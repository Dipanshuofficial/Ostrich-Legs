This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where line numbers have been added.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: client/src/**/*, server/src/**/*, shared/**/*, *.md, package.json, client/package.json, server/package.json, client/tsconfig*.json, server/tsconfig.json, client/vite.config.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<user_provided_header>
OSTRICH-LEGS: Distributed Compute Platform Context
</user_provided_header>

<directory_structure>
client/package.json
client/src/App.tsx
client/src/components/Card.tsx
client/src/components/ErrorBoundary.tsx
client/src/contexts/SwarmContext.tsx
client/src/core/constants.ts
client/src/core/SocketManager.ts
client/src/core/swarmStore.ts
client/src/core/theme.css
client/src/core/types.ts
client/src/features/connection/DeviceConnector.tsx
client/src/features/dashboard/ActiveSwarm.tsx
client/src/features/dashboard/JobGauge.tsx
client/src/features/dashboard/ResourceStats.tsx
client/src/features/dashboard/SwarmControls.tsx
client/src/features/dashboard/ThrottleControl.tsx
client/src/features/dashboard/VelocityMonitor.tsx
client/src/features/terminal/LiveTerminal.tsx
client/src/hooks/useMediaQuery.ts
client/src/hooks/usePersistentIdentity.ts
client/src/hooks/useSocket.ts
client/src/hooks/useWorker.ts
client/src/main.tsx
client/src/utils/compute.worker.ts
client/src/utils/metrics.ts
client/tsconfig.app.json
client/tsconfig.json
client/tsconfig.node.json
client/vite.config.ts
README.md
server/package.json
server/src/core/types.ts
server/src/index.ts
server/src/managers/AuthManager.ts
server/src/managers/DeviceManager.ts
server/src/managers/JobScheduler.ts
server/tsconfig.json
shared/socket/events.ts
shared/socket/payloads.ts
shared/socket/states.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/src/components/Card.tsx">
 1: import { type ReactNode } from "react";
 2: import { clsx, type ClassValue } from "clsx";
 3: import { twMerge } from "tailwind-merge";
 4: 
 5: function cn(...inputs: ClassValue[]) {
 6:   return twMerge(clsx(inputs));
 7: }
 8: 
 9: interface CardProps {
10:   children: ReactNode;
11:   className?: string;
12:   variant?: "flat" | "elevated" | "glass";
13: }
14: 
15: export const Card = ({
16:   children,
17:   className,
18:   variant = "elevated",
19: }: CardProps) => {
20:   const variants = {
21:     flat: "bg-surface-white border border-border-soft",
22:     elevated: "soft-card",
23:     glass: "bg-white/70 backdrop-blur-md border border-white/20 shadow-lg",
24:   };
25: 
26:   return <div className={cn(variants[variant], className)}>{children}</div>;
27: };
</file>

<file path="client/src/components/ErrorBoundary.tsx">
 1: // client/src/components/ErrorBoundary.tsx - NEW FILE
 2: import { Component, type ErrorInfo, type ReactNode } from "react";
 3: 
 4: interface Props {
 5:   children: ReactNode;
 6:   fallback?: ReactNode;
 7: }
 8: 
 9: interface State {
10:   hasError: boolean;
11:   error?: Error;
12: }
13: 
14: export class ErrorBoundary extends Component<Props, State> {
15:   state: State = { hasError: false };
16: 
17:   static getDerivedStateFromError(error: Error): State {
18:     return { hasError: true, error };
19:   }
20: 
21:   componentDidCatch(error: Error, errorInfo: ErrorInfo) {
22:     console.error("ErrorBoundary caught:", error, errorInfo);
23:     // Could send to error tracking service here
24:   }
25: 
26:   render() {
27:     if (this.state.hasError) {
28:       return (
29:         this.props.fallback || (
30:           <div className="min-h-screen flex items-center justify-center bg-surface-muted">
31:             <div className="bg-white p-8 rounded-2xl shadow-lg max-w-md text-center">
32:               <h2 className="text-xl font-bold text-red-600 mb-4">
33:                 Something went wrong
34:               </h2>
35:               <p className="text-gray-600 mb-4">
36:                 The application encountered an error. Please refresh the page.
37:               </p>
38:               <button
39:                 onClick={() => window.location.reload()}
40:                 className="bg-brand-orange text-white px-6 py-2 rounded-xl font-bold"
41:               >
42:                 Reload Application
43:               </button>
44:             </div>
45:           </div>
46:         )
47:       );
48:     }
49: 
50:     return this.props.children;
51:   }
52: }
</file>

<file path="client/src/contexts/SwarmContext.tsx">
 1: // client/src/contexts/SwarmContext.tsx
 2: import { createContext, useContext, type ReactNode, useMemo } from "react";
 3: import {
 4:   type SwarmSnapshot,
 5:   type DeviceInfo,
 6:   type SwarmStatus,
 7: } from "../core/types";
 8: import { useSocket } from "../hooks/useSocket";
 9: import { useSwarmStore } from "../core/swarmStore";
10: import { useWorker } from "../hooks/useWorker";
11: 
12: interface SwarmContextType {
13:   snapshot: SwarmSnapshot | null;
14:   devices: DeviceInfo[];
15:   isConnected: boolean;
16:   logs: string[];
17:   actions: {
18:     setRunState: (state: SwarmStatus) => void;
19:     setThrottle: (value: number) => void;
20:     toggleDevice: (id: string, enabled: boolean) => void;
21:     runLocalBenchmark: () => void;
22:     generateInviteToken: () => Promise<string>;
23:     leaveSwarm: () => void;
24:     manualJoin: (code: string) => Promise<void>;
25:   };
26: }
27: 
28: const SwarmContext = createContext<SwarmContextType | undefined>(undefined);
29: 
30: export const SwarmProvider = ({ children }: { children: ReactNode }) => {
31:   const { snapshot, isConnected, logs } = useSwarmStore();
32: 
33:   // 1. Initialize Worker Logic
34:   const { runLocalBenchmark, executeJob } = useWorker();
35: 
36:   // 2. Initialize Socket Logic with Worker Bridge
37:   const socketActions = useSocket(executeJob);
38: 
39:   const devices = useMemo(
40:     () => (snapshot ? Object.values(snapshot.devices) : []),
41:     [snapshot],
42:   );
43: 
44:   const value = useMemo(
45:     () => ({
46:       snapshot,
47:       devices,
48:       isConnected,
49:       logs,
50:       actions: {
51:         ...socketActions,
52:         runLocalBenchmark, // Now provided by the real useWorker hook
53:       },
54:     }),
55:     [snapshot, devices, isConnected, logs, socketActions, runLocalBenchmark],
56:   );
57: 
58:   return (
59:     <SwarmContext.Provider value={value}>{children}</SwarmContext.Provider>
60:   );
61: };
62: 
63: export const useSwarm = () => {
64:   const context = useContext(SwarmContext);
65:   if (!context) throw new Error("useSwarm must be used within a SwarmProvider");
66:   return context;
67: };
</file>

<file path="client/src/core/constants.ts">
1: export const MAX_SAFE_THROTTLE_PERCENT = 75; // Hard cap – never exceed this % of device cores
</file>

<file path="client/src/core/SocketManager.ts">
 1: import { io, Socket } from "socket.io-client";
 2: 
 3: class SocketManager {
 4:   private socket: Socket | null = null;
 5:   private currentToken: string | null = null;
 6: 
 7:   get(persistentId: string, token: string | null = null) {
 8:     const t = token || "";
 9:     // Ensure we don't recreate the socket if identity and token haven't changed
10:     if (this.socket?.connected && this.currentToken === t) {
11:       return this.socket;
12:     }
13: 
14:     // Token mismatch or disconnected: Kill and rebuild
15:     this.socket?.disconnect();
16:     this.currentToken = t;
17: 
18:     const url = window.location.hostname.includes("trycloudflare.com")
19:       ? "/"
20:       : `http://${window.location.hostname}:3000`;
21: 
22:     this.socket = io(url, {
23:       query: { persistentId, token: t },
24:       auth: { token: t },
25:       transports: ["websocket", "polling"],
26:       reconnection: true,
27:       reconnectionDelay: 800,
28:       path: "/socket.io/",
29:     });
30: 
31:     return this.socket;
32:   }
33: 
34:   disconnect() {
35:     this.socket?.disconnect();
36:     this.socket = null;
37:     this.currentToken = null;
38:   }
39: }
40: 
41: export const socketManager = new SocketManager();
</file>

<file path="client/src/core/swarmStore.ts">
 1: import { create } from "zustand";
 2: import { type SwarmSnapshot } from "../core/types";
 3: import { type LogLevel } from "@shared/socket/states";
 4: 
 5: interface SwarmState {
 6:   snapshot: SwarmSnapshot | null;
 7:   logs: string[];
 8:   isConnected: boolean;
 9:   setSnapshot: (s: SwarmSnapshot | null) => void;
10:   setConnected: (c: boolean) => void;
11:   addLog: (level: LogLevel, message: string) => void;
12: }
13: 
14: export const useSwarmStore = create<SwarmState>((set) => ({
15:   snapshot: null,
16:   logs: [],
17:   isConnected: false,
18:   setSnapshot: (s) => set({ snapshot: s }),
19:   setConnected: (c) => set({ isConnected: c }),
20:   addLog: (level, message) =>
21:     set((state) => {
22:       const time = new Date().toLocaleTimeString().split(" ")[0];
23:       const newLog = `[${time}] [${level}] ${message}`;
24:       return { logs: [...state.logs.slice(-49), newLog] };
25:     }),
26: }));
</file>

<file path="client/src/features/dashboard/ResourceStats.tsx">
 1: import { Database, Zap, Activity } from "lucide-react";
 2: import { Card } from "../../components/Card";
 3: import { type SwarmStats } from "../../core/types";
 4: 
 5: interface Props {
 6:   stats: SwarmStats;
 7:   onlineCount: number;
 8: }
 9: 
10: export const ResourceStats = ({ stats, onlineCount }: Props) => {
11:   return (
12:     <div className="grid grid-cols-1 md:grid-cols-3 gap-5">
13:       <StatItem
14:         label="Online Nodes"
15:         value={onlineCount}
16:         icon={<Database size={18} className="text-blue-600" />}
17:         gradient="from-blue-50 to-blue-100/50"
18:         border="border-blue-100"
19:       />
20:       <StatItem
21:         label="Active Jobs"
22:         value={stats.activeJobs}
23:         icon={<Activity size={18} className="text-brand-orange" />}
24:         gradient="from-orange-50 to-orange-100/50"
25:         border="border-orange-100"
26:       />
27:       <StatItem
28:         label="Pending"
29:         value={stats.pendingJobs}
30:         icon={<Zap size={18} className="text-purple-600" />}
31:         gradient="from-purple-50 to-purple-100/50"
32:         border="border-purple-100"
33:       />
34:     </div>
35:   );
36: };
37: 
38: const StatItem = ({ label, value, icon, gradient, border }: any) => (
39:   <Card
40:     className={`p-5 bg-linear-to-br ${gradient} border ${border} hover:-translate-y-1 transition-transform duration-300 shadow-sm`}
41:   >
42:     <div className="flex justify-between items-start">
43:       <div>
44:         <p className="text-[10px] font-black text-text-muted uppercase tracking-widest mb-2">
45:           {label}
46:         </p>
47:         <p className="text-3xl font-black text-text-main tracking-tight">
48:           {value.toLocaleString()}
49:         </p>
50:       </div>
51:       <div className="p-3 bg-white rounded-xl shadow-sm border border-white/50">
52:         {icon}
53:       </div>
54:     </div>
55:   </Card>
56: );
</file>

<file path="client/src/hooks/useMediaQuery.ts">
 1: import { useState, useEffect } from "react";
 2: 
 3: export function useMediaQuery(query: string): boolean {
 4:   const [matches, setMatches] = useState(
 5:     () => window.matchMedia(query).matches,
 6:   );
 7: 
 8:   useEffect(() => {
 9:     const media = window.matchMedia(query);
10:     const listener = () => setMatches(media.matches);
11:     media.addEventListener("change", listener);
12:     return () => media.removeEventListener("change", listener);
13:   }, [query]);
14: 
15:   return matches;
16: }
</file>

<file path="client/src/hooks/useSocket.ts">
  1: // client/src/hooks/useSocket.ts
  2: import { useCallback, useEffect } from "react";
  3: import { socketManager } from "../core/SocketManager";
  4: import { SocketEvents } from "@shared/socket/events";
  5: import { useSwarmStore } from "../core/swarmStore";
  6: import { usePersistentIdentity } from "./usePersistentIdentity";
  7: import { type SwarmStatus, type Job } from "../core/types";
  8: 
  9: export const useSocket = (onJobReceived?: (job: Job) => void) => {
 10:   const { identity, swarmToken, saveSwarmToken, clearSwarmToken } =
 11:     usePersistentIdentity();
 12:   const { setSnapshot, setConnected, addLog, snapshot } = useSwarmStore();
 13: 
 14:   const getSocket = useCallback(() => {
 15:     return socketManager.get(identity.id, swarmToken);
 16:   }, [identity.id, swarmToken]);
 17: 
 18:   useEffect(() => {
 19:     if (!identity.id || identity.id === "loading-identity") return;
 20: 
 21:     const socket = getSocket();
 22: 
 23:     socket.on(SocketEvents.CONNECT, () => {
 24:       setConnected(true);
 25:       addLog("NET", "Swarm Link Established");
 26:       socket.emit(SocketEvents.DEVICE_REGISTER, {
 27:         name: localStorage.getItem("ostrich_device_name") || "Local Node",
 28:         capabilities: {
 29:           cpuCores: navigator.hardwareConcurrency || 4,
 30:           memoryGB: (navigator as any).deviceMemory || 8,
 31:           gpuAvailable: !!(navigator as any).gpu,
 32:         },
 33:       });
 34:       // Immediately request work if the swarm is already running
 35:       socket.emit(SocketEvents.JOB_REQUEST_BATCH);
 36:     });
 37: 
 38:     socket.on("disconnect", () => setConnected(false));
 39: 
 40:     socket.on(SocketEvents.SWARM_SNAPSHOT, (data) => {
 41:       const previousState = snapshot?.runState;
 42:       setSnapshot(data);
 43:       // If state just changed to RUNNING, kickstart the pipeline
 44:       if (previousState !== "RUNNING" && data.runState === "RUNNING") {
 45:         socket.emit(SocketEvents.JOB_REQUEST_BATCH);
 46:       }
 47:     });
 48: 
 49:     socket.on(SocketEvents.JOB_BATCH_DISPATCH, (jobs: Job[]) => {
 50:       if (onJobReceived) {
 51:         jobs.forEach((job) => onJobReceived(job));
 52:       }
 53:     });
 54: 
 55:     socket.on(SocketEvents.SYSTEM_LOG, (p) => addLog(p.level, p.message));
 56: 
 57:     return () => {
 58:       socket.off(SocketEvents.CONNECT);
 59:       socket.off("disconnect");
 60:       socket.off(SocketEvents.SWARM_SNAPSHOT);
 61:       socket.off(SocketEvents.JOB_BATCH_DISPATCH);
 62:       socket.off(SocketEvents.SYSTEM_LOG);
 63:     };
 64:   }, [
 65:     identity.id,
 66:     getSocket,
 67:     setConnected,
 68:     setSnapshot,
 69:     addLog,
 70:     onJobReceived,
 71:     snapshot?.runState,
 72:   ]);
 73: 
 74:   // Orchestration Actions
 75:   const setRunState = (s: SwarmStatus) =>
 76:     getSocket().emit(SocketEvents.SWARM_SET_STATE, s);
 77:   const setThrottle = (v: number) =>
 78:     getSocket().emit(SocketEvents.SWARM_SET_THROTTLE, v);
 79:   const toggleDevice = (id: string, enabled: boolean) =>
 80:     getSocket().emit("cmd:toggle_device", { id, enabled });
 81: 
 82:   const manualJoin = async (code: string) => {
 83:     saveSwarmToken(code);
 84:     const socket = socketManager.get(identity.id, code);
 85:     return new Promise<void>((res, rej) => {
 86:       socket.once("connect", () => res());
 87:       socket.once("connect_error", (err) => rej(err));
 88:       setTimeout(() => rej(new Error("Join Timeout")), 5000);
 89:     });
 90:   };
 91: 
 92:   const leaveSwarm = () => {
 93:     clearSwarmToken();
 94:     socketManager.disconnect();
 95:     window.location.href = window.location.origin;
 96:   };
 97: 
 98:   const generateInviteToken = () =>
 99:     new Promise<string>((res) => getSocket().emit("auth:generate_token", res));
100: 
101:   return {
102:     setRunState,
103:     setThrottle,
104:     toggleDevice,
105:     manualJoin,
106:     leaveSwarm,
107:     generateInviteToken,
108:   };
109: };
</file>

<file path="client/src/hooks/useWorker.ts">
  1: // client/src/hooks/useWorker.ts
  2: import { useEffect, useRef, useCallback } from "react";
  3: import { useSwarmStore } from "../core/swarmStore";
  4: import { socketManager } from "../core/SocketManager";
  5: import { SocketEvents } from "@shared/socket/events";
  6: import { usePersistentIdentity } from "./usePersistentIdentity";
  7: import { MAX_SAFE_THROTTLE_PERCENT } from "../core/constants";
  8: import ComputeWorker from "../utils/compute.worker?worker";
  9: import { metrics } from "../utils/metrics";
 10: 
 11: export const useWorker = () => {
 12:   const workerRef = useRef<Worker | null>(null);
 13:   const { identity, swarmToken } = usePersistentIdentity();
 14:   const { snapshot, addLog } = useSwarmStore();
 15: 
 16:   const handleWorkerMessage = useCallback(
 17:     (e: MessageEvent) => {
 18:       const {
 19:         type,
 20:         score,
 21:         chunkId,
 22:         result,
 23:         error,
 24:         message,
 25:         level,
 26:         durationMs,
 27:       } = e.data;
 28:       const socket = socketManager.get(identity.id, swarmToken);
 29: 
 30:       switch (type) {
 31:         case "WORKER_LOG":
 32:           addLog(level || "SYS", message);
 33:           break;
 34:         case "BENCHMARK_COMPLETE":
 35:           socket.emit(SocketEvents.BENCHMARK_RESULT, { score });
 36:           addLog("CPU", `Benchmark: ${score.toLocaleString()} OPS/s`);
 37:           break;
 38:         case "JOB_COMPLETE":
 39:           if (durationMs) {
 40:             metrics.record("job_execution_time", durationMs);
 41:           }
 42:           socket.emit(SocketEvents.JOB_COMPLETE, {
 43:             chunkId,
 44:             result,
 45:             workerId: identity.id,
 46:             durationMs,
 47:           });
 48:           socket.emit(SocketEvents.JOB_REQUEST_BATCH);
 49:           break;
 50:         case "JOB_ERROR":
 51:           addLog("ERR", `Job ${chunkId} failed: ${error}`);
 52:           socket.emit(SocketEvents.JOB_COMPLETE, {
 53:             chunkId,
 54:             error,
 55:             workerId: identity.id,
 56:           });
 57:           socket.emit(SocketEvents.JOB_REQUEST_BATCH);
 58:           break;
 59:       }
 60:     },
 61:     [identity.id, swarmToken, addLog],
 62:   );
 63: 
 64:   // Initialize Worker
 65:   useEffect(() => {
 66:     if (!workerRef.current) {
 67:       workerRef.current = new ComputeWorker();
 68:     }
 69:     workerRef.current.onmessage = handleWorkerMessage;
 70: 
 71:     return () => {
 72:       workerRef.current?.terminate();
 73:       workerRef.current = null;
 74:     };
 75:   }, [handleWorkerMessage]);
 76: 
 77:   // Sync Throttle with Worker Thread Pool
 78:   useEffect(() => {
 79:     if (!workerRef.current) return;
 80: 
 81:     const globalThrottle = snapshot?.stats.globalThrottle ?? 40;
 82:     const safeThrottle =
 83:       Math.min(globalThrottle, MAX_SAFE_THROTTLE_PERCENT) / 100;
 84: 
 85:     workerRef.current.postMessage({
 86:       type: "CONFIG_UPDATE",
 87:       payload: { throttle: safeThrottle },
 88:     });
 89:   }, [snapshot?.stats.globalThrottle]);
 90: 
 91:   const runLocalBenchmark = useCallback(() => {
 92:     const socket = socketManager.get(identity.id, swarmToken);
 93:     socket.emit(SocketEvents.HEARTBEAT, { lastInteraction: Date.now() });
 94:     addLog("SYS", "Manual Benchmark Triggered");
 95:     workerRef.current?.postMessage({ type: "BENCHMARK" });
 96:   }, [identity.id, swarmToken, addLog]);
 97: 
 98:   const executeJob = useCallback((job: any) => {
 99:     workerRef.current?.postMessage({ type: "EXECUTE_JOB", payload: job });
100:   }, []);
101: 
102:   return { runLocalBenchmark, executeJob };
103: };
</file>

<file path="client/src/utils/metrics.ts">
 1: export class MetricsCollector {
 2:   private metrics: Map<string, number[]> = new Map();
 3: 
 4:   /**
 5:    * Records a new data point for a specific metric.
 6:    * Limits storage to the last 1000 values to prevent memory leaks.
 7:    */
 8:   record(metric: string, value: number) {
 9:     if (!this.metrics.has(metric)) {
10:       this.metrics.set(metric, []);
11:     }
12: 
13:     const stream = this.metrics.get(metric)!;
14:     stream.push(value);
15: 
16:     // Keep last 1000 values (Memory Boundary)
17:     if (stream.length > 1000) {
18:       stream.shift();
19:     }
20:   }
21: 
22:   /**
23:    * Calculates the moving average for a metric.
24:    */
25:   getAverage(metric: string): number {
26:     const values = this.metrics.get(metric) || [];
27:     if (values.length === 0) return 0;
28:     const sum = values.reduce((a, b) => a + b, 0);
29:     return sum / values.length;
30:   }
31: 
32:   /**
33:    * Returns the most recent value recorded.
34:    */
35:   getLatest(metric: string): number {
36:     const values = this.metrics.get(metric) || [];
37:     return values.length > 0 ? values[values.length - 1] : 0;
38:   }
39: }
40: 
41: // Export a singleton instance for app-wide tracking
42: export const metrics = new MetricsCollector();
</file>

<file path="client/tsconfig.json">
1: {
2:   "files": [],
3:   "references": [
4:     { "path": "./tsconfig.app.json" },
5:     { "path": "./tsconfig.node.json" }
6:   ]
7: }
</file>

<file path="client/tsconfig.node.json">
 1: {
 2:   "compilerOptions": {
 3:     "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
 4:     "target": "ES2023",
 5:     "lib": ["ES2023"],
 6:     "module": "ESNext",
 7:     "types": ["node"],
 8:     "skipLibCheck": true,
 9: 
10:     /* Bundler mode */
11:     "moduleResolution": "bundler",
12:     "allowImportingTsExtensions": true,
13:     "verbatimModuleSyntax": true,
14:     "moduleDetection": "force",
15:     "noEmit": true,
16: 
17:     /* Linting */
18:     "strict": true,
19:     "noUnusedLocals": true,
20:     "noUnusedParameters": true,
21:     "erasableSyntaxOnly": true,
22:     "noFallthroughCasesInSwitch": true,
23:     "noUncheckedSideEffectImports": true
24:   },
25:   "include": ["vite.config.ts"]
26: }
</file>

<file path="README.md">
  1: # Ostrich-Legs
  2: 
  3: A distributed computing platform that transforms browsers into a collaborative compute swarm. Think SETI@home, but your "supercomputer" is a mesh of phones, laptops, and tablets orchestrated in real-time via WebSockets.
  4: 
  5: ![TypeScript](https://img.shields.io/badge/TypeScript-5.9-blue?logo=typescript)
  6: ![React](https://img.shields.io/badge/React-19-61DAFB?logo=react)
  7: ![Bun](https://img.shields.io/badge/Bun-Runtime-black?logo=bun)
  8: ![Socket.io](https://img.shields.io/badge/Socket.io-4.8-white?logo=socket.io)
  9: ![Tailwind](https://img.shields.io/badge/Tailwind-4.1-06B6D4?logo=tailwindcss)
 10: 
 11: ## What It Does
 12: 
 13: Ostrich-Legs enables any device with a browser to join a compute swarm and contribute processing power toward distributed workloads:
 14: 
 15: - **Zero-Install Workers**: Devices join via QR code, invite links, or manual token entry
 16: - **Weighted Job Distribution**: Scheduler allocates jobs proportional to device capability (CPU cores + GPU availability + benchmark scores)
 17: - **Real-Time Control**: Live throttle adjustment (0-100%), pause/resume/stop states, per-device enable/disable
 18: - **WebGPU Support**: Matrix multiplication kernels with graceful CPU fallback
 19: - **Persistent Identity**: Devices maintain stable IDs across sessions via localStorage
 20: 
 21: ## Architecture
 22: 
 23: ```
 24: ┌─────────────────────────────────────────────────────────────────┐
 25: │                     DISTRIBUTED COMPUTE SWARM                     │
 26: │                                                                   │
 27: │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐           │
 28: │  │   Desktop    │  │   Mobile     │  │   Tablet     │           │
 29: │  │   (Worker)   │  │   (Worker)   │  │   (Master)   │           │
 30: │  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘           │
 31: │         │                 │                 │                    │
 32: │         └─────────────────┴─────────────────┘                    │
 33: │                           │                                      │
 34: │                    WebSocket (Socket.io)                         │
 35: │                           │                                      │
 36: │              ┌────────────┴────────────┐                        │
 37: │              │      Bun Server         │                        │
 38: │              │  ┌─────────────────┐    │                        │
 39: │              │  │ DeviceManager   │    │  - Registration       │
 40: │              │  │ JobScheduler    │    │  - Weighted dispatch  │
 41: │              │  │ AuthManager     │    │  - Token lifecycle    │
 42: │              │  └─────────────────┘    │                        │
 43: │              └─────────────────────────┘                        │
 44: └─────────────────────────────────────────────────────────────────┘
 45: ```
 46: 
 47: ### Stack
 48: 
 49: | Layer         | Technology            | Purpose                                      |
 50: | ------------- | --------------------- | -------------------------------------------- |
 51: | **Frontend**  | React 19 + Vite + SWC | Component-based UI with fast HMR             |
 52: | **State**     | Zustand               | Lightweight global state management          |
 53: | **Styling**   | Tailwind CSS v4       | Utility-first design system                  |
 54: | **Real-Time** | Socket.io             | Bidirectional event streaming with rooms     |
 55: | **Backend**   | Bun + Socket.io       | High-performance runtime, 2s broadcast loops |
 56: | **Compute**   | Web Workers + WebGPU  | Browser-based parallel processing            |
 57: | **Types**     | Shared `/shared`      | Compile-time API contracts across boundaries |
 58: 
 59: ## Quick Start
 60: 
 61: Prerequisites: [Bun](https://bun.sh) runtime
 62: 
 63: ```bash
 64: # 1. Clone and enter
 65: cd ostrich-legs
 66: 
 67: # 2. Start the server
 68: cd server && bun run dev
 69: 
 70: # 3. In another terminal, start the client
 71: cd client && bun run dev
 72: 
 73: # 4. Open http://localhost:5173
 74: ```
 75: 
 76: The first browser becomes the swarm master. Click the share icon to generate QR codes for other devices to join.
 77: 
 78: ## Key Design Decisions
 79: 
 80: ### Type-Safe Socket Contracts
 81: 
 82: All client-server communication uses strictly typed contracts in `/shared/socket/`:
 83: 
 84: ```typescript
 85: // shared/socket/events.ts - Single source of truth
 86: SocketEvents.DEVICE_REGISTER; // "device:register"
 87: SocketEvents.JOB_BATCH_DISPATCH; // "job:batch"
 88: SocketEvents.SWARM_THROTTLE_SYNC; // "swarm:throttle_sync"
 89: ```
 90: 
 91: This eliminates runtime errors at the network boundary through TypeScript's compile-time checking.
 92: 
 93: ### Weighted Job Scheduling
 94: 
 95: The scheduler calculates device weights from real-time capability profiles:
 96: 
 97: ```typescript
 98: // server/src/managers/JobScheduler.ts:34-38
 99: weight = (cpuCores × 10) + (gpuAvailable ? 50 : 0) + min(opsScore / 1000, 100)
100: ```
101: 
102: Jobs dispatch proportionally by weight with dynamic quota adjustment. The scheduler recalculates weights every 10 seconds based on live benchmark scores, ensuring optimal distribution as device performance changes.
103: 
104: ### Dynamic Worker Thread Pool
105: 
106: The compute layer spawns threads based on device capabilities and global throttle:
107: 
108: ```typescript
109: // client/src/utils/compute.worker.ts:5-8
110: TOTAL_CORES = navigator.hardwareConcurrency || 4;
111: RESERVED_CORES = TOTAL_CORES > 8 ? 2 : 1;
112: LOGICAL_CORES = Math.max(1, TOTAL_CORES - RESERVED_CORES);
113: targetThreads = Math.floor(LOGICAL_CORES × throttlePercent);
114: ```
115: 
116: Workers execute in sandboxed Blob URLs with automatic WebGPU→CPU fallback. The pool scales up/down dynamically as throttle changes.
117: 
118: ### Hierarchical State Management
119: 
120: ```
121: Zustand Store (swarmStore.ts)
122:     │
123:     ├── snapshot: SwarmSnapshot    ← Server broadcasts every 2s
124:     ├── logs: string[]             ← Circular buffer (last 50)
125:     └── isConnected: boolean
126:     │
127: SwarmContext.tsx
128:     │
129:     ├── useSocket()                ← Socket.io lifecycle
130:     ├── useWorker()                ← Web Worker orchestration
131:     └── Actions exposed to UI
132: ```
133: 
134: This separation keeps socket/worker logic out of React render cycles while providing reactive UI updates.
135: 
136: ### Auth Middleware Flow
137: 
138: ```typescript
139: // server/src/index.ts:45-70
140: if (no_token_or_empty) {
141:   socket.data.swarmId = persistentId; // Master mode
142: } else if (valid_token) {
143:   socket.data.swarmId = targetSwarm; // Worker joins existing
144: } else {
145:   reject("JOIN_CODE_INVALID"); // Expired/invalid
146: }
147: ```
148: 
149: Tokens have 15-minute TTL, rate-limited to 5/minute per swarm. No user accounts required—just stable device identities.
150: 
151: ### Persistent Identity
152: 
153: Devices maintain stable identities across sessions:
154: 
155: ```
156: ostrich_device_id     → node-${random(36)}     (permanent)
157: ostrich_device_name   → "Desktop Node" etc.    (platform detection)
158: ```
159: 
160: This enables reliable reconnection, historical tracking, and automatic re-registration without server-side accounts.
161: 
162: ## Project Structure
163: 
164: ```
165: ostrich-legs/
166: ├── client/                    # React 19 frontend
167: │   ├── src/
168: │   │   ├── features/         # Domain modules
169: │   │   │   ├── connection/   # QR/invite joining
170: │   │   │   ├── dashboard/    # Metrics & controls
171: │   │   │   └── terminal/     # Live logging
172: │   │   ├── hooks/            # Custom hooks
173: │   │   │   ├── useSocket.ts  # Socket.io lifecycle
174: │   │   │   ├── useWorker.ts  # Web Worker bridge
175: │   │   │   └── usePersistentIdentity.ts
176: │   │   ├── core/             # State & types
177: │   │   │   ├── swarmStore.ts # Zustand store
178: │   │   │   ├── SocketManager.ts
179: │   │   │   └── types.ts
180: │   │   └── utils/            # Web Workers
181: │   │       └── compute.worker.ts
182: │   └── package.json
183: ├── server/                    # Bun backend
184: │   ├── src/
185: │   │   ├── managers/         # Business logic
186: │   │   │   ├── DeviceManager.ts    # Lifecycle & health
187: │   │   │   ├── JobScheduler.ts     # Weighted dispatch
188: │   │   │   └── AuthManager.ts      # Token generation
189: │   │   ├── core/types.ts
190: │   │   └── index.ts          # Socket.io server
191: │   └── package.json
192: └── shared/                    # Cross-boundary contracts
193:     └── socket/
194:         ├── events.ts          # Event name registry
195:         ├── payloads.ts        # Request/response types
196:         └── states.ts          # State enumerations
197: ```
198: 
199: ## Use Cases
200: 
201: - **Distributed Computation**: Farm out math-heavy workloads (matrix ops, simulations) to idle devices
202: - **Load Testing**: Stress-test with real heterogeneous hardware and network conditions
203: - **Edge Computing POC**: Validate compute-offloading before cloud deployment
204: - **Educational**: Demonstrate distributed systems, Web Workers, and Socket.io patterns
205: 
206: ## Performance Characteristics
207: 
208: | Metric               | Value                           | Implementation                    |
209: | -------------------- | ------------------------------- | --------------------------------- |
210: | State broadcast      | 2s interval                     | `setInterval` with room filtering |
211: | Job generation       | 100 jobs/sec                    | Capped at 5,000 queue depth       |
212: | Weight recalculation | 10s interval                    | Dynamic based on `opsScore`       |
213: | Device heartbeat     | Client 10s / Server 60s timeout | Graceful degradation              |
214: | Worker threads       | `LOGICAL_CORES × throttle`      | Dynamic Blob URL workers          |
215: | Log retention        | 50 entries                      | Circular buffer in Zustand        |
216: | Token TTL            | 15 minutes                      | Rate-limited to 5/min             |
217: 
218: ## Trade-offs & Limitations
219: 
220: **In-Memory State**: Device registry and job queues use Maps. Horizontal scaling would require Redis for sticky sessions and state synchronization.
221: 
222: **No Persistence**: Job results are ephemeral—acknowledged then discarded. Designed for compute workloads, not data archival.
223: 
224: **Browser Constraints**: WebGPU support varies (Chrome/Edge best). Automatic CPU fallback adds ~20% latency but ensures universal compatibility.
225: 
226: **Single Server**: Current architecture assumes single-node deployment. Multi-server would need Redis adapter and load balancer with sticky sessions.
227: 
228: ## License
229: 
230: MIT
</file>

<file path="shared/socket/events.ts">
 1: export const SocketEvents = {
 2:   // Connection Lifecycle
 3:   CONNECT: "connect",
 4:   DISCONNECT: "disconnect",
 5:   CONNECTION_ERROR: "connect_error",
 6: 
 7:   // Identity & Registration
 8:   DEVICE_REGISTER: "device:register",
 9:   DEVICE_READY: "device:ready",
10:   HEARTBEAT: "heartbeat",
11: 
12:   // Swarm Orchestration
13:   SWARM_SNAPSHOT: "swarm:snapshot",
14:   SWARM_SET_STATE: "cmd:set_run_state",
15:   SWARM_SET_THROTTLE: "cmd:set_throttle",
16:   SWARM_THROTTLE_SYNC: "swarm:throttle_sync",
17: 
18:   // Job Pipeline
19:   JOB_REQUEST_BATCH: "job:request_batch",
20:   JOB_BATCH_DISPATCH: "job:batch",
21:   JOB_COMPLETE: "job:complete",
22: 
23:   // Diagnostics & Terminal
24:   SYSTEM_LOG: "sys:log",
25:   BENCHMARK_START: "cmd:run_benchmark",
26:   BENCHMARK_RESULT: "benchmark:result",
27: } as const;
28: 
29: export type SocketEvent = (typeof SocketEvents)[keyof typeof SocketEvents];
</file>

<file path="shared/socket/payloads.ts">
 1: import { SwarmRunState, DeviceConnectionStatus, LogLevel } from "./states";
 2: 
 3: export interface DeviceRegisterPayload {
 4:   name: string;
 5:   capabilities: {
 6:     cpuCores: number;
 7:     memoryGB: number;
 8:     gpuAvailable: boolean;
 9:     gpuName?: string;
10:   };
11: }
12: 
13: export interface JobCompletePayload {
14:   chunkId: string;
15:   workerId: string;
16:   result?: any;
17:   error?: string;
18:   durationMs?: number;
19: }
20: 
21: export interface SwarmSnapshotPayload {
22:   runState: SwarmRunState;
23:   devices: Record<string, any>; // Will be refined in Phase 2
24:   stats: {
25:     totalJobs: number;
26:     completedJobs: number;
27:     activeJobs: number;
28:     globalVelocity: number;
29:     globalThrottle: number;
30:   };
31: }
</file>

<file path="shared/socket/states.ts">
 1: // Strict states for the compute engine
 2: export type SwarmRunState = "IDLE" | "RUNNING" | "PAUSED" | "STOPPED";
 3: 
 4: // Device lifecycle states
 5: export type DeviceConnectionStatus = "OFFLINE" | "ONLINE" | "BUSY" | "DISABLED";
 6: 
 7: // Log levels for the Terminal
 8: export type LogLevel = "SYS" | "NET" | "CPU" | "GPU" | "ERR" | "WARN";
 9: 
10: export interface SystemLogPayload {
11:   level: LogLevel;
12:   message: string;
13:   timestamp: number;
14:   source?: string;
15: }
</file>

<file path="client/src/core/types.ts">
 1: /** * Strict Domain Model for Ostrich Swarm
 2:  */
 3: 
 4: export type SwarmStatus = "IDLE" | "RUNNING" | "PAUSED" | "STOPPED";
 5: export type DeviceType = "DESKTOP" | "MOBILE" | "COLAB" | "SERVER";
 6: export type JobType = "MATH_STRESS" | "MAT_MUL" | "TEXT_TOKENIZE";
 7: 
 8: export interface DeviceCapabilities {
 9:   cpuCores: number;
10:   memoryGB: number;
11:   gpuAvailable: boolean;
12:   gpuName?: string;
13: }
14: 
15: export interface DeviceInfo {
16:   id: string;
17:   name: string;
18:   type: DeviceType;
19:   status: "ONLINE" | "BUSY" | "OFFLINE" | "DISABLED";
20:   capabilities: DeviceCapabilities;
21:   opsScore: number;
22:   totalJobsCompleted: number;
23:   lastHeartbeat: number;
24: }
25: 
26: export interface SwarmResources {
27:   totalCores: number;
28:   totalMemory: number;
29:   totalGPUs: number;
30:   onlineCount: number;
31: }
32: 
33: export interface Job {
34:   id: string;
35:   type: JobType;
36:   complexity: number;
37:   data: any;
38: }
39: 
40: export interface SwarmSnapshot {
41:   runState: SwarmStatus;
42:   devices: Record<string, DeviceInfo>;
43:   stats: {
44:     totalJobs: number;
45:     activeJobs: number;
46:     pendingJobs: number;
47:     completedJobs: number;
48:     globalVelocity: number;
49:     globalThrottle?: number;
50:   };
51:   resources: SwarmResources;
52: }
</file>

<file path="client/src/features/dashboard/ActiveSwarm.tsx">
  1: import { Smartphone, Laptop, Server, Cpu, Play } from "lucide-react";
  2: import { Card } from "../../components/Card";
  3: import { type DeviceInfo } from "../../core/types";
  4: 
  5: interface ActiveSwarmProps {
  6:   devices: DeviceInfo[];
  7:   onBenchmark: () => void;
  8:   onToggle: (id: string, state: boolean) => void;
  9: }
 10: 
 11: export const ActiveSwarm = ({
 12:   devices,
 13:   onBenchmark,
 14:   onToggle,
 15: }: ActiveSwarmProps) => {
 16:   const getIcon = (type: string) => {
 17:     switch (type) {
 18:       case "MOBILE":
 19:         return <Smartphone size={18} />;
 20:       case "SERVER":
 21:         return <Server size={18} />;
 22:       case "COLAB":
 23:         return <Cpu size={18} />;
 24:       default:
 25:         return <Laptop size={18} />;
 26:     }
 27:   };
 28: 
 29:   return (
 30:     <Card className="flex flex-col h-full bg-surface-white relative overflow-hidden p-4 sm:p-6">
 31:       <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 gap-4">
 32:         <div>
 33:           <h3 className="font-bold text-lg text-text-main">Swarm Nodes</h3>
 34:           <p className="text-xs text-text-muted">Manage active resources</p>
 35:         </div>
 36:         <button
 37:           onClick={onBenchmark}
 38:           className="w-full sm:w-auto flex items-center justify-center gap-2 bg-gray-900 hover:bg-black text-white px-4 py-2.5 rounded-xl text-xs font-bold transition-all active:scale-95 shadow-lg shadow-gray-900/20"
 39:         >
 40:           <Play size={12} fill="currentColor" />
 41:           Benchmark All
 42:         </button>
 43:       </div>
 44: 
 45:       <div className="flex-1 overflow-y-auto space-y-3 pr-1 custom-scrollbar">
 46:         {devices.map((device) => {
 47:           const isDisabled = device.status === "DISABLED";
 48:           const isLocal =
 49:             device.id.includes("node-") || device.name === "Local Host";
 50: 
 51:           return (
 52:             <div
 53:               key={device.id}
 54:               className={`flex flex-col md:flex-row md:items-center justify-between p-4 rounded-2xl border transition-all duration-300 gap-4 ${
 55:                 isDisabled
 56:                   ? "bg-gray-50 border-transparent opacity-60"
 57:                   : "bg-white border-gray-100 hover:border-brand-orange/30 shadow-sm"
 58:               }`}
 59:             >
 60:               {/* Left Section: Identity */}
 61:               <div className="flex items-center gap-3">
 62:                 <div
 63:                   className={`p-3 rounded-xl shrink-0 ${
 64:                     isDisabled
 65:                       ? "bg-gray-200 text-gray-400"
 66:                       : "bg-surface-muted text-brand-orange"
 67:                   }`}
 68:                 >
 69:                   {getIcon(device.type)}
 70:                 </div>
 71:                 <div className="min-w-0">
 72:                   <div className="flex items-center gap-2 flex-wrap">
 73:                     <h4 className="text-sm font-bold text-text-main truncate">
 74:                       {device.name}
 75:                     </h4>
 76:                     {isLocal && (
 77:                       <span className="text-[9px] bg-brand-orange/10 text-brand-orange px-1.5 py-0.5 rounded font-bold border border-brand-orange/20 uppercase tracking-tighter">
 78:                         YOU
 79:                       </span>
 80:                     )}
 81:                   </div>
 82:                   <div className="flex items-center gap-2 mt-0.5">
 83:                     <span
 84:                       className={`w-1.5 h-1.5 rounded-full shrink-0 ${
 85:                         isDisabled
 86:                           ? "bg-gray-400"
 87:                           : device.status === "ONLINE"
 88:                             ? "bg-green-500"
 89:                             : "bg-amber-500"
 90:                       }`}
 91:                     />
 92:                     <span className="text-[10px] font-bold text-text-muted uppercase truncate">
 93:                       {device.status === "ONLINE"
 94:                         ? `${device.capabilities.cpuCores} Cores Online`
 95:                         : device.status}
 96:                     </span>
 97:                   </div>
 98:                 </div>
 99:               </div>
100: 
101:               {/* Right Section: Stats & Toggle */}
102:               <div className="flex items-center justify-between md:justify-end gap-4 md:gap-8 border-t md:border-t-0 pt-3 md:pt-0">
103:                 <div className="flex gap-6">
104:                   {/* Job Counter */}
105:                   <div className="text-left md:text-right min-w-15">
106:                     <div className="font-mono text-sm font-black text-text-main">
107:                       {device.totalJobsCompleted || 0}
108:                     </div>
109:                     <div className="text-[9px] font-bold text-text-muted uppercase tracking-tighter">
110:                       Jobs
111:                     </div>
112:                   </div>
113: 
114:                   {/* OPS Score */}
115:                   <div className="text-left md:text-right min-w-17.5">
116:                     <div className="font-mono text-sm font-black text-brand-orange">
117:                       {device.opsScore > 0
118:                         ? device.opsScore.toLocaleString()
119:                         : "---"}
120:                     </div>
121:                     <div className="text-[9px] font-bold text-text-muted uppercase tracking-tighter">
122:                       OPS Score
123:                     </div>
124:                   </div>
125:                 </div>
126: 
127:                 <button
128:                   onClick={() => onToggle(device.id, isDisabled)}
129:                   className={`w-11 h-6 rounded-full p-1 transition-colors relative shrink-0 ${
130:                     !isDisabled ? "bg-green-500" : "bg-gray-300"
131:                   }`}
132:                 >
133:                   <div
134:                     className={`w-4 h-4 rounded-full bg-white shadow-sm transition-transform duration-200 ${
135:                       !isDisabled ? "translate-x-5" : "translate-x-0"
136:                     }`}
137:                   />
138:                 </button>
139:               </div>
140:             </div>
141:           );
142:         })}
143: 
144:         {devices.length === 0 && (
145:           <div className="text-center py-10">
146:             <p className="text-sm text-text-muted italic">
147:               Waiting for swarm nodes...
148:             </p>
149:           </div>
150:         )}
151:       </div>
152:     </Card>
153:   );
154: };
</file>

<file path="client/src/features/dashboard/JobGauge.tsx">
 1: import { Card } from "../../components/Card";
 2: 
 3: interface Props {
 4:   readonly total: number;
 5:   readonly completed: number;
 6: }
 7: 
 8: export const JobGauge = ({ total, completed }: Props) => {
 9:   const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
10:   const radius = 45;
11:   const circumference = 2 * Math.PI * radius;
12:   const strokeDashoffset = circumference - (percentage / 100) * circumference;
13: 
14:   return (
15:     <Card className="flex flex-col items-center justify-center p-6 bg-surface-white">
16:       <div className="relative w-40 h-40 mb-4">
17:         {/* Rotated SVG container to start from 12 o'clock */}
18:         <svg className="w-full h-full -rotate-90" viewBox="0 0 128 128">
19:           {/* Background Track */}
20:           {/* JobGauge.tsx line 24 */}
21:           <circle
22:             cx="64"
23:             cy="64"
24:             r={radius}
25:             stroke="var(--color-surface-muted)" // Dynamic color
26:             strokeWidth="12"
27:             fill="transparent"
28:             strokeLinecap="round"
29:           />
30:           {/* Active Progress */}
31:           <circle
32:             cx="64"
33:             cy="64"
34:             r={radius}
35:             stroke="#ff7d54"
36:             strokeWidth="12"
37:             fill="transparent"
38:             strokeDasharray={circumference}
39:             strokeDashoffset={strokeDashoffset}
40:             strokeLinecap="round"
41:             className="transition-all duration-1000 ease-out"
42:           />
43:         </svg>
44: 
45:         {/* Center Text (Counter-rotated to stay upright) */}
46:         <div className="absolute inset-0 flex flex-col items-center justify-center">
47:           <span className="text-3xl font-black text-text-main">{total}</span>
48:           <span className="text-[10px] font-bold text-text-muted uppercase tracking-widest">
49:             Total Jobs
50:           </span>
51:         </div>
52:       </div>
53: 
54:       <div className="w-full space-y-2 px-2">
55:         <div className="flex justify-between text-[10px] font-bold text-text-muted uppercase">
56:           <span>Progress</span>
57:           <span>{percentage}%</span>
58:         </div>
59:         <div className="w-full h-2 bg-gray-100 rounded-full overflow-hidden shadow-inner">
60:           <div
61:             className="h-full bg-brand-orange transition-all duration-500"
62:             style={{ width: `${percentage}%` }}
63:           />
64:         </div>
65:       </div>
66:     </Card>
67:   );
68: };
</file>

<file path="client/src/features/dashboard/ThrottleControl.tsx">
 1: import { Card } from "../../components/Card";
 2: import { Cpu, Server, Box } from "lucide-react";
 3: import { MAX_SAFE_THROTTLE_PERCENT } from "../../core/constants";
 4: 
 5: interface Props {
 6:   value: number;
 7:   onChange: (val: number) => void;
 8:   totalCores: number;
 9:   totalMemory: number;
10:   totalGPUs: number;
11: }
12: 
13: export const ThrottleControl = ({
14:   value,
15:   onChange,
16:   totalCores = 0,
17:   totalMemory = 0,
18:   totalGPUs = 0,
19: }: Props) => {
20:   const safeValue = Math.min(value, MAX_SAFE_THROTTLE_PERCENT);
21:   const percent = safeValue / 100;
22: 
23:   const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
24:     const newVal = parseInt(e.target.value);
25:     onChange(Math.min(newVal, MAX_SAFE_THROTTLE_PERCENT)); // hard clamp
26:   };
27: 
28:   return (
29:     <Card className="relative overflow-hidden group p-5 bg-surface-white">
30:       <div className="flex justify-between items-center mb-6">
31:         <div>
32:           <h3 className="font-bold text-sm text-text-muted uppercase tracking-widest">
33:             Global Allocation
34:           </h3>
35:           <p className="text-2xl font-black text-text-main">{safeValue}%</p>
36:         </div>
37: 
38:         <div className="flex flex-wrap gap-2 justify-end max-w-45">
39:           <div className="flex items-center gap-1.5 bg-gray-50 px-2 py-1 rounded-lg border border-gray-100">
40:             <Cpu size={12} className="text-brand-orange" />
41:             <span className="text-[10px] font-bold text-gray-600">
42:               {Math.round(totalCores * percent)} / {totalCores}
43:             </span>
44:           </div>
45:           <div className="flex items-center gap-1.5 bg-gray-50 px-2 py-1 rounded-lg border border-gray-100">
46:             <Server size={12} className="text-blue-500" />
47:             <span className="text-[10px] font-bold text-gray-600">
48:               {Math.round(totalMemory * percent)} GB
49:             </span>
50:           </div>
51:           <div
52:             className={`flex items-center gap-1.5 px-2 py-1 rounded-lg border ${totalGPUs > 0 ? "bg-purple-50 border-purple-100" : "bg-gray-50 border-gray-100 opacity-50"}`}
53:           >
54:             <Box
55:               size={12}
56:               className={totalGPUs > 0 ? "text-purple-600" : "text-gray-400"}
57:             />
58:             <span
59:               className={`text-[10px] font-bold ${totalGPUs > 0 ? "text-purple-700" : "text-gray-400"}`}
60:             >
61:               {totalGPUs} GPU{totalGPUs !== 1 ? "s" : ""}
62:             </span>
63:           </div>
64:         </div>
65:       </div>
66: 
67:       <input
68:         type="range"
69:         min="10"
70:         max="100"
71:         step="5"
72:         value={safeValue}
73:         onChange={handleChange}
74:         className="w-full h-2 bg-gray-100 rounded-lg appearance-none cursor-pointer accent-brand-orange transition-all hover:bg-gray-200"
75:       />
76: 
77:       <div className="flex justify-between mt-3 text-[10px] font-bold text-text-muted uppercase tracking-tighter">
78:         <span>Eco Mode</span>
79:         <span>Balanced</span>
80:         <span>Max Performance</span>
81:       </div>
82: 
83:       <div className="text-[9px] text-amber-600 mt-2 text-center font-medium">
84:         Hard safety cap: {MAX_SAFE_THROTTLE_PERCENT}% (prevents device freeze)
85:       </div>
86:     </Card>
87:   );
88: };
</file>

<file path="server/package.json">
 1: {
 2:   "name": "ostrich-server",
 3:   "version": "1.0.0",
 4:   "type": "module",
 5:   "scripts": {
 6:     "dev": "bun src/index.ts"
 7:   },
 8:   "dependencies": {
 9:     "cors": "^2.8.6",
10:     "express": "^5.2.1",
11:     "http": "^0.0.1-security",
12:     "socket.io": "^4.8.3"
13:   },
14:   "devDependencies": {
15:     "@types/cors": "^2.8.13",
16:     "@types/express": "^4.17.17",
17:     "@types/node": "^25.2.1",
18:     "ts-node": "^10.9.1",
19:     "typescript": "^5.1.6"
20:   }
21: }
</file>

<file path="server/src/managers/JobScheduler.ts">
  1: import { type Job, type DeviceInfo } from "../core/types";
  2: 
  3: interface DeviceJobQuota {
  4:   deviceId: string;
  5:   weight: number;
  6:   activeJobs: number;
  7:   maxConcurrent: number;
  8: }
  9: 
 10: export class JobScheduler {
 11:   private jobQueue: Job[] = [];
 12:   private deviceQuotas = new Map<string, DeviceJobQuota>();
 13:   private deviceWeights = new Map<string, number>();
 14:   private totalWeight = 0;
 15:   private readonly MAX_QUEUE_SIZE = 5000;
 16: 
 17:   constructor() {
 18:     setInterval(() => this.generateJobs(), 1000);
 19:   }
 20: 
 21:   private generateJobs() {
 22:     if (this.jobQueue.length > this.MAX_QUEUE_SIZE) return;
 23:     for (let i = 0; i < 100; i++) {
 24:       const isGpuTask = Math.random() > 0.7;
 25:       this.jobQueue.push({
 26:         id: `job-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`,
 27:         type: isGpuTask ? "MAT_MUL" : "MATH_STRESS",
 28:         complexity: Math.floor(Math.random() * 10) + 1,
 29:         data: isGpuTask ? { size: 1024 } : { iterations: 100000 },
 30:       });
 31:     }
 32:   }
 33: 
 34:   private calculateWeight(device: DeviceInfo): number {
 35:     const cpu = (device.capabilities.cpuCores || 4) * 10;
 36:     const gpu = device.capabilities.gpuAvailable ? 50 : 0;
 37:     const score = Math.min((device.opsScore || 0) / 1000, 100);
 38:     return Math.max(1, cpu + gpu + score);
 39:   }
 40: 
 41:   public registerDevice(device: DeviceInfo) {
 42:     const weight = this.calculateWeight(device);
 43:     const old = this.deviceWeights.get(device.id) || 0;
 44:     this.totalWeight += weight - old;
 45:     this.deviceWeights.set(device.id, weight);
 46: 
 47:     this.deviceQuotas.set(device.id, {
 48:       deviceId: device.id,
 49:       weight,
 50:       activeJobs: 0,
 51:       maxConcurrent: Math.max(10, (device.capabilities.cpuCores || 4) * 4),
 52:     });
 53:   }
 54: 
 55:   public getJobBatchForDevice(
 56:     device: DeviceInfo,
 57:     requestedCount: number = 10,
 58:   ): Job[] {
 59:     const quota = this.deviceQuotas.get(device.id);
 60:     if (!quota) {
 61:       this.registerDevice(device);
 62:       return this.getJobBatchForDevice(device, requestedCount);
 63:     }
 64: 
 65:     const availableSlots = quota.maxConcurrent - quota.activeJobs;
 66:     if (availableSlots <= 0) return [];
 67: 
 68:     const weight = this.deviceWeights.get(device.id) || 1;
 69:     const share = Math.max(
 70:       1,
 71:       Math.floor((weight / Math.max(1, this.totalWeight)) * requestedCount * 3),
 72:     );
 73: 
 74:     const batchSize = Math.min(share, availableSlots, this.jobQueue.length);
 75: 
 76:     const batch: Job[] = [];
 77:     const preferred = device.capabilities.gpuAvailable
 78:       ? "MAT_MUL"
 79:       : "MATH_STRESS";
 80: 
 81:     for (let i = 0; i < batchSize; i++) {
 82:       let idx = this.jobQueue.findIndex((j) => j.type === preferred);
 83:       if (idx === -1) idx = 0;
 84:       if (idx < this.jobQueue.length) {
 85:         batch.push(this.jobQueue.splice(idx, 1)[0]);
 86:         quota.activeJobs++;
 87:       }
 88:     }
 89:     return batch;
 90:   }
 91: 
 92:   public releaseJobSlot(deviceId: string, durationMs?: number) {
 93:     const quota = this.deviceQuotas.get(deviceId);
 94:     if (quota && quota.activeJobs > 0) {
 95:       quota.activeJobs--;
 96: 
 97:       // If we got duration data, we could refine the weight here
 98:       if (durationMs && durationMs > 0) {
 99:         // Example: Penalize weight if jobs are taking > 2000ms
100:         const latencyImpact = durationMs > 2000 ? 0.95 : 1.02;
101:         quota.weight *= latencyImpact;
102:       }
103:     }
104:   }
105: 
106:   public getQueueStats() {
107:     return {
108:       pending: this.jobQueue.length,
109:       active: Array.from(this.deviceQuotas.values()).reduce(
110:         (sum, q) => sum + q.activeJobs,
111:         0,
112:       ),
113:     };
114:   }
115: }
</file>

<file path="server/tsconfig.json">
 1: {
 2:   "compilerOptions": {
 3:     "target": "ES2023",
 4:     "lib": ["ES2023"],
 5:     "module": "ESNext",
 6:     "types": ["node"],
 7:     "skipLibCheck": true,
 8:     "baseUrl": ".",
 9:     "paths": {
10:       "@shared/*": ["../shared/*"]
11:     },
12: 
13:     /* Bundler mode */
14:     "moduleResolution": "bundler",
15:     "allowImportingTsExtensions": true,
16:     "verbatimModuleSyntax": true,
17:     "moduleDetection": "force",
18:     "noEmit": true,
19: 
20:     /* Linting */
21:     "strict": true,
22:     "noUnusedLocals": true,
23:     "noUnusedParameters": true,
24:     "erasableSyntaxOnly": true,
25:     "noFallthroughCasesInSwitch": true,
26:     "noUncheckedSideEffectImports": true
27:   }
28: }
</file>

<file path="client/src/core/theme.css">
  1: @import "tailwindcss";
  2: @theme {
  3:   /* 1. DEFINE DESIGN TOKENS (One Source of Truth) */
  4:   --color-brand-orange: #ff7d54;
  5:   --color-brand-peach: #ffb09c;
  6: 
  7:   /* Use variables for surface/text colors to allow easy switching */
  8:   --color-surface-white: var(--surface-white);
  9:   --color-surface-muted: var(--surface-muted);
 10:   --color-text-main: var(--text-main);
 11:   --color-text-muted: var(--text-muted);
 12:   --color-border-soft: var(--border-soft);
 13: 
 14:   /* Elevation (Adapt for Dark Mode) */
 15:   --shadow-card: var(--card-shadow);
 16: }
 17: 
 18: @layer base {
 19:   /* 2. LIGHT MODE (Default) */
 20:   :root {
 21:     --surface-white: #fcfcfd;
 22:     --surface-muted: #f3f4f6;
 23:     --text-main: #1a1a1e;
 24:     --text-muted: #6b7280;
 25:     --border-soft: rgba(0, 0, 0, 0.05);
 26:     --card-shadow: 0 20px 40px -12px rgba(0, 0, 0, 0.05);
 27:   }
 28: 
 29:   /* 3. DARK MODE (Override) */
 30:   .dark {
 31:     /* ELEVATED SURFACES (Not pure black) */
 32:     --surface-white: #1a1a1e; /* Card surface */
 33:     --surface-muted: #0f0f11; /* Background surface */
 34: 
 35:     /* TEXT HIERARCHY */
 36:     --text-main: #fcfcfd;
 37:     --text-muted: #94a3b8;
 38: 
 39:     /* BORDERS & DEPTH */
 40:     --border-soft: rgba(255, 255, 255, 0.06);
 41: 
 42:     /* NEUMORPHIC GLOW (The secret sauce) */
 43:     --card-shadow:
 44:       0 10px 30px -5px rgba(0, 0, 0, 0.5),
 45:       0 0 15px -3px rgba(255, 125, 84, 0.05); /* Subtle brand glow */
 46: 
 47:     color-scheme: dark;
 48:   }
 49: 
 50:   body {
 51:     @apply bg-surface-muted text-text-main transition-colors duration-300;
 52:   }
 53: }
 54: 
 55: /* Ensure the dark variant is recognized by custom class logic */
 56: /* client/src/core/theme.css */
 57: 
 58: @layer components {
 59:   .soft-card {
 60:     @apply bg-surface-white border border-border-soft shadow-card rounded-2xl p-6 transition-all;
 61:     /* Subtle inner-glow for dark mode depth */
 62:     background-image: linear-gradient(
 63:       to bottom right,
 64:       rgba(255, 255, 255, 0.02),
 65:       transparent
 66:     );
 67:   }
 68: 
 69:   /* Fix for the Dashboard navigation and header glass effect */
 70:   .backdrop-blur-md {
 71:     @apply dark:bg-surface-white/80 dark:border-white/5;
 72:   }
 73:   
 74:   /* Modern Scrollbar */
 75:   ::-webkit-scrollbar {
 76:     width: 6px;
 77:   }
 78:   ::-webkit-scrollbar-thumb {
 79:     @apply bg-gray-200 rounded-full hover:bg-gray-300;
 80:   }
 81: }
 82: @custom-variant dark (&:where(.dark, .dark *));
 83: @keyframes scan {
 84:   0% {
 85:     top: 10%;
 86:   }
 87:   50% {
 88:     top: 90%;
 89:   }
 90:   100% {
 91:     top: 10%;
 92:   }
 93: }
 94: @keyframes shake {
 95:   0%,
 96:   100% {
 97:     transform: translateX(0);
 98:   }
 99:   25% {
100:     transform: translateX(-4px);
101:   }
102:   75% {
103:     transform: translateX(4px);
104:   }
105: }
106: .animate-shake {
107:   animation: shake 0.2s ease-in-out 0s 2;
108: }
</file>

<file path="client/src/features/terminal/LiveTerminal.tsx">
 1: import { useEffect, useRef, memo } from "react";
 2: import { Terminal, Activity } from "lucide-react";
 3: import { Card } from "../../components/Card";
 4: 
 5: interface Props {
 6:   logs: string[];
 7: }
 8: 
 9: const LogLine = memo(({ log, index }: { log: string; index: number }) => {
10:   const isErr = log.includes("[ERR]");
11:   const isSys = log.includes("[SYS]");
12:   const isNet = log.includes("[NET]");
13: 
14:   return (
15:     <div className="flex gap-3 leading-relaxed border-b border-gray-100/30 pb-1 last:border-0">
16:       <span className="text-gray-400 select-none font-bold w-8">
17:         {(index + 1).toString().padStart(3, "0")}
18:       </span>
19:       <span
20:         className={`font-medium ${isErr ? "text-red-500" : isSys ? "text-blue-600" : isNet ? "text-green-600" : "text-gray-600"}`}
21:       >
22:         {log}
23:       </span>
24:     </div>
25:   );
26: });
27: 
28: LogLine.displayName = "LogLine";
29: 
30: export const LiveTerminal = ({ logs }: Props) => {
31:   const scrollRef = useRef<HTMLDivElement>(null);
32: 
33:   useEffect(() => {
34:     if (scrollRef.current) {
35:       scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
36:     }
37:   }, [logs]);
38: 
39:   return (
40:     <Card className="h-full flex flex-col relative overflow-hidden bg-surface-white border border-border-soft shadow-soft-depth">
41:       <div className="flex items-center justify-between px-5 py-3 bg-[#e9ecef] border-b border-white rounded-t-xl shadow-sm z-10">
42:         <div className="flex items-center gap-2.5">
43:           <Terminal size={12} className="text-text-main" />
44:           <span className="text-[10px] font-black text-text-main/80 tracking-widest uppercase">
45:             System Log
46:           </span>
47:         </div>
48:         <div className="flex bg-surface-white px-3 py-1 rounded-lg border border-white/50 shadow-inner">
49:           <Activity
50:             size={10}
51:             className="text-brand-orange animate-pulse mr-2"
52:           />
53:           <span className="text-[9px] font-bold text-brand-orange uppercase">
54:             Realtime
55:           </span>
56:         </div>
57:       </div>
58: 
59:       <div
60:         ref={scrollRef}
61:         className="flex-1 p-5 font-mono text-[11px] overflow-y-auto space-y-1 bg-surface-muted/30"
62:       >
63:         {logs.length === 0 && (
64:           <span className="text-gray-400 italic">
65:             Listening for swarm events...
66:           </span>
67:         )}
68:         {logs.map((log, i) => (
69:           <LogLine key={i} log={log} index={i} />
70:         ))}
71:       </div>
72:     </Card>
73:   );
74: };
</file>

<file path="client/src/main.tsx">
 1: import { StrictMode } from "react";
 2: import { createRoot } from "react-dom/client";
 3: import "./core/theme.css";
 4: import App from "./App.tsx";
 5: import { ErrorBoundary } from "./components/ErrorBoundary.tsx";
 6: import { SwarmProvider } from "./contexts/SwarmContext.tsx";
 7: 
 8: createRoot(document.getElementById("root")!).render(
 9:   <StrictMode>
10:     <ErrorBoundary>
11:       <SwarmProvider>
12:         <App />
13:       </SwarmProvider>
14:     </ErrorBoundary>
15:   </StrictMode>,
16: );
</file>

<file path="client/tsconfig.app.json">
 1: {
 2:   "compilerOptions": {
 3:     "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
 4:     "target": "ES2022",
 5:     "useDefineForClassFields": true,
 6:     "lib": ["ES2022", "DOM", "DOM.Iterable"],
 7:     "module": "ESNext",
 8:     "types": ["vite/client", "node"],
 9:     "skipLibCheck": true,
10:     "baseUrl": ".",
11:     "paths": {
12:       "@shared/*": ["../shared/*"]
13:     },
14:     /* Bundler mode */
15:     "moduleResolution": "bundler",
16:     "allowImportingTsExtensions": true,
17:     "verbatimModuleSyntax": true,
18:     "moduleDetection": "force",
19:     "noEmit": true,
20:     "jsx": "react-jsx",
21: 
22:     /* Linting */
23:     "strict": true,
24:     "noUnusedLocals": true,
25:     "noUnusedParameters": true,
26:     "erasableSyntaxOnly": true,
27:     "noFallthroughCasesInSwitch": true,
28:     "noUncheckedSideEffectImports": true
29:   },
30:   "include": ["src"]
31: }
</file>

<file path="server/src/managers/AuthManager.ts">
 1: export class AuthManager {
 2:   private activeTokens = new Map<
 3:     string,
 4:     { swarmId: string; expiresAt: number }
 5:   >();
 6:   private readonly TOKEN_TTL_MS = 24 * 60 * 60 * 1000;
 7:   private tokenGenerationLog = new Map<string, number[]>(); // swarmId -> timestamps
 8:   constructor() {
 9:     setInterval(() => this.cleanup(), 30000);
10:   }
11: 
12:   /**
13:    * Generates a unique 6-digit alphanumeric token for a specific swarm.
14:    */
15:   public generateToken(swarmId: string): string | null {
16:     const now = Date.now();
17:     let generations = this.tokenGenerationLog.get(swarmId) || [];
18:     const oneMinuteAgo = now - 60000;
19:     generations = generations.filter((t) => t > oneMinuteAgo);
20: 
21:     if (generations.length >= 5) {
22:       return null; // Rate limited
23:     }
24: 
25:     generations.push(now);
26:     this.tokenGenerationLog.set(swarmId, generations);
27: 
28:     const token = Math.random().toString(36).substring(2, 8).toUpperCase();
29:     this.activeTokens.set(token, {
30:       swarmId,
31:       expiresAt: Date.now() + this.TOKEN_TTL_MS,
32:     });
33: 
34:     return token;
35:   }
36: 
37:   /**
38:    * Validates a token and returns the associated swarmId.
39:    * This is the "Party Join" mechanism.
40:    */
41:   public validateToken(token: string): string | null {
42:     const data = this.activeTokens.get(token);
43: 
44:     if (!data) return null;
45: 
46:     if (Date.now() > data.expiresAt) {
47:       this.activeTokens.delete(token);
48:       return null;
49:     }
50: 
51:     return data.swarmId;
52:   }
53: 
54:   private cleanup() {
55:     const now = Date.now();
56:     for (const [token, data] of this.activeTokens.entries()) {
57:       if (now > data.expiresAt) this.activeTokens.delete(token);
58:     }
59:   }
60: }
</file>

<file path="client/package.json">
 1: {
 2:   "name": "client",
 3:   "private": true,
 4:   "version": "0.0.0",
 5:   "type": "module",
 6:   "scripts": {
 7:     "dev": "vite --host",
 8:     "build": "tsc -b && vite build",
 9:     "lint": "eslint .",
10:     "preview": "vite preview"
11:   },
12:   "dependencies": {
13:     "@tailwindcss/vite": "^4.1.18",
14:     "clsx": "^2.1.1",
15:     "framer-motion": "^12.33.0",
16:     "html5-qrcode": "^2.3.8",
17:     "lucide-react": "^0.563.0",
18:     "qrcode.react": "^4.2.0",
19:     "react": "^19.2.0",
20:     "react-dom": "^19.2.0",
21:     "recharts": "^3.7.0",
22:     "socket.io-client": "^4.8.3",
23:     "tailwind-merge": "^3.4.0",
24:     "tailwindcss": "^4.1.18",
25:     "zustand": "^5.0.11"
26:   },
27:   "devDependencies": {
28:     "@eslint/js": "^9.39.1",
29:     "@types/node": "^24.10.1",
30:     "@types/react": "^19.2.5",
31:     "@types/react-dom": "^19.2.3",
32:     "@vitejs/plugin-react-swc": "^4.2.2",
33:     "eslint": "^9.39.1",
34:     "eslint-plugin-react-hooks": "^7.0.1",
35:     "eslint-plugin-react-refresh": "^0.4.24",
36:     "globals": "^16.5.0",
37:     "typescript": "~5.9.3",
38:     "typescript-eslint": "^8.46.4",
39:     "vite": "^7.2.4"
40:   }
41: }
</file>

<file path="client/vite.config.ts">
 1: import { defineConfig } from "vite";
 2: import react from "@vitejs/plugin-react-swc";
 3: import tailwindcss from "@tailwindcss/vite";
 4: import path from "path";
 5: // https://vite.dev/config/
 6: export default defineConfig({
 7:   plugins: [react(), tailwindcss()],
 8:   server: {
 9:     allowedHosts: true,
10:     host: true,
11:     proxy: {
12:       // Forward all requests starting with /api to the backend
13:       "/api": {
14:         target: "http://localhost:3000",
15:         changeOrigin: true,
16:       },
17:       // Also proxy the socket.io connection
18:       "/socket.io": {
19:         target: "http://localhost:3000",
20:         secure: false,
21:         changeOrigin: true,
22:         ws: true,
23:       },
24:     },
25:   },
26:   resolve: {
27:     alias: {
28:       // Points @shared to the actual folder outside /client
29:       "@shared": path.resolve(__dirname, "../shared"),
30:     },
31:   },
32: });
</file>

<file path="server/src/core/types.ts">
 1: // server/src/core/types.ts
 2: export type DeviceType = "DESKTOP" | "MOBILE" | "COLAB" | "SERVER";
 3: export type JobType = "MATH_STRESS" | "MAT_MUL" | "TEXT_TOKENIZE";
 4: // Added REGISTERED to the flow
 5: export type DeviceConnectionStatus =
 6:   | "OFFLINE"
 7:   | "ONLINE"
 8:   | "BUSY"
 9:   | "DISABLED"
10:   | "REGISTERED";
11: 
12: export interface DeviceCapabilities {
13:   cpuCores: number;
14:   memoryGB: number;
15:   gpuAvailable: boolean;
16:   gpuName?: string;
17: }
18: 
19: export interface DeviceInfo {
20:   id: string;
21:   name: string;
22:   type: DeviceType;
23:   status: DeviceConnectionStatus;
24:   capabilities: DeviceCapabilities;
25:   opsScore: number;
26:   totalJobsCompleted: number;
27:   lastHeartbeat: number;
28:   lastUserInteraction: number;
29:   swarmId?: string;
30: }
31: 
32: // ... rest of the file remains same
33: export interface SwarmResources {
34:   totalCores: number;
35:   totalMemory: number;
36:   totalGPUs: number;
37:   onlineCount: number;
38: }
39: 
40: export interface Job {
41:   id: string;
42:   type: JobType;
43:   complexity: number;
44:   data: any;
45: }
46: 
47: export interface SwarmSnapshot {
48:   runState: "IDLE" | "RUNNING" | "PAUSED" | "STOPPED";
49:   devices: Record<string, DeviceInfo>;
50:   stats: {
51:     totalJobs: number;
52:     activeJobs: number;
53:     pendingJobs: number;
54:     completedJobs: number;
55:     globalVelocity: number;
56:     globalThrottle: number;
57:   };
58:   resources: SwarmResources;
59: }
</file>

<file path="client/src/features/dashboard/SwarmControls.tsx">
  1: import { Play, Pause, Square } from "lucide-react";
  2: import { Card } from "../../components/Card";
  3: 
  4: interface SwarmControlsProps {
  5:   readonly status: "IDLE" | "RUNNING" | "PAUSED" | "STOPPED";
  6:   readonly onToggle: () => void;
  7:   readonly onStop: () => void;
  8: }
  9: 
 10: export const SwarmControls = ({
 11:   status,
 12:   onToggle,
 13:   onStop,
 14: }: SwarmControlsProps) => {
 15:   const isRunning = status === "RUNNING";
 16: 
 17:   return (
 18:     <Card className="p-5 bg-surface-white">
 19:       <h3 className="font-bold text-sm text-text-muted uppercase tracking-widest mb-4">
 20:         Master Control
 21:       </h3>
 22: 
 23:       <div className="grid grid-cols-2 gap-4">
 24:         {/* Start/Pause: Orange by default, Emerald on Hover */}
 25:         <button
 26:           onClick={() => {
 27:             console.log("CLICKED TOGGLE");
 28:             onToggle();
 29:           }}
 30:           className={`
 31:             h-20 rounded-2xl flex flex-col items-center justify-center gap-2 transition-all duration-200 active:scale-[0.95]
 32:             border group
 33:             ${
 34:               isRunning
 35:                 ? "bg-brand-orange/5 border-brand-orange/20 shadow-inner"
 36:                 : "bg-surface-white shadow-[6px_6px_12px_#d1d5db,-6px_-6px_12px_#ffffff] border-white hover:bg-emerald-50 hover:border-emerald-100"
 37:             }
 38:           `}
 39:         >
 40:           <div
 41:             className={`p-2 rounded-full transition-colors ${
 42:               isRunning
 43:                 ? "bg-brand-orange text-white shadow-[0_0_10px_rgba(255,125,84,0.4)]"
 44:                 : "text-text-muted bg-gray-100 group-hover:bg-emerald-100 group-hover:text-emerald-600"
 45:             }`}
 46:           >
 47:             {isRunning ? (
 48:               <Pause size={24} fill="currentColor" />
 49:             ) : (
 50:               <Play size={24} fill="currentColor" className="ml-0.5" />
 51:             )}
 52:           </div>
 53:           <span
 54:             className={`text-[10px] font-black uppercase transition-colors ${
 55:               isRunning
 56:                 ? "text-brand-orange"
 57:                 : "text-text-muted group-hover:text-emerald-600"
 58:             }`}
 59:           >
 60:             {isRunning ? "Pause Swarm" : "Start Swarm"}
 61:           </span>
 62:         </button>
 63: 
 64:         {/* Kill Process: Gray by default, Red on Hover */}
 65:         <button
 66:           onClick={() => {
 67:             if (
 68:               window.confirm(
 69:                 "KILL PROCESS? This will terminate all active local threads.",
 70:               )
 71:             ) {
 72:               onStop();
 73:             }
 74:           }}
 75:           className={`
 76:             h-20 rounded-2xl flex flex-col items-center justify-center gap-2 transition-all duration-200 active:scale-[0.98]
 77:             border group
 78:             ${
 79:               status === "STOPPED"
 80:                 ? "bg-red-50 border-red-200 shadow-inner"
 81:                 : "bg-surface-white shadow-[6px_6px_12px_#d1d5db,-6px_-6px_12px_#ffffff] border-white hover:bg-red-50 hover:border-red-100"
 82:             }
 83:           `}
 84:         >
 85:           <div
 86:             className={`p-2 rounded-full transition-colors ${
 87:               status === "STOPPED"
 88:                 ? "bg-red-500 text-white"
 89:                 : "text-text-muted bg-gray-100 group-hover:bg-red-100 group-hover:text-red-500"
 90:             }`}
 91:           >
 92:             <Square size={24} fill="currentColor" />
 93:           </div>
 94:           <span
 95:             className={`text-[10px] font-black uppercase transition-colors ${
 96:               status === "STOPPED"
 97:                 ? "text-red-600"
 98:                 : "text-text-muted group-hover:text-red-600"
 99:             }`}
100:           >
101:             {status === "STOPPED" ? "System Killed" : "Kill Process"}
102:           </span>
103:         </button>
104:       </div>
105: 
106:       {/* Status LED Panel */}
107:       <div className="mt-6 flex items-center justify-between soft-inset p-3 border border-black/5 dark:border-white/5">
108:         <span className="text-xs font-bold text-text-muted">System State</span>
109:         <div className="flex items-center gap-2">
110:           <div
111:             className={`w-2 h-2 rounded-full ${
112:               isRunning
113:                 ? "bg-brand-orange shadow-[0_0_8px_rgba(255,125,84,0.8)]"
114:                 : "bg-red-500"
115:             }`}
116:           />
117:           <span className="font-mono text-xs font-bold text-text-main">
118:             {status}
119:           </span>
120:         </div>
121:       </div>
122:     </Card>
123:   );
124: };
</file>

<file path="client/src/features/dashboard/VelocityMonitor.tsx">
  1: import { useEffect, useRef } from "react";
  2: import { Card } from "../../components/Card";
  3: import { Activity } from "lucide-react";
  4: 
  5: interface VelocityMonitorProps {
  6:   readonly velocity: number;
  7:   readonly throttle: number;
  8: }
  9: 
 10: export const VelocityMonitor = ({
 11:   velocity,
 12:   throttle,
 13: }: VelocityMonitorProps) => {
 14:   const canvasRef = useRef<HTMLCanvasElement>(null);
 15:   const dataRef = useRef<number[]>(new Array(60).fill(0));
 16:   const requestRef = useRef<number>(0);
 17: 
 18:   const getColor = (val: number) => {
 19:     if (val < 30) return "#22c55e";
 20:     if (val < 70) return "#ff7d54";
 21:     return "#ef4444";
 22:   };
 23:   // 1. OPTIMIZATION: Frame Rate Throttling
 24:   const lastFrameTime = useRef<number>(0);
 25:   const FRAME_INTERVAL = 1000 / 30; // 30 FPS target
 26: 
 27:   useEffect(() => {
 28:     const canvas = canvasRef.current;
 29:     if (!canvas) return;
 30: 
 31:     const ctx = canvas.getContext("2d", { alpha: false });
 32:     if (!ctx) return;
 33: 
 34:     const dpr = window.devicePixelRatio || 1;
 35:     const rect = canvas.getBoundingClientRect();
 36:     canvas.width = rect.width * dpr;
 37:     canvas.height = rect.height * dpr;
 38:     ctx.scale(dpr, dpr);
 39: 
 40:     // 2. UPDATED ANIMATION LOOP
 41:     const animate = (timestamp: number) => {
 42:       // Check if enough time has passed to render the next frame
 43:       if (timestamp - lastFrameTime.current < FRAME_INTERVAL) {
 44:         requestRef.current = requestAnimationFrame(animate);
 45:         return;
 46:       }
 47:       lastFrameTime.current = timestamp;
 48: 
 49:       // Update Data
 50:       dataRef.current.shift();
 51:       dataRef.current.push(velocity);
 52: 
 53:       // Render logic (Preserved from original for design consistency)
 54:       ctx.fillStyle = "#fcfcfd";
 55:       ctx.fillRect(0, 0, rect.width, rect.height);
 56: 
 57:       const activeColor = getColor(throttle);
 58:       const step = rect.width / (dataRef.current.length - 1);
 59:       const dynamicMax = Math.max(Math.max(...dataRef.current) * 1.2, 100);
 60: 
 61:       // Draw Gradient Path
 62:       ctx.beginPath();
 63:       ctx.moveTo(0, rect.height);
 64:       dataRef.current.forEach((val, i) => {
 65:         const x = i * step;
 66:         const normalized = Math.min(val / dynamicMax, 1);
 67:         const y = rect.height - normalized * rect.height * 0.7 - 20;
 68:         ctx.lineTo(x, y);
 69:       });
 70:       ctx.lineTo(rect.width, rect.height);
 71:       const gradient = ctx.createLinearGradient(0, 0, 0, rect.height);
 72:       gradient.addColorStop(0, `${activeColor}33`);
 73:       gradient.addColorStop(1, `${activeColor}00`);
 74:       ctx.fillStyle = gradient;
 75:       ctx.fill();
 76: 
 77:       // Draw Stroke
 78:       ctx.beginPath();
 79:       ctx.lineWidth = 2;
 80:       ctx.lineJoin = "round";
 81:       ctx.strokeStyle = activeColor;
 82:       dataRef.current.forEach((val, i) => {
 83:         const x = i * step;
 84:         const normalized = Math.min(val / dynamicMax, 1);
 85:         const y = rect.height - normalized * rect.height * 0.7 - 20;
 86:         if (i === 0) ctx.moveTo(x, y);
 87:         else ctx.lineTo(x, y);
 88:       });
 89:       ctx.stroke();
 90: 
 91:       requestRef.current = requestAnimationFrame(animate);
 92:     };
 93: 
 94:     requestRef.current = requestAnimationFrame(animate);
 95: 
 96:     return () => {
 97:       cancelAnimationFrame(requestRef.current);
 98:     };
 99:   }, [velocity, throttle]);
100: 
101:   // ... (rest of the component and resize logic)
102: 
103:   useEffect(() => {
104:     const canvas = canvasRef.current;
105:     if (!canvas) return;
106: 
107:     const ctx = canvas.getContext("2d", { alpha: false });
108:     if (!ctx) return;
109: 
110:     const resizeCanvas = () => {
111:       const rect = canvas.getBoundingClientRect();
112:       const dpr = window.devicePixelRatio || 1;
113:       canvas.width = rect.width * dpr;
114:       canvas.height = rect.height * dpr;
115:       ctx.scale(dpr, dpr);
116:     };
117: 
118:     resizeCanvas();
119: 
120:     const resizeObserver = new ResizeObserver(resizeCanvas);
121:     resizeObserver.observe(canvas.parentElement!);
122: 
123:     return () => resizeObserver.disconnect();
124:   }, []);
125: 
126:   return (
127:     <Card className="h-80 flex flex-col relative overflow-hidden bg-surface-white border border-border-soft shadow-soft-depth">
128:       <div className="flex justify-between items-center mb-4 z-10 px-5 pt-5">
129:         <div>
130:           <h3 className="font-bold text-lg text-text-main flex items-center gap-2">
131:             <Activity
132:               className={throttle > 70 ? "text-red-500" : "text-brand-orange"}
133:               size={20}
134:             />
135:             Live Compute Velocity
136:           </h3>
137:           <p className="text-xs text-text-muted mt-1">
138:             Real-time operations per second
139:           </p>
140:         </div>
141:         <div className="bg-surface-muted/50 px-4 py-2 rounded-xl border border-white/50 shadow-inner backdrop-blur-sm">
142:           <span
143:             className="text-3xl font-black tabular-nums tracking-tight"
144:             style={{ color: getColor(throttle) }}
145:           >
146:             {velocity.toLocaleString()}
147:           </span>
148:           <span className="text-[10px] font-bold text-text-muted ml-1 uppercase">
149:             OPS/s
150:           </span>
151:         </div>
152:       </div>
153:       <div className="flex-1 w-full min-h-0 relative px-5 pb-5">
154:         <canvas
155:           ref={canvasRef}
156:           className="w-full h-full rounded-xl border border-black/5 shadow-inner"
157:         />
158:       </div>
159:     </Card>
160:   );
161: };
</file>

<file path="client/src/hooks/usePersistentIdentity.ts">
 1: import { useState, useEffect, useCallback } from "react";
 2: 
 3: const SWARM_TOKEN_KEY = "ostrich_swarm_token";
 4: 
 5: export const usePersistentIdentity = () => {
 6:   const [identity, setIdentity] = useState({ id: "", name: "" });
 7:   const [swarmToken, setSwarmToken] = useState<string | null>(null);
 8: 
 9:   useEffect(() => {
10:     // 1. Identity Logic (Existing)
11:     let storedId = localStorage.getItem("ostrich_device_id");
12:     let storedName = localStorage.getItem("ostrich_device_name");
13: 
14:     if (!storedId || storedId === "undefined") {
15:       const newId = `node-${Math.random().toString(36).substring(2, 11)}`;
16:       localStorage.setItem("ostrich_device_id", newId);
17:       storedId = newId;
18:     }
19: 
20:     if (!storedName) {
21:       const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
22:       storedName = isMobile ? "Mobile Node" : "Desktop Node";
23:       localStorage.setItem("ostrich_device_name", storedName);
24:     }
25:     setIdentity({ id: storedId, name: storedName });
26: 
27:     // 2. Swarm Persistence Logic (New)
28:     const storedToken = sessionStorage.getItem(SWARM_TOKEN_KEY);
29:     const urlToken = new URLSearchParams(window.location.search).get("invite");
30: 
31:     if (urlToken) {
32:       // New join via URL link
33:       sessionStorage.setItem(SWARM_TOKEN_KEY, urlToken);
34:       setSwarmToken(urlToken);
35:     } else if (storedToken) {
36:       // RELOAD PROTECTION: Restore state first, then update URL for consistency
37:       setSwarmToken(storedToken);
38:       const url = new URL(window.location.href);
39:       url.searchParams.set("invite", storedToken);
40:       window.history.replaceState({}, "", url.toString());
41:     } else {
42:       setSwarmToken(null);
43:     }
44:   }, []);
45:   // NEW: Function to lock in a token from ANY source (QR/Manual/Link)
46:   const saveSwarmToken = useCallback((token: string) => {
47:     sessionStorage.setItem(SWARM_TOKEN_KEY, token);
48:     setSwarmToken(token);
49: 
50:     // Update URL so a browser refresh behaves like a link-join
51:     const url = new URL(window.location.href);
52:     url.searchParams.set("invite", token);
53:     window.history.replaceState({}, "", url.toString());
54:   }, []);
55: 
56:   const clearSwarmToken = useCallback(() => {
57:     sessionStorage.removeItem(SWARM_TOKEN_KEY);
58:     setSwarmToken(null);
59:     const url = new URL(window.location.href);
60:     url.searchParams.delete("invite");
61:     window.history.replaceState({}, "", url.toString());
62:   }, []);
63: 
64:   return { identity, swarmToken, clearSwarmToken, saveSwarmToken }; // Added isHydrated
65: };
</file>

<file path="client/src/utils/compute.worker.ts">
  1: /// <reference lib="webworker" />
  2: 
  3: import { MAX_SAFE_THROTTLE_PERCENT } from "../core/constants";
  4: 
  5: const TOTAL_CORES = navigator.hardwareConcurrency || 4;
  6: const RESERVED_CORES = TOTAL_CORES > 8 ? 2 : 1;
  7: const LOGICAL_CORES = Math.max(1, TOTAL_CORES - RESERVED_CORES);
  8: 
  9: const threadPool = new Map();
 10: let throttleLimit = 0.3;
 11: let nextWorkerId = 0;
 12: 
 13: const WGSL_SHADER = `
 14: @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
 15: @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
 16: @group(0) @binding(2) var<storage, read_write> result : array<f32>;
 17: @group(0) @binding(3) var<uniform> uniforms : vec2<f32>;
 18: 
 19: @compute @workgroup_size(64)
 20: fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
 21:   let index = global_id.x;
 22:   let size = u32(uniforms.x);
 23:   if (index >= size * size) { return; }
 24:   let row = index / size;
 25:   let col = index % size;
 26:   var sum = 0.0;
 27:   for (var k = 0u; k < size; k = k + 1u) {
 28:     sum = sum + matrixA[row * size + k] * matrixB[k * size + col];
 29:   }
 30:   result[index] = sum;
 31: }
 32: `;
 33: 
 34: const createSubWorker = (_wId: number) => {
 35:   // CRITICAL: This block MUST be pure Vanilla JS. No TS 'as' or types.
 36:   const code = `
 37:     let device = null;
 38:     let computePipeline = null;
 39:     let gpuReady = false;
 40: 
 41:     const runCpuStress = (iterations) => {
 42:       let sum = 0;
 43:       for (let i = 0; i < (iterations || 100000); i++) {
 44:         sum += Math.sqrt(i) * Math.sin(i);
 45:       }
 46:       return sum;
 47:     };
 48: 
 49:     async function initWebGPU() {
 50:       if (!navigator.gpu) return false;
 51:       try {
 52:         const adapter = await navigator.gpu.requestAdapter();
 53:         if (!adapter) return false;
 54:         device = await adapter.requestDevice();
 55:         const shaderModule = device.createShaderModule({ code: \`${WGSL_SHADER}\` });
 56:         computePipeline = device.createComputePipeline({
 57:           layout: 'auto',
 58:           compute: { module: shaderModule, entryPoint: "main" }
 59:         });
 60:         return true;
 61:       } catch(e) { return false; }
 62:     }
 63: 
 64:     const initPromise = initWebGPU().then(ok => {
 65:       gpuReady = ok;
 66:       self.postMessage({ type: "WORKER_LOG", level: "GPU", message: ok ? "WebGPU Kernel Ready" : "WebGPU Init Failed: Using CPU Fallback" });
 67:     });
 68: 
 69:     self.onmessage = async (e) => {
 70:       await initPromise;
 71:       const { type, payload } = e.data;
 72: 
 73:       if (type === "EXECUTE_JOB") {
 74:         const start = performance.now();
 75:         let result = 0;
 76:         try {
 77:           // Actual math execution
 78:           result = runCpuStress(payload.data?.iterations || 100000);
 79:           self.postMessage({ type: "JOB_COMPLETE", chunkId: payload.id, result, durationMs: performance.now() - start });
 80:           
 81:           
 82:         } catch (err) {
 83:           self.postMessage({ type: "JOB_ERROR", chunkId: payload.id, error: err.message });
 84:         }
 85:       }
 86: 
 87:       if (type === "BENCHMARK") {
 88:         const start = performance.now();
 89:         runCpuStress(1000000);
 90:         const score = Math.round(1000 / ((performance.now() - start) / 1000));
 91:         self.postMessage({ type: "BENCHMARK_COMPLETE", score });
 92:       }
 93:     };
 94:   `;
 95:   const blob = new Blob([code], { type: "application/javascript" });
 96:   const objectUrl = URL.createObjectURL(blob);
 97:   const worker = new Worker(objectUrl);
 98: 
 99:   // Cleanup the URL immediately after the worker is initialized to free memory
100:   // The worker remains active as the browser has already loaded the script
101:   URL.revokeObjectURL(objectUrl);
102: 
103:   return { worker, objectUrl: "" }; // objectUrl no longer needed
104: };
105: 
106: const applyConfig = () => {
107:   const safeThrottle = Math.min(throttleLimit, MAX_SAFE_THROTTLE_PERCENT / 100);
108:   const target = Math.max(1, Math.floor(LOGICAL_CORES * safeThrottle));
109: 
110:   if (target > threadPool.size) {
111:     for (let i = threadPool.size; i < target; i++) {
112:       const wId = nextWorkerId++;
113:       const { worker } = createSubWorker(wId);
114:       worker.onmessage = (ev) => self.postMessage(ev.data);
115:       threadPool.set(wId, { worker, busy: false });
116:     }
117:   } else if (target < threadPool.size) {
118:     const toRemove = Array.from(threadPool.entries())
119:       .filter(([, data]) => !data.busy)
120:       .slice(0, threadPool.size - target);
121: 
122:     toRemove.forEach(([id, data]) => {
123:       data.worker.terminate();
124:       threadPool.delete(id);
125:     });
126:   }
127: };
128: 
129: self.onmessage = (e) => {
130:   const { type, payload } = e.data;
131:   if (type === "CONFIG_UPDATE") {
132:     throttleLimit = payload.throttle;
133:     applyConfig();
134:     return;
135:   }
136: 
137:   // Find free worker
138:   const workers = Array.from(threadPool.values());
139:   const freeWorker = workers.find((t) => !t.busy) || workers[0]; // Fallback to first if all busy
140: 
141:   if (freeWorker) {
142:     if (type === "EXECUTE_JOB") freeWorker.busy = true;
143:     const originalHandler = freeWorker.worker.onmessage;
144:     freeWorker.worker.onmessage = (ev: any) => {
145:       freeWorker.busy = false;
146:       freeWorker.worker.onmessage = originalHandler;
147:       self.postMessage(ev.data);
148:     };
149:     freeWorker.worker.postMessage({ type, payload });
150:   }
151: };
</file>

<file path="server/src/managers/DeviceManager.ts">
  1: import {
  2:   type DeviceInfo,
  3:   type DeviceCapabilities,
  4:   type DeviceType,
  5: } from "../core/types";
  6: 
  7: export class DeviceManager {
  8:   private devices = new Map<string, DeviceInfo>();
  9:   // 60s for offline (allows for long reloads/bad signal), 5mins for full deletion
 10:   private readonly OFFLINE_THRESHOLD = 60000;
 11:   private readonly DELETE_THRESHOLD = 300000;
 12:   constructor() {
 13:     setInterval(() => this.cleanup(), 5000);
 14:   }
 15: 
 16:   public register(
 17:     id: string,
 18:     name: string,
 19:     caps: DeviceCapabilities,
 20:     swarmId: string,
 21:   ) {
 22:     const existing = this.devices.get(id);
 23:     let type: DeviceType = "DESKTOP";
 24: 
 25:     if (name.toLowerCase().includes("mobile")) {
 26:       type = "MOBILE";
 27:     } else if (name.toLowerCase().includes("colab")) {
 28:       type = "COLAB";
 29:     } else if (caps.gpuAvailable && caps.memoryGB > 16) {
 30:       type = "SERVER";
 31:     }
 32:     this.devices.set(id, {
 33:       id,
 34:       name,
 35:       type,
 36:       status: "ONLINE", // Move to ONLINE immediately if registering/re-registering
 37:       capabilities: caps,
 38:       opsScore: existing?.opsScore || 0,
 39:       totalJobsCompleted: existing?.totalJobsCompleted || 0,
 40:       lastHeartbeat: Date.now(),
 41:       lastUserInteraction: Date.now(),
 42:       swarmId,
 43:     });
 44:   }
 45: 
 46:   public heartbeat(id: string, data?: { lastInteraction: number }) {
 47:     const device = this.devices.get(id);
 48:     if (!device) return;
 49: 
 50:     device.lastHeartbeat = Date.now();
 51:     if (data?.lastInteraction)
 52:       device.lastUserInteraction = data.lastInteraction;
 53: 
 54:     // If they heartbeat, they are ONLINE
 55:     if (device.status === "OFFLINE" || device.status === "REGISTERED") {
 56:       device.status = "ONLINE";
 57:     }
 58:   }
 59: 
 60:   public toggleDevice(id: string, enabled: boolean) {
 61:     const device = this.devices.get(id);
 62:     if (device) device.status = enabled ? "ONLINE" : "DISABLED";
 63:   }
 64: 
 65:   public updateScore(id: string, score: number) {
 66:     const device = this.devices.get(id);
 67:     if (device) device.opsScore = score;
 68:   }
 69: 
 70:   public getDevicesBySwarm(swarmId: string) {
 71:     return Array.from(this.devices.values()).filter(
 72:       (d) => d.swarmId === swarmId,
 73:     );
 74:   }
 75: 
 76:   public getAvailableResources(swarmId: string) {
 77:     let [totalCores, totalMemory, totalGPUs, onlineCount] = [0, 0, 0, 0];
 78: 
 79:     this.getDevicesBySwarm(swarmId).forEach((d) => {
 80:       if (
 81:         d.status === "ONLINE" ||
 82:         d.status === "BUSY" ||
 83:         d.status === "REGISTERED"
 84:       ) {
 85:         totalCores += d.capabilities.cpuCores;
 86:         totalMemory += d.capabilities.memoryGB;
 87:         if (d.capabilities.gpuAvailable) totalGPUs++;
 88:         onlineCount++;
 89:       }
 90:     });
 91: 
 92:     return { totalCores, totalMemory, totalGPUs, onlineCount };
 93:   }
 94: 
 95:   public getDevice(id: string) {
 96:     return this.devices.get(id);
 97:   }
 98: 
 99:   public remove(id: string) {
100:     this.devices.delete(id);
101:   }
102: 
103:   private cleanup() {
104:     const now = Date.now();
105:     this.devices.forEach((device, id) => {
106:       const diff = now - device.lastHeartbeat;
107: 
108:       if (diff > this.DELETE_THRESHOLD) {
109:         this.devices.delete(id);
110:       } else if (
111:         device.status !== "DISABLED" &&
112:         diff > this.OFFLINE_THRESHOLD
113:       ) {
114:         device.status = "OFFLINE";
115:       }
116:     });
117:   }
118: }
</file>

<file path="client/src/features/connection/DeviceConnector.tsx">
  1: // client/src/features/connection/DeviceConnector.tsx
  2: import { QRCodeSVG } from "qrcode.react";
  3: import {
  4:   X,
  5:   Copy,
  6:   RefreshCw,
  7:   LogOut,
  8:   ArrowRight,
  9:   Camera,
 10:   Smartphone,
 11: } from "lucide-react";
 12: import { Card } from "../../components/Card";
 13: import { useEffect, useState, useCallback, useRef } from "react";
 14: import { Html5Qrcode } from "html5-qrcode";
 15: 
 16: interface DeviceConnectorProps {
 17:   readonly isOpen: boolean;
 18:   readonly onClose: () => void;
 19:   readonly onRegenerateToken: () => Promise<string>;
 20:   readonly onManualJoin: (code: string) => Promise<void>;
 21:   readonly onLeave: () => void;
 22:   readonly isGuest: boolean;
 23: }
 24: 
 25: export const DeviceConnector = ({
 26:   isOpen,
 27:   onClose,
 28:   onRegenerateToken,
 29:   onManualJoin,
 30:   onLeave,
 31:   isGuest,
 32: }: DeviceConnectorProps) => {
 33:   const [token, setToken] = useState<string>("");
 34:   const [inputCode, setInputCode] = useState<string>("");
 35:   const [isLoading, setIsLoading] = useState(false);
 36:   const [isScanning, setIsScanning] = useState(false);
 37:   const [showSuccess, setShowSuccess] = useState(false);
 38:   const [isError, setIsError] = useState(false);
 39:   const scannerRef = useRef<Html5Qrcode | null>(null);
 40: 
 41:   const handleRegenerate = useCallback(async () => {
 42:     if (isGuest || isLoading) return;
 43:     setIsLoading(true);
 44:     try {
 45:       const newToken = await onRegenerateToken();
 46:       setToken(newToken);
 47:     } catch (err) {
 48:       console.error("[UI] Token Generation Failed", err);
 49:     } finally {
 50:       setIsLoading(false);
 51:     }
 52:   }, [onRegenerateToken, isGuest, isLoading]);
 53: 
 54:   const stopScanner = useCallback(async () => {
 55:     if (scannerRef.current?.isScanning) {
 56:       await scannerRef.current.stop();
 57:     }
 58:     setIsScanning(false);
 59:   }, []);
 60: 
 61:   const startScanner = useCallback(async () => {
 62:     setIsScanning(true);
 63:     setTimeout(async () => {
 64:       const element = document.getElementById("reader");
 65:       if (!element) {
 66:         setIsScanning(false);
 67:         return;
 68:       }
 69:       try {
 70:         const html5QrCode = new Html5Qrcode("reader");
 71:         scannerRef.current = html5QrCode;
 72:         await html5QrCode.start(
 73:           { facingMode: "environment" },
 74:           { fps: 20, qrbox: { width: 220, height: 220 }, aspectRatio: 1.0 },
 75:           async (decodedText) => {
 76:             const code = decodedText.includes("invite=")
 77:               ? decodedText.split("invite=")[1].split("&")[0]
 78:               : decodedText.trim();
 79: 
 80:             await stopScanner();
 81:             handleJoinProtocol(code);
 82:           },
 83:           () => {},
 84:         );
 85:       } catch (err) {
 86:         setIsScanning(false);
 87:       }
 88:     }, 150);
 89:   }, [stopScanner]);
 90: 
 91:   const handleJoinProtocol = async (code: string) => {
 92:     setIsLoading(true);
 93:     setIsError(false);
 94:     try {
 95:       await onManualJoin(code);
 96:       setShowSuccess(true);
 97:       setTimeout(() => {
 98:         onClose();
 99:         setShowSuccess(false);
100:         setInputCode("");
101:       }, 1200);
102:     } catch (err) {
103:       setIsError(true);
104:       setTimeout(() => setIsError(false), 1000);
105:     } finally {
106:       setIsLoading(false);
107:     }
108:   };
109: 
110:   useEffect(() => {
111:     if (isOpen && !isGuest && !token && !isLoading) handleRegenerate();
112:   }, [isOpen, isGuest, token, isLoading, handleRegenerate]);
113: 
114:   useEffect(() => {
115:     const handleEsc = (e: KeyboardEvent) => {
116:       if (e.key === "Escape") onClose();
117:     };
118:     if (isOpen) document.addEventListener("keydown", handleEsc);
119:     return () => document.removeEventListener("keydown", handleEsc);
120:   }, [isOpen, onClose]);
121: 
122:   useEffect(() => {
123:     if (!isOpen && isScanning) stopScanner();
124:   }, [isOpen, isScanning, stopScanner]);
125: 
126:   if (!isOpen) return null;
127: 
128:   return (
129:     <div
130:       className="fixed inset-0 z-50 flex items-center justify-center bg-gray-900/60 backdrop-blur-md p-6"
131:       onClick={onClose}
132:     >
133:       <div className="modal-content" onClick={(e) => e.stopPropagation()}>
134:         <Card
135:           className="max-w-sm w-full relative p-6 space-y-6"
136:           variant="elevated"
137:         >
138:           <button
139:             onClick={onClose}
140:             className="absolute top-4 right-4 p-2 hover:bg-gray-100 rounded-full transition-colors"
141:           >
142:             <X size={18} className="text-text-muted" />
143:           </button>
144:           <div className="text-center space-y-4">
145:             <h3 className="text-xl font-bold">Swarm Access</h3>
146:             {isGuest ? (
147:               <div className="p-4 bg-red-50 border border-red-100 rounded-2xl space-y-3">
148:                 <p className="text-[10px] font-black text-red-500 uppercase">
149:                   Swarm Guest Mode
150:                 </p>
151:                 <button
152:                   onClick={onLeave}
153:                   className="w-full flex items-center justify-center gap-2 bg-red-500 text-white py-3 rounded-xl font-bold text-xs hover:bg-red-600"
154:                 >
155:                   <LogOut size={14} /> Exit Swarm
156:                 </button>
157:               </div>
158:             ) : (
159:               <div className="space-y-6">
160:                 <div className="flex bg-gray-100/80 p-1 rounded-2xl shadow-inner border border-gray-200/50 mx-auto w-fit">
161:                   <button
162:                     onClick={stopScanner}
163:                     className={`flex items-center gap-2 px-4 py-1.5 rounded-xl text-[10px] font-black uppercase tracking-wider transition-all ${!isScanning ? "bg-white text-brand-orange shadow-sm" : "text-text-muted"}`}
164:                   >
165:                     <Smartphone size={12} /> Share
166:                   </button>
167:                   <button
168:                     onClick={startScanner}
169:                     className={`flex items-center gap-2 px-4 py-1.5 rounded-xl text-[10px] font-black uppercase tracking-wider transition-all ${isScanning ? "bg-white text-brand-orange shadow-sm" : "text-text-muted"}`}
170:                   >
171:                     <Camera size={12} /> Scan
172:                   </button>
173:                 </div>
174:                 {!isScanning ? (
175:                   <div className="space-y-4 animate-in fade-in slide-in-from-bottom-2">
176:                     <div className="relative inline-block p-4 bg-white border border-border-soft rounded-3xl shadow-sm">
177:                       {isLoading && (
178:                         <div className="absolute inset-0 z-10 bg-white/80 flex items-center justify-center rounded-3xl">
179:                           <RefreshCw
180:                             size={24}
181:                             className="animate-spin text-brand-orange"
182:                           />
183:                         </div>
184:                       )}
185:                       <QRCodeSVG
186:                         value={token || "OSTRICH_WAITING"}
187:                         size={180}
188:                         level="M"
189:                         includeMargin
190:                       />
191:                     </div>
192:                     <div className="bg-gray-100 p-3 rounded-xl border border-dashed flex items-center justify-between">
193:                       <div className="text-left">
194:                         <p className="text-[9px] font-black text-gray-400 uppercase">
195:                           Join Code
196:                         </p>
197:                         <p className="font-mono font-bold text-brand-orange">
198:                           {token || "GENERATING..."}
199:                         </p>
200:                       </div>
201:                       <div className="flex gap-1">
202:                         <button
203:                           onClick={handleRegenerate}
204:                           className="p-2 hover:bg-white rounded-lg"
205:                         >
206:                           <RefreshCw
207:                             size={16}
208:                             className={isLoading ? "animate-spin" : ""}
209:                           />
210:                         </button>
211:                         <button
212:                           onClick={() =>
213:                             token && navigator.clipboard.writeText(token)
214:                           }
215:                           className="p-2 hover:bg-white rounded-lg"
216:                         >
217:                           <Copy size={16} />
218:                         </button>
219:                       </div>
220:                     </div>
221:                   </div>
222:                 ) : (
223:                   <div className="animate-in fade-in zoom-in-95">
224:                     <div className="relative w-full aspect-square max-w-60 mx-auto bg-black rounded-[40px] border-8 border-surface-white overflow-hidden shadow-inner">
225:                       <div
226:                         id="reader"
227:                         className="w-full h-full [&_video]:object-cover [&_video]:rounded-[32px]"
228:                       />
229:                       <div className="absolute inset-0 border-2 border-brand-orange/30 rounded-[32px] pointer-events-none">
230:                         <div className="absolute top-0 left-0 w-full h-2 bg-brand-orange/50 shadow-[0_0_15px_rgba(255,125,84,0.8)] animate-[scan_2s_linear_infinite]" />
231:                       </div>
232:                     </div>
233:                   </div>
234:                 )}
235:               </div>
236:             )}
237:           </div>
238:           <div className="border-t pt-6 space-y-3">
239:             <div className="flex gap-2">
240:               <input
241:                 type="text"
242:                 maxLength={6}
243:                 value={inputCode}
244:                 onChange={(e) => {
245:                   setIsError(false);
246:                   setInputCode(e.target.value.toUpperCase());
247:                 }}
248:                 placeholder="ENTER CODE"
249:                 className={`flex-1 bg-gray-100 border rounded-xl px-4 py-3 font-mono font-bold text-sm focus:outline-brand-orange transition-all ${isError ? "border-red-500 animate-shake" : "border-border-soft"}`}
250:               />
251:               <button
252:                 onClick={() => handleJoinProtocol(inputCode)}
253:                 disabled={inputCode.length < 4 || isLoading || showSuccess}
254:                 className={`p-3 rounded-xl transition-all duration-200 ${showSuccess ? "bg-green-500" : isError ? "bg-red-500" : "bg-gray-900"} text-white`}
255:               >
256:                 {isLoading ? (
257:                   <RefreshCw size={20} className="animate-spin" />
258:                 ) : (
259:                   <ArrowRight size={20} />
260:                 )}
261:               </button>
262:             </div>
263:           </div>
264:         </Card>
265:       </div>
266:     </div>
267:   );
268: };
</file>

<file path="server/src/index.ts">
  1: import { Server } from "socket.io";
  2: import { DeviceManager } from "./managers/DeviceManager";
  3: import { JobScheduler } from "./managers/JobScheduler";
  4: import { AuthManager } from "./managers/AuthManager";
  5: import { type SwarmSnapshot } from "./core/types";
  6: import { SocketEvents } from "@shared/socket/events";
  7: import { type LogLevel, type SystemLogPayload } from "@shared/socket/states";
  8: 
  9: const io = new Server(3000, {
 10:   cors: { origin: "*" },
 11:   transports: ["websocket", "polling"],
 12: });
 13: 
 14: const deviceManager = new DeviceManager();
 15: const jobScheduler = new JobScheduler();
 16: const authManager = new AuthManager();
 17: 
 18: const activeSwarmIds = new Set<string>();
 19: const swarmStates = new Map<string, SwarmSnapshot["runState"]>();
 20: const swarmCompletedCounts = new Map<string, number>();
 21: const swarmThrottles = new Map<string, number>();
 22: 
 23: /**
 24:  * Global System Logger
 25:  * Broadcasts to terminal and server console
 26:  */
 27: const systemLog = (
 28:   swarmId: string,
 29:   level: LogLevel,
 30:   message: string,
 31:   source: string = "CORE",
 32: ) => {
 33:   const payload: SystemLogPayload = {
 34:     level,
 35:     message,
 36:     timestamp: Date.now(),
 37:     source,
 38:   };
 39:   io.to(swarmId).emit(SocketEvents.SYSTEM_LOG, payload);
 40: };
 41: 
 42: // Auth Middleware (as we fixed in Phase 0)
 43: // server/src/index.ts
 44: 
 45: io.use((socket, next) => {
 46:   const token = socket.handshake.auth.token || socket.handshake.query.token;
 47:   const persistentId = socket.handshake.query.persistentId as string;
 48: 
 49:   if (!persistentId) return next(new Error("MISSING_PERSISTENT_ID"));
 50: 
 51:   // Master Mode: No token provided or token is empty
 52:   const isEmptyToken =
 53:     !token || token === "null" || token === "undefined" || token === "";
 54: 
 55:   if (isEmptyToken) {
 56:     socket.data.swarmId = persistentId; // Host joins their own swarm
 57:     return next();
 58:   }
 59: 
 60:   // Worker Mode: Validate the invite code against active sessions
 61:   const targetSwarm = authManager.validateToken(token as string);
 62: 
 63:   if (targetSwarm) {
 64:     socket.data.swarmId = targetSwarm; // Restore joined membership
 65:     return next();
 66:   }
 67: 
 68:   // Reject connection if the token is invalid or expired
 69:   return next(new Error("JOIN_CODE_INVALID"));
 70: });
 71: 
 72: io.on("connection", (socket) => {
 73:   const persistentId = socket.handshake.query.persistentId as string;
 74:   const swarmId = socket.data.swarmId;
 75:   activeSwarmIds.add(swarmId);
 76: 
 77:   socket.join(swarmId);
 78:   systemLog(
 79:     swarmId,
 80:     "NET",
 81:     `Socket connected: ${persistentId.slice(0, 8)}`,
 82:     "GATEWAY",
 83:   );
 84: 
 85:   // Protocol: Registration
 86:   socket.on(SocketEvents.DEVICE_REGISTER, (data) => {
 87:     deviceManager.register(persistentId, data.name, data.capabilities, swarmId);
 88:     // FIX: Register device in scheduler to initialize quotas
 89:     const device = deviceManager.getDevice(persistentId);
 90:     if (device) jobScheduler.registerDevice(device);
 91: 
 92:     systemLog(swarmId, "SYS", `Node Registered: ${data.name}`, "AUTH");
 93:     deviceManager.heartbeat(persistentId);
 94:     broadcastState(swarmId);
 95:   });
 96: 
 97:   // Protocol: Heartbeat
 98:   socket.on(SocketEvents.HEARTBEAT, (data) => {
 99:     deviceManager.heartbeat(persistentId, data);
100:   });
101: 
102:   // Protocol: Job Pipeline
103:   socket.on(SocketEvents.JOB_REQUEST_BATCH, () => {
104:     const currentState = swarmStates.get(swarmId);
105:     const device = deviceManager.getDevice(persistentId);
106: 
107:     if (!device || device.status === "OFFLINE" || currentState !== "RUNNING")
108:       return;
109: 
110:     // FIX: Use the new batch distribution method
111:     const batch = jobScheduler.getJobBatchForDevice(device, 10); // Requesting larger batches for high-perf
112: 
113:     if (batch.length > 0) {
114:       socket.emit(SocketEvents.JOB_BATCH_DISPATCH, batch);
115:     }
116:   });
117: 
118:   socket.on(SocketEvents.JOB_COMPLETE, (payload) => {
119:     // FIX: Release the job slot in the scheduler regardless of success/error
120:     jobScheduler.releaseJobSlot(persistentId);
121:     if (!payload.error) {
122:       swarmCompletedCounts.set(
123:         swarmId,
124:         (swarmCompletedCounts.get(swarmId) || 0) + 1,
125:       );
126:       const device = deviceManager.getDevice(persistentId);
127:       if (device) device.totalJobsCompleted++;
128:     } else {
129:       systemLog(
130:         swarmId,
131:         "ERR",
132:         `Job ${payload.chunkId} failed on ${persistentId}`,
133:         "COMPUTE",
134:       );
135:     }
136:   });
137: 
138:   // --- ADD THIS HANDLER ---
139:   socket.on("auth:generate_token", (callback: (token: string) => void) => {
140:     try {
141:       const token = authManager.generateToken(swarmId);
142:       if (!token) {
143:         systemLog(
144:           swarmId,
145:           "WARN",
146:           "Invite code generation rate limited (5/min)",
147:           "AUTH",
148:         );
149:         callback("");
150:         return;
151:       }
152:       systemLog(swarmId, "SYS", `Generated new invite code: ${token}`, "AUTH");
153:       callback(token);
154:     } catch (err) {
155:       console.error("Token generation error:", err);
156:       callback("");
157:     }
158:   });
159:   // Swarm Controls
160:   socket.on(SocketEvents.SWARM_SET_STATE, (state) => {
161:     swarmStates.set(swarmId, state);
162:     systemLog(swarmId, "SYS", `Swarm state changed to ${state}`, "MASTER");
163:     broadcastState(swarmId);
164:   });
165: 
166:   socket.on(SocketEvents.SWARM_SET_THROTTLE, (val) => {
167:     swarmThrottles.set(swarmId, val);
168:     io.to(swarmId).emit(SocketEvents.SWARM_THROTTLE_SYNC, val);
169:   });
170: 
171:   socket.on(SocketEvents.BENCHMARK_RESULT, (data) => {
172:     deviceManager.updateScore(persistentId, data.score);
173:     systemLog(
174:       swarmId,
175:       "CPU",
176:       `Benchmark: ${data.score.toLocaleString()} OPS`,
177:       persistentId,
178:     );
179:     const device = deviceManager.getDevice(persistentId);
180:     if (device) jobScheduler.registerDevice(device);
181:     broadcastState(swarmId);
182:   });
183: 
184:   // --- ADD THIS HANDLER TO THE SERVER ---
185:   socket.on(
186:     "cmd:toggle_device",
187:     ({ id, enabled }: { id: string; enabled: boolean }) => {
188:       deviceManager.toggleDevice(id, enabled);
189: 
190:       systemLog(
191:         swarmId,
192:         enabled ? "SYS" : "WARN",
193:         `Node ${id.slice(0, 8)} was ${enabled ? "enabled" : "disabled"} by Master`,
194:         "ORCHESTRATOR",
195:       );
196: 
197:       // Force update to all nodes so the UI updates immediately
198:       broadcastState(swarmId);
199:     },
200:   );
201: 
202:   // --- ADD THIS HANDLER FOR THE GENERATOR ---
203: 
204:   socket.on("disconnect", () => {
205:     // Check if room is empty before removing swarmId from broadcaster
206:     const room = io.sockets.adapter.rooms.get(swarmId);
207:     if (!room || room.size === 0) {
208:       activeSwarmIds.delete(swarmId);
209:     }
210:     systemLog(
211:       swarmId,
212:       "NET",
213:       `Node offline: ${persistentId.slice(0, 8)}`,
214:       "GATEWAY",
215:     );
216:   });
217: });
218: 
219: /**
220:  * Single Global Snapshot Loop
221:  * Prevents interval leaks
222:  */
223: let broadcastDebounce: NodeJS.Timeout | null = null;
224: 
225: function broadcastState(swarmId: string) {
226:   if (broadcastDebounce) clearTimeout(broadcastDebounce);
227: 
228:   broadcastDebounce = setTimeout(() => {
229:     const resources = deviceManager.getAvailableResources(swarmId);
230:     const queue = jobScheduler.getQueueStats();
231:     const allDevices = deviceManager.getDevicesBySwarm(swarmId);
232:     const currentState = swarmStates.get(swarmId) || "STOPPED";
233:     const completedCount = swarmCompletedCounts.get(swarmId) || 0;
234:     const currentThrottle = swarmThrottles.get(swarmId) || 40;
235: 
236:     const totalOpsScore = allDevices
237:       .filter((d) => d.status !== "OFFLINE" && d.status !== "DISABLED")
238:       .reduce((sum, d) => sum + (d.opsScore || 0), 0);
239: 
240:     const snapshot: SwarmSnapshot = {
241:       runState: currentState,
242:       devices: allDevices.reduce((acc, d) => ({ ...acc, [d.id]: d }), {}),
243:       stats: {
244:         totalJobs: completedCount + queue.pending,
245:         activeJobs: currentState === "RUNNING" ? resources.onlineCount : 0,
246:         pendingJobs: queue.pending,
247:         completedJobs: completedCount,
248:         globalVelocity:
249:           currentState === "RUNNING"
250:             ? Math.round(totalOpsScore * (currentThrottle / 100))
251:             : 0,
252:         globalThrottle: currentThrottle,
253:       },
254:       resources,
255:     };
256: 
257:     io.to(swarmId).emit(SocketEvents.SWARM_SNAPSHOT, snapshot);
258:   }, 50);
259: }
260: 
261: // Tick all active swarms every 2s
262: setInterval(() => {
263:   activeSwarmIds.forEach((id) => {
264:     // Only broadcast if there are actually sockets in that room
265:     const room = io.sockets.adapter.rooms.get(id);
266:     if (room && room.size > 0) {
267:       broadcastState(id);
268:     } else {
269:       activeSwarmIds.delete(id);
270:     }
271:   });
272: }, 2000);
273: // Periodic Weight Recalculation (Every 10s)
274: // Re-calculates device weights based on live benchmark (opsScore) averages
275: setInterval(() => {
276:   activeSwarmIds.forEach((swarmId) => {
277:     const devices = deviceManager.getDevicesBySwarm(swarmId);
278:     devices.forEach((d) => {
279:       if (d.status !== "OFFLINE" && d.status !== "DISABLED") {
280:         jobScheduler.registerDevice(d);
281:       }
282:     });
283:   });
284: }, 10000);
285: console.log("🚀 Ostrich Swarm Coordinator [PHASE 2] Online");
</file>

<file path="client/src/App.tsx">
  1: // client/src/App.tsx
  2: import { useState, useEffect, useRef, useMemo } from "react";
  3: import { Wifi, Share2, LogOut, RefreshCw, Terminal } from "lucide-react";
  4: 
  5: // NEW HOOKS
  6: 
  7: import { useSwarm } from "./contexts/SwarmContext";
  8: import { usePersistentIdentity } from "./hooks/usePersistentIdentity";
  9: import { useMediaQuery } from "./hooks/useMediaQuery";
 10: 
 11: // COMPONENTS
 12: import { VelocityMonitor } from "./features/dashboard/VelocityMonitor";
 13: import { ActiveSwarm } from "./features/dashboard/ActiveSwarm";
 14: import { ResourceStats } from "./features/dashboard/ResourceStats";
 15: import { JobGauge } from "./features/dashboard/JobGauge";
 16: import { ThrottleControl } from "./features/dashboard/ThrottleControl";
 17: import { LiveTerminal } from "./features/terminal/LiveTerminal";
 18: import { DeviceConnector } from "./features/connection/DeviceConnector";
 19: import { SwarmControls } from "./features/dashboard/SwarmControls";
 20: 
 21: export default function App() {
 22:   const isMobile = useMediaQuery("(max-width: 768px)");
 23:   const [showMobileTerminal, setShowMobileTerminal] = useState(false);
 24:   const [activeTab, setActiveTab] = useState("Dashboard");
 25:   const [isModalOpen, setIsModalOpen] = useState(false);
 26: 
 27:   const { swarmToken } = usePersistentIdentity();
 28:   const { snapshot, devices, isConnected, logs, actions } = useSwarm();
 29: 
 30:   const {
 31:     setRunState,
 32:     setThrottle: setGlobalThrottle,
 33:     runLocalBenchmark,
 34:     toggleDevice,
 35:     generateInviteToken,
 36:     leaveSwarm,
 37:     manualJoin,
 38:   } = actions;
 39: 
 40:   const [localThrottle, setLocalThrottle] = useState(40);
 41:   const debounceTimer = useRef<NodeJS.Timeout | null>(null);
 42: 
 43:   const totalResources = useMemo(
 44:     () =>
 45:       snapshot?.resources || {
 46:         totalCores: 0,
 47:         totalMemory: 0,
 48:         totalGPUs: 0,
 49:         onlineCount: 0,
 50:       },
 51:     [snapshot],
 52:   );
 53:   const stats = useMemo(
 54:     () =>
 55:       snapshot?.stats || {
 56:         totalJobs: 0,
 57:         activeJobs: 0,
 58:         pendingJobs: 0,
 59:         completedJobs: 0,
 60:         globalVelocity: 0,
 61:         globalThrottle: 20,
 62:       },
 63:     [snapshot],
 64:   );
 65: 
 66:   const isRunning = snapshot?.runState === "RUNNING";
 67:   const isGuest =
 68:     new URLSearchParams(window.location.search).has("invite") || !!swarmToken;
 69: 
 70:   useEffect(() => {
 71:     if (stats.globalThrottle !== undefined)
 72:       setLocalThrottle(stats.globalThrottle);
 73:   }, [stats.globalThrottle]);
 74: 
 75:   const handleThrottleChange = (val: number) => {
 76:     setLocalThrottle(val);
 77:     if (debounceTimer.current) clearTimeout(debounceTimer.current);
 78:     debounceTimer.current = setTimeout(() => setGlobalThrottle(val), 300);
 79:   };
 80: 
 81:   return (
 82:     <div className="min-h-screen bg-surface-muted p-4 md:p-8 font-sans antialiased text-text-main">
 83:       <header className="max-w-7xl mx-auto flex items-center mb-8 bg-surface-white/90 backdrop-blur-md px-6 py-4 rounded-4xl border border-white shadow-lg sticky top-4 z-50 w-full">
 84:         <div className="flex items-center gap-4 flex-1 basis-0">
 85:           <div className="w-12 h-12 bg-surface-white rounded-2xl flex items-center justify-center shadow-soft-depth border border-white relative overflow-hidden group">
 86:             <svg
 87:               viewBox="0 0 512 512"
 88:               className="w-10 h-10 transition-transform duration-500 group-hover:scale-110"
 89:             >
 90:               <path
 91:                 d="M256 120V256M256 256L140 380M256 256L372 380"
 92:                 stroke="#1a1a1e"
 93:                 strokeWidth="48"
 94:                 strokeLinecap="round"
 95:                 strokeLinejoin="round"
 96:               />
 97:               <path
 98:                 d="M256 130V256M256 256L150 370M256 256L362 370"
 99:                 stroke="#ff7d54"
100:                 strokeWidth="24"
101:                 strokeLinecap="round"
102:                 strokeLinejoin="round"
103:               />
104:               <circle cx="256" cy="256" r="55" fill="#1a1a1e" />
105:               <circle
106:                 cx="256"
107:                 cy="256"
108:                 r="30"
109:                 fill="#ff7d54"
110:                 className="animate-pulse"
111:               />
112:             </svg>
113:           </div>
114:           <div className="flex flex-col justify-center -space-y-1">
115:             <span className="text-lg md:text-xl font-black tracking-tighter text-gray-800 leading-tight">
116:               Ostrich-Legs
117:             </span>
118:             <div
119:               className={`flex items-center gap-1.5 text-[9px] font-bold ${isConnected ? "text-green-600" : "text-amber-500 animate-pulse"}`}
120:             >
121:               {isConnected ? (
122:                 <Wifi size={10} />
123:               ) : (
124:                 <RefreshCw size={10} className="animate-spin" />
125:               )}
126:               {isConnected ? "CONNECTED" : "ESTABLISHING LINK..."}
127:             </div>
128:           </div>
129:           <nav className="absolute left-1/2 -translate-x-1/2 hidden lg:flex items-center gap-1 bg-gray-100/80 p-1.5 rounded-2xl shadow-inner border border-gray-200/50">
130:             {["Dashboard", "Monitoring"].map((tab) => (
131:               <button
132:                 key={tab}
133:                 onClick={() => setActiveTab(tab)}
134:                 className={`px-6 py-2 rounded-xl text-xs font-bold transition-all ${activeTab === tab ? "bg-white text-brand-orange shadow-sm border border-gray-100" : "text-text-muted hover:text-text-main"}`}
135:               >
136:                 {tab}
137:               </button>
138:             ))}
139:           </nav>
140:           <div className="ml-auto flex items-center gap-3">
141:             {isConnected && (
142:               <button
143:                 onClick={leaveSwarm}
144:                 className="flex items-center gap-2.5 bg-red-50 text-red-600 px-5 py-2.5 rounded-2xl text-[11px] font-bold border border-red-100 hover:bg-red-500 hover:text-white transition-all uppercase tracking-wider shadow-sm"
145:               >
146:                 <LogOut size={16} />{" "}
147:                 <span className="hidden sm:inline">
148:                   {isGuest ? "Leave Swarm" : "Exit Session"}
149:                 </span>
150:               </button>
151:             )}
152: 
153:             <button
154:               onClick={() => setIsModalOpen(true)}
155:               className="p-2 hover:bg-gray-100 rounded-xl"
156:             >
157:               <Share2 size={20} className="text-text-muted" />
158:             </button>
159:           </div>
160:         </div>
161:       </header>
162:       <main className="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-12 gap-8 pb-12">
163:         {activeTab === "Dashboard" ? (
164:           <>
165:             <div className="lg:col-span-8 space-y-8 flex flex-col">
166:               <VelocityMonitor
167:                 velocity={stats.globalVelocity}
168:                 throttle={localThrottle}
169:               />
170:               <ResourceStats stats={stats} onlineCount={devices.length} />
171:               <div className="flex-1 min-h-100">
172:                 <ActiveSwarm
173:                   devices={devices}
174:                   onBenchmark={runLocalBenchmark}
175:                   onToggle={toggleDevice}
176:                 />
177:               </div>
178:               {isMobile && (
179:                 <div className="mt-6 border-t pt-6">
180:                   <button
181:                     onClick={() => setShowMobileTerminal(!showMobileTerminal)}
182:                     className="w-full flex items-center justify-center gap-2.5 bg-gray-900 text-white py-3.5 rounded-2xl font-bold text-sm"
183:                   >
184:                     <Terminal size={18} />{" "}
185:                     {showMobileTerminal ? "Hide System Logs" : "Show Live Logs"}
186:                   </button>
187:                   {showMobileTerminal && (
188:                     <div className="mt-4 h-80 rounded-3xl overflow-hidden border border-border-soft shadow-inner">
189:                       <LiveTerminal logs={logs} />
190:                     </div>
191:                   )}
192:                 </div>
193:               )}
194:             </div>
195:             <div className="lg:col-span-4 space-y-8">
196:               <JobGauge
197:                 total={stats.totalJobs}
198:                 completed={stats.completedJobs}
199:               />
200:               <SwarmControls
201:                 status={snapshot?.runState || "STOPPED"}
202:                 onToggle={() => setRunState(isRunning ? "PAUSED" : "RUNNING")}
203:                 onStop={() => setRunState("STOPPED")}
204:               />
205:               <ThrottleControl
206:                 value={localThrottle}
207:                 onChange={handleThrottleChange}
208:                 totalGPUs={totalResources.totalGPUs}
209:                 totalCores={totalResources.totalCores}
210:                 totalMemory={totalResources.totalMemory}
211:               />
212:             </div>
213:           </>
214:         ) : (
215:           <div className="lg:col-span-12 h-[80vh]">
216:             <LiveTerminal logs={logs} />
217:           </div>
218:         )}
219:       </main>
220:       <DeviceConnector
221:         isOpen={isModalOpen}
222:         onClose={() => setIsModalOpen(false)}
223:         onRegenerateToken={generateInviteToken}
224:         onManualJoin={manualJoin}
225:         onLeave={leaveSwarm}
226:         isGuest={isGuest}
227:       />
228:     </div>
229:   );
230: }
</file>

</files>
