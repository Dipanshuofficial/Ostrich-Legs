This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where line numbers have been added.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: client/src/**/*, server/src/**/*, shared/**/*, *.md, package.json, client/package.json, server/package.json, client/tsconfig*.json, server/tsconfig.json, client/vite.config.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<user_provided_header>
OSTRICH-LEGS: Distributed Compute Platform Context
</user_provided_header>

<directory_structure>
Architecture.md
client/package.json
client/src/App.tsx
client/src/components/Card.tsx
client/src/components/ErrorBoundary.tsx
client/src/contexts/SwarmContext.tsx
client/src/core/constants.ts
client/src/core/SocketManager.ts
client/src/core/swarmStore.ts
client/src/core/theme.css
client/src/core/types.ts
client/src/features/connection/DeviceConnector.tsx
client/src/features/dashboard/ActiveSwarm.tsx
client/src/features/dashboard/JobGauge.tsx
client/src/features/dashboard/ResourceStats.tsx
client/src/features/dashboard/SwarmControls.tsx
client/src/features/dashboard/ThrottleControl.tsx
client/src/features/dashboard/VelocityMonitor.tsx
client/src/features/terminal/LiveTerminal.tsx
client/src/hooks/useMediaQuery.ts
client/src/hooks/usePersistentIdentity.ts
client/src/hooks/useSocket.ts
client/src/hooks/useTheme.ts
client/src/hooks/useWorker.ts
client/src/main.tsx
client/src/utils/compute.worker.ts
client/src/utils/metrics.ts
client/tsconfig.app.json
client/tsconfig.json
client/tsconfig.node.json
client/vite.config.ts
server/package.json
server/src/core/types.ts
server/src/index.ts
server/src/managers/AuthManager.ts
server/src/managers/DeviceManager.ts
server/src/managers/JobScheduler.ts
server/tsconfig.json
shared/socket/events.ts
shared/socket/payloads.ts
shared/socket/states.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Architecture.md">
  1: # Ostrich-Legs Architecture
  2: 
  3: ## Executive Summary
  4: 
  5: Ostrich-Legs is a distributed computing platform enabling browser-based devices to form collaborative compute swarms. The system implements a hierarchical master-worker topology with real-time orchestration, adaptive throttling, and capability-aware job scheduling.
  6: 
  7: ## System Topology
  8: 
  9: ```
 10: ┌─────────────────────────────────────────────────────────────────┐
 11: │                        SWARM CLUSTER                              │
 12: │                                                                   │
 13: │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐           │
 14: │  │ Master Node  │  │ Worker Node  │  │ Worker Node  │           │
 15: │  │  (Browser)   │  │  (Mobile)    │  │  (Desktop)   │           │
 16: │  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘           │
 17: │         │                 │                 │                    │
 18: │         └─────────────────┴─────────────────┘                    │
 19: │                           │                                      │
 20: │                    WebSocket (Socket.io)                         │
 21: │                           │                                      │
 22: │         ┌─────────────────┴─────────────────┐                    │
 23: │         │                                   │                    │
 24: │    ┌────▼────┐                        ┌─────▼────┐              │
 25: │    │ Bun     │                        │ Bun      │              │
 26: │    │ Server  │◄──────────────────────►│ Server   │              │
 27: │    │ :3000  │   Horizontal Scale      │ :3001    │              │
 28: │    └────┬────┘                        └─────┬────┘              │
 29: │         │                                    │                   │
 30: └─────────┼────────────────────────────────────┼───────────────────┘
 31:           │                                    │
 32:           └──────────────┬─────────────────────┘
 33:                          │
 34:                     Redis/PubSub
 35:               (Eventual: State Synchronization)
 36: ```
 37: 
 38: ---
 39: 
 40: ## Directory Structure
 41: 
 42: ```
 43: Ostrich-Legs/
 44: ├── client/                          # React Frontend (Vite + SWC)
 45: │   ├── src/
 46: │   │   ├── features/               # Domain-organized feature modules
 47: │   │   │   ├── connection/         # Device onboarding & swarm joining
 48: │   │   │   │   └── DeviceConnector.tsx
 49: │   │   │   ├── dashboard/          # Compute visualization & controls
 50: │   │   │   │   ├── ActiveSwarm.tsx
 51: │   │   │   │   ├── JobGauge.tsx
 52: │   │   │   │   ├── ResourceStats.tsx
 53: │   │   │   │   ├── SwarmControls.tsx
 54: │   │   │   │   ├── ThrottleControl.tsx
 55: │   │   │   │   └── VelocityMonitor.tsx
 56: │   │   │   └── terminal/           # System logging interface
 57: │   │   │       └── LiveTerminal.tsx
 58: │   │   ├── components/             # Shared UI primitives
 59: │   │   │   └── Card.tsx
 60: │   │   ├── hooks/                  # State management & side effects
 61: │   │   │   ├── usePersistentIdentity.ts
 62: │   │   │   └── useSwarmEngine.ts
 63: │   │   ├── utils/                  # Computational workers
 64: │   │   │   └── compute.worker.ts
 65: │   │   ├── core/                   # Client-side type definitions & theming
 66: │   │   │   ├── types.ts
 67: │   │   │   └── theme.css
 68: │   │   ├── App.tsx                 # Root component & layout orchestration
 69: │   │   └── main.tsx                # Application bootstrap
 70: │   ├── package.json
 71: │   └── vite.config.ts
 72: │
 73: ├── server/                          # Bun Backend (Socket.io)
 74: │   ├── src/
 75: │   │   ├── managers/               # Domain logic controllers
 76: │   │   │   ├── AuthManager.ts      # Token generation & validation
 77: │   │   │   ├── DeviceManager.ts    # Device lifecycle & health
 78: │   │   │   └── JobScheduler.ts     # Job queue & dispatch
 79: │   │   ├── core/                   # Server-side type definitions
 80: │   │   │   └── types.ts
 81: │   │   └── index.ts                # Socket.io server & event handlers
 82: │   └── package.json
 83: │
 84: └── shared/                          # Cross-boundary type contracts
 85:     └── socket/
 86:         ├── events.ts               # Canonical event name registry
 87:         ├── payloads.ts             # Request/response type definitions
 88:         └── states.ts               # State enumerations & log types
 89: ```
 90: 
 91: ---
 92: 
 93: ## Shared Type Architecture
 94: 
 95: ### Contract Boundary: `shared/socket/`
 96: 
 97: All client-server communication flows through strictly typed contracts defined in the shared directory. This ensures compile-time safety across the network boundary.
 98: 
 99: #### Event Registry (`shared/socket/events.ts`)
100: 
101: ```typescript
102: SocketEvents = {
103:   // Lifecycle
104:   CONNECT: "connect",
105:   DISCONNECT: "disconnect",
106:   CONNECTION_ERROR: "connect_error",
107: 
108:   // Identity
109:   DEVICE_REGISTER: "device:register",
110:   DEVICE_READY: "device:ready",
111:   HEARTBEAT: "heartbeat",
112: 
113:   // Orchestration
114:   SWARM_SNAPSHOT: "swarm:snapshot",
115:   SWARM_SET_STATE: "cmd:set_run_state",
116:   SWARM_SET_THROTTLE: "cmd:set_throttle",
117:   SWARM_THROTTLE_SYNC: "swarm:throttle_sync",
118: 
119:   // Job Pipeline
120:   JOB_REQUEST_BATCH: "job:request_batch",
121:   JOB_BATCH_DISPATCH: "job:batch",
122:   JOB_COMPLETE: "job:complete",
123: 
124:   // Diagnostics
125:   SYSTEM_LOG: "sys:log",
126:   BENCHMARK_START: "cmd:run_benchmark",
127:   BENCHMARK_RESULT: "benchmark:result",
128: };
129: ```
130: 
131: #### State Enumerations (`shared/socket/states.ts`)
132: 
133: ```
134: SwarmRunState: "IDLE" | "RUNNING" | "PAUSED" | "STOPPED"
135: DeviceConnectionStatus: "OFFLINE" | "ONLINE" | "BUSY" | "DISABLED"
136: LogLevel: "SYS" | "NET" | "CPU" | "GPU" | "ERR" | "WARN"
137: ```
138: 
139: #### Payload Contracts (`shared/socket/payloads.ts`)
140: 
141: | Payload                 | Direction | Fields                                                                                          |
142: | ----------------------- | --------- | ----------------------------------------------------------------------------------------------- |
143: | `DeviceRegisterPayload` | C→S       | name, capabilities {cpuCores, memoryGB, gpuAvailable, gpuName?}                                 |
144: | `JobCompletePayload`    | C→S       | chunkId, workerId, result?, error?, durationMs?                                                 |
145: | `SwarmSnapshotPayload`  | S→C       | runState, devices, stats {totalJobs, completedJobs, activeJobs, globalVelocity, globalThrottle} |
146: | `SystemLogPayload`      | S→C       | level, message, timestamp, source?                                                              |
147: 
148: ---
149: 
150: ## Client Architecture
151: 
152: ### Module Hierarchy
153: 
154: ```
155: App.tsx (Orchestrator)
156: │
157: ├── usePersistentIdentity.ts ──► localStorage ("ostrich_device_id", "ostrich_device_name")
158: │
159: ├── useSwarmEngine.ts ────────► Socket.io connection
160: │   │
161: │   ├── socketRef ────────────► SocketEvents.CONNECT
162: │   │                           SocketEvents.JOB_BATCH_DISPATCH
163: │   │                           SocketEvents.SWARM_SNAPSHOT
164: │   │                           SocketEvents.SYSTEM_LOG
165: │   │
166: │   └── workerRef ────────────► compute.worker.ts
167: │       │
168: │       ├── "BENCHMARK" ──────► BenchmarkResult ──► SocketEvents.BENCHMARK_RESULT
169: │       ├── "EXECUTE_JOB" ────► JobComplete ──────► SocketEvents.JOB_COMPLETE
170: │       └── "JOB_ERROR" ──────► ErrorLog ─────────► SocketEvents.JOB_COMPLETE (with error)
171: │
172: ├── Dashboard View
173: │   │
174: │   ├── VelocityMonitor.tsx ──► Canvas API (real-time velocity graph)
175: │   ├── ResourceStats.tsx ────► Grid display (online nodes, active jobs, pending)
176: │   ├── ActiveSwarm.tsx ──────► Device list with toggle controls
177: │   ├── JobGauge.tsx ─────────► SVG circular progress (completed/total)
178: │   ├── SwarmControls.tsx ────► Play/Pause/Stop buttons ──► SocketEvents.SWARM_SET_STATE
179: │   └── ThrottleControl.tsx ──► Range slider ─────────────► SocketEvents.SWARM_SET_THROTTLE
180: │
181: ├── LiveTerminal.tsx ─────────► Scrollable log feed (logs state from useSwarmEngine)
182: │
183: └── DeviceConnector.tsx ──────► Modal overlay
184:     │
185:     ├── QRCode generation ────► qrcode.react
186:     ├── QR Scanner ───────────► html5-qrcode
187:     └── Manual join ──────────► SocketEvents.auth:generate_token
188: ```
189: 
190: ### Compute Worker Architecture (`client/src/utils/compute.worker.ts`)
191: 
192: The Web Worker implements a thread pool pattern with WebGPU capability detection:
193: 
194: ```
195: ┌─────────────────────────────────────────┐
196: │       MAIN THREAD (useSwarmEngine)      │
197: │                                         │
198: │  globalSocket ←──────────────────────┐  │
199: │  globalWorker ──► postMessage() ───┐ │  │
200: └────────────────────────────────────│─┼──┘
201:                                      │ │
202:                     ┌────────────────┘ │
203:                     ▼                  │
204: ┌──────────────────────────────────┐   │
205: │    COMPUTE WORKER (compute.worker.ts) │
206: │                                  │   │
207: │  ThreadPool: Map<id, SubWorker>  │   │
208: │                                  │   │
209: │  ┌──────────┐  ┌──────────┐     │   │
210: │  │ Worker 0 │  │ Worker 1 │ ... │   │
211: │  │ ┌──────┐ │  │ ┌──────┐ │     │   │
212: │  │ │CPU   │ │  │ │CPU   │ │     │   │
213: │  │ │Math  │ │  │ │Math  │ │     │   │
214: │  │ └──────┘ │  │ └──────┘ │     │   │
215: │  └──────────┘  └──────────┘     │   │
216: │                                  │   │
217: │  SubWorkers created via Blob URL │   │
218: │  (Vanilla JS, no TypeScript)     │   │
219: └──────────────────────────────────┘   │
220:                     │                  │
221:                     └──── onmessage ───┘
222:                           (score, result, error)
223: ```
224: 
225: **Worker Thread Pool Formula:**
226: 
227: ```typescript
228: TOTAL_CORES = navigator.hardwareConcurrency || 4;
229: RESERVED_CORES = TOTAL_CORES > 8 ? 2 : 1;
230: LOGICAL_CORES = Math.max(1, TOTAL_CORES - RESERVED_CORES);
231: targetThreadCount = Math.max(1, Math.floor(LOGICAL_CORES * throttleLimit));
232: ```
233: 
234: **WebGPU Support:**
235: 
236: - WGSL shader embedded in worker for matrix multiplication (`MAT_MUL` jobs)
237: - Graceful fallback to CPU stress (`MATH_STRESS`) on GPU init failure
238: 
239: ---
240: 
241: ## Server Architecture
242: 
243: ### Event Handler Matrix (`server/src/index.ts`)
244: 
245: ```
246: ┌──────────────────────────────────────────────────────────────┐
247: │                    SOCKET.IO SERVER (Port 3000)                │
248: │                                                                │
249: │  Auth Middleware                                               │
250: │  ├── Extract: handshake.auth.token || handshake.query.token   │
251: │  ├── Extract: handshake.query.persistentId                    │
252: │  └── Assign: socket.data.swarmId                              │
253: │                                                                │
254: │  Connection Handlers                                           │
255: │  ├── DEVICE_REGISTER ──► DeviceManager.register()             │
256: │  ├── HEARTBEAT ────────► DeviceManager.heartbeat()            │
257: │  │                       └── 10s interval from client         │
258: │  ├── JOB_REQUEST_BATCH ─► JobScheduler.getJobForDevice()     │
259: │  │   │                        ↓                               │
260: │  │   └── JOB_BATCH_DISPATCH ──► Array<Job>                   │
261: │  │                                                            │
262: │  ├── JOB_COMPLETE ─────► swarmCompletedCounts++              │
263: │  │                       DeviceManager.updateScore()          │
264: │  │                                                            │
265: │  ├── cmd:toggle_device ─► DeviceManager.toggleDevice()       │
266: │  ├── SWARM_SET_STATE ──► swarmStates Map                     │
267: │  ├── SWARM_SET_THROTTLE ► swarmThrottles Map                 │
268: │  │                       └── SWARM_THROTTLE_SYNC broadcast    │
269: │  ├── BENCHMARK_RESULT ─► DeviceManager.updateScore()         │
270: │  ├── auth:generate_token ► AuthManager.generateToken()       │
271: │  └── disconnect ───────► Room cleanup check                   │
272: │                                                                │
273: │  Global Broadcast Loop (2s interval)                          │
274: │  └── broadcastState() ──► SWARM_SNAPSHOT to all rooms         │
275: └──────────────────────────────────────────────────────────────┘
276: ```
277: 
278: ### Manager Classes
279: 
280: #### DeviceManager (`server/src/managers/DeviceManager.ts`)
281: 
282: ```typescript
283: State Container:
284: ├── devices: Map<string, DeviceInfo>
285: ├── OFFLINE_THRESHOLD: 60000ms (1 minute)
286: └── DELETE_THRESHOLD: 300000ms (5 minutes)
287: 
288: Lifecycle:
289: register(id, name, caps, swarmId) ──► DeviceInfo
290: heartbeat(id, data?) ──► Update lastHeartbeat, lastUserInteraction
291: toggleDevice(id, enabled) ──► status: "ONLINE" | "DISABLED"
292: updateScore(id, score) ──► opsScore assignment
293: cleanup() ──► Every 5s: OFFLINE → DELETE progression
294: 
295: Computed Aggregations:
296: getAvailableResources(swarmId) ──► {totalCores, totalMemory, totalGPUs, onlineCount}
297: getDevicesBySwarm(swarmId) ──► DeviceInfo[]
298: ```
299: 
300: #### JobScheduler (`server/src/managers/JobScheduler.ts`)
301: 
302: ```typescript
303: State Container:
304: ├── jobQueue: Job[]
305: └── MAX_QUEUE_SIZE: 500
306: 
307: Job Generation:
308: setInterval(generateJobs, 2000ms)
309: ├── 50 jobs per batch
310: ├── 70% CPU tasks (MATH_STRESS)
311: └── 30% GPU tasks (MAT_MUL)
312: 
313: Dispatch Logic:
314: getJobForDevice(device) ──► Job | null
315: ├── Capability matching: GPU devices → MAT_MUL
316: ├── Fallback: Any available job
317: └── Exclusion: DISABLED/OFFLINE devices
318: ```
319: 
320: #### AuthManager (`server/src/managers/AuthManager.ts`)
321: 
322: ```typescript
323: State Container:
324: ├── activeTokens: Map<string, {swarmId, expiresAt}>
325: └── TOKEN_TTL_MS: 900000ms (15 minutes)
326: 
327: Token Flow:
328: generateToken(swarmId) ──► 6-char alphanumeric code
329: validateToken(token) ──► swarmId | null
330: cleanup() ──► Every 30s: Expired token removal
331: ```
332: 
333: ---
334: 
335: ## State Flow Diagrams
336: 
337: ### Device Registration Flow
338: 
339: ```
340: ┌──────────┐     DEVICE_REGISTER     ┌──────────┐
341: │  Client  │ ───────────────────────► │  Server  │
342: │          │ {name, capabilities}     │          │
343: │          │                          │ DeviceManager
344: │          │     DEVICE_READY         │          │
345: │          │ ◄─────────────────────── │          │
346: │          │                          │          │
347: │          │     HEARTBEAT (10s)      │          │
348: │          │ ═══════════════════════► │          │
349: │          │ {lastInteraction}        │ DeviceManager
350: │          │                          │ .heartbeat()
351: └──────────┘                          └──────────┘
352: ```
353: 
354: ### Job Execution Flow
355: 
356: ```
357: ┌──────────┐   JOB_REQUEST_BATCH   ┌──────────┐
358: │  Client  │ ─────────────────────► │  Server  │
359: │          │                        │          │
360: │          │   JOB_BATCH_DISPATCH   │          │
361: │  Worker  │ ◄───────────────────── │ Scheduler│
362: │  Pool    │ Array<5 Jobs>          │ .getJobForDevice()
363: │          │                        │          │
364: │  ┌────┐  │                        │          │
365: │  │ W0 │  │  EXECUTE_JOB (CPU/GPU) │          │
366: │  │ W1 │  │ ─────────────────────► │          │
367: │  │ W2 │  │                        │          │
368: │  │ W3 │  │    JOB_COMPLETE        │          │
369: │  └────┘  │ ◄───────────────────── │          │
370: │          │ {chunkId, result,      │  Counts  │
371: │          │  durationMs}           │  Update  │
372: │          │                        │          │
373: │          │   JOB_REQUEST_BATCH    │          │
374: │          │ ─────────────────────► │          │
375: │          │   (Keep pipeline full) │          │
376: └──────────┘                        └──────────┘
377: ```
378: 
379: ### Throttle Propagation Flow
380: 
381: ```
382: ┌──────────┐  SWARM_SET_THROTTLE  ┌──────────┐
383: │  Master  │ ────────────────────► │  Server  │
384: │  Client  │ {value: 0-100}        │          │
385: │          │                       │ swarmThrottles
386: │          │  SWARM_THROTTLE_SYNC  │    Map   │
387: │          │ ◄───────────────────  │          │
388: │          │ Broadcast to swarmId  │          │
389: │          │                       │          │
390: ├──────────┤                       │          │
391: │ Worker 1 │ ◄───────────────────  │          │
392: │ Worker 2 │ ◄───────────────────  │          │
393: │ Worker N │ ◄───────────────────  │          │
394: └──────────┘                       └──────────┘
395:          │
396:          ▼
397: ┌──────────────────────────┐
398: │ compute.worker.ts        │
399: │ threadPool scaling:      │
400: │ LOGICAL_CORES * throttle │
401: └──────────────────────────┘
402: ```
403: 
404: ### Swarm State Machine
405: 
406: ```
407:                     ┌─────────┐
408:          ┌─────────►│  IDLE   │◄────────┐
409:          │          └────┬────┘         │
410:          │               │              │
411:     STOP │          START│         STOP │
412:          │               ▼              │
413: ┌────────┴─┐      ┌──────────┐    ┌────┴───┐
414: │ STOPPED  │◄─────│ RUNNING  │───►│ PAUSED │
415: └──────────┘ STOP  └────┬─────┘    └────────┘
416:                         │
417:                         │ JOB_REQUEST_BATCH
418:                         ▼
419:                   ┌─────────────┐
420:                   │ JobExecution│
421:                   │   (Worker)  │
422:                   └─────────────┘
423: ```
424: 
425: ---
426: 
427: ## Data Models
428: 
429: ### Client Types (`client/src/core/types.ts`)
430: 
431: ```typescript
432: SwarmStatus: "IDLE" | "RUNNING" | "PAUSED" | "STOPPED"
433: DeviceType: "DESKTOP" | "MOBILE" | "COLAB" | "SERVER"
434: JobType: "MATH_STRESS" | "MAT_MUL" | "TEXT_TOKENIZE"
435: 
436: DeviceCapabilities:
437: ├── cpuCores: number
438: ├── memoryGB: number
439: ├── gpuAvailable: boolean
440: └── gpuName?: string
441: 
442: DeviceInfo:
443: ├── id: string
444: ├── name: string
445: ├── type: DeviceType
446: ├── status: "ONLINE" | "BUSY" | "OFFLINE" | "DISABLED"
447: ├── capabilities: DeviceCapabilities
448: ├── opsScore: number
449: ├── totalJobsCompleted: number
450: └── lastHeartbeat: number
451: 
452: SwarmSnapshot:
453: ├── runState: SwarmStatus
454: ├── devices: Record<string, DeviceInfo>
455: ├── stats: {
456: │   ├── totalJobs: number
457: │   ├── activeJobs: number
458: │   ├── pendingJobs: number
459: │   ├── completedJobs: number
460: │   ├── globalVelocity: number
461: │   └── globalThrottle?: number
462: │}
463: └── resources: {
464:     ├── totalCores: number
465:     ├── totalMemory: number
466:     ├── totalGPUs: number
467:     └── onlineCount: number
468: }
469: ```
470: 
471: ### Server Types (`server/src/core/types.ts`)
472: 
473: Extends client types with server-specific fields:
474: 
475: ```typescript
476: DeviceInfo (Extended):
477: ├── lastUserInteraction: number
478: ├── swarmId: string
479: └── status: + "REGISTERED"
480: 
481: Job:
482: ├── id: string
483: ├── type: JobType
484: ├── complexity: number
485: └── data: any
486: ```
487: 
488: ---
489: 
490: ## Persistence & Identity
491: 
492: ### LocalStorage Schema
493: 
494: | Key                   | Value                          | Lifecycle      |
495: | --------------------- | ------------------------------ | -------------- |
496: | `ostrich_device_id`   | `node-${random(36)}`           | Permanent      |
497: | `ostrich_device_name` | "Desktop Node" / "Mobile Node" | Auto-generated |
498: 
499: ### Identity Resolution
500: 
501: ```
502: First Visit:
503:   ↓
504: Generate node-id ──► localStorage.setItem("ostrich_device_id", id)
505:   ↓
506: Detect platform ──► localStorage.setItem("ostrich_device_name", name)
507:   ↓
508: Subsequent visits: Read from localStorage
509: ```
510: 
511: ---
512: 
513: ## Build & Runtime Configuration
514: 
515: ### Client (`client/vite.config.ts`)
516: 
517: ```typescript
518: Plugins:
519: ├── @vitejs/plugin-react-swc (Fast compilation)
520: └── @tailwindcss/vite (Tailwind v4)
521: 
522: Server Proxy:
523: ├── /api ────────► http://localhost:3000
524: └── /socket.io ──► ws://localhost:3000
525: 
526: Resolve Alias:
527: └── @shared ─────► ../shared
528: ```
529: 
530: ### Theme System (`client/src/core/theme.css`)
531: 
532: ```css
533: Design Tokens:
534: ├── --color-brand-orange: #ff7d54
535: ├── --color-brand-peach: #ffb09c
536: ├── --color-surface-white: #fcfcfd
537: ├── --color-surface-muted: #f3f4f6
538: ├── --color-text-main: #1a1a1e
539: ├── --color-text-muted: #6b7280
540: ├── --color-border-soft: rgba(0,0,0,0.05)
541: ├── --shadow-card: 0 20px 40px -12px rgba(0,0,0,0.05)
542: ├── --radius-xl: 24px
543: └── --radius-2xl: 32px
544: 
545: Components:
546: └── .soft-card: Elevated card with neumorphic shadow
547: ```
548: 
549: ---
550: 
551: ## Security Model
552: 
553: ### Authentication Flow
554: 
555: ```
556: 1. Handshake
557:    Client ──► Server
558:    {
559:      persistentId: localStorage ID,
560:      token?: invite code
561:    }
562: 
563: 2. Middleware Resolution
564:    ├── No token / empty ──► Own swarm (Master)
565:    ├── Valid token ───────► Target swarm (Worker)
566:    └── Invalid token ─────► Fallback to own swarm
567: 
568: 3. Room Assignment
569:    socket.join(swarmId)
570: 
571: 4. Token Lifecycle
572:    AuthManager.generateToken() ──► 15 min TTL
573:    AuthManager.validateToken() ──► One-time lookup
574: ```
575: 
576: ### Device Capability Isolation
577: 
578: - Workers cannot access DOM
579: - Workers execute in sandboxed Blob URLs
580: - No eval() of untrusted code
581: - WebGPU errors caught and fallback to CPU
582: 
583: ---
584: 
585: ## Performance Characteristics
586: 
587: ### Client-Side
588: 
589: | Metric              | Value                     | Notes                           |
590: | ------------------- | ------------------------- | ------------------------------- |
591: | Canvas refresh      | 60 FPS                    | requestAnimationFrame           |
592: | Socket reconnection | Infinite                  | exponential backoff starting 1s |
593: | Worker threads      | LOGICAL_CORES \* throttle | Dynamic scaling                 |
594: | Log retention       | 50 entries                | Circular buffer                 |
595: | Heartbeat interval  | 10s                       | Prevents OFFLINE status         |
596: 
597: ### Server-Side
598: 
599: | Metric           | Value        | Notes                      |
600: | ---------------- | ------------ | -------------------------- |
601: | State broadcast  | 2s interval  | Batch updates              |
602: | Job generation   | 50 jobs / 2s | MAX_QUEUE_SIZE: 500        |
603: | Device cleanup   | 5s interval  | OFFLINE: 60s, DELETE: 300s |
604: | Token expiration | 15 minutes   | Auto-cleanup every 30s     |
605: 
606: ---
607: 
608: ## File Dependency Graph
609: 
610: ```
611: shared/socket/events.ts ◄────┬────┬────┬────┬────┬────┬────┐
612:                               │    │    │    │    │    │    │
613:                               ▼    ▼    ▼    ▼    ▼    ▼    ▼
614: ┌─────────────────┐     ┌──────────┐  ┌──────────┐  ┌──────────┐
615: │ server/index.ts │────►│DeviceManager│ JobScheduler│ AuthManager│
616: └─────────────────┘     └──────────┘  └──────────┘  └──────────┘
617:         │                                               ▲
618:         │                                               │
619:         │         ┌─────────────────────────────────────┘
620:         │         │
621:         ▼         │
622: ┌─────────────────┴──────────┐
623: │   client/src/hooks/        │
624: │   useSwarmEngine.ts        │
625: └──────────┬─────────────────┘
626:            │
627:     ┌──────┴──────┬──────────────┐
628:     ▼             ▼              ▼
629: ┌─────────┐  ┌──────────┐  ┌──────────┐
630: │  App.tsx │  │features/ │  │ LiveTerminal
631: │         │  │dashboard/│  │         │
632: │         │  │         │  │         │
633: │ ┌─────┐ │  │Velocity │  │         │
634: │ │Card │ │  │Monitor  │  │         │
635: │ └─────┘ │  │JobGauge │  │         │
636: │         │  │...      │  │         │
637: └─────────┘  └──────────┘  └──────────┘
638:     │
639:     ▼
640: ┌──────────────────────────┐
641: │ features/connection/     │
642: │ DeviceConnector.tsx      │
643: │ (QR + Scanner + Manual)  │
644: └──────────────────────────┘
645: ```
646: 
647: ---
648: 
649: ## Scaling Considerations
650: 
651: ### Horizontal Scaling Path
652: 
653: Current architecture supports single-node server deployment. For horizontal scaling:
654: 
655: 1. **Redis Adapter**: Replace in-memory maps with Redis for:
656:    - `devices` state
657:    - `swarmStates`
658:    - `swarmCompletedCounts`
659:    - `swarmThrottles`
660: 
661: 2. **Sticky Sessions**: Ensure Socket.io connections route to same server instance
662: 
663: 3. **Job Queue**: Migrate from in-memory array to Redis-backed queue (Bull/BullMQ)
664: 
665: ---
666: 
667: ## Version & Dependency Lock
668: 
669: ### Client Dependencies
670: 
671: - React: ^19.2.0
672: - Socket.io-client: ^4.8.3
673: - Tailwind CSS: ^4.1.18
674: - Vite: ^7.2.4
675: - @vitejs/plugin-react-swc: ^4.2.2
676: 
677: ### Server Dependencies
678: 
679: - Bun runtime (required)
680: - Socket.io: ^4.8.3
681: - TypeScript: ^5.1.6
682: 
683: ---
684: 
685: ## Architectural Invariants
686: 
687: 1. **Single Source of Truth**: Server maintains canonical device registry and job queue
688: 2. **Eventual Consistency**: 2s broadcast interval allows for temporary client-side stale data
689: 3. **Graceful Degradation**: WebGPU failure falls back to CPU without user intervention
690: 4. **Idempotent Operations**: Device registration and heartbeat are safely repeatable
691: 5. **Memory Boundaries**: All collections have maximum sizes (jobQueue: 500, logs: 50)
692: 6. **Automatic Cleanup**: No manual intervention required for stale device removal
693: 
694: ---
695: 
696: ## End of Document
697: 
698: _This architecture document represents the complete system topology as of the current codebase state. All references are exact file paths and line-accurate to the source tree._
</file>

<file path="client/package.json">
 1: {
 2:   "name": "client",
 3:   "private": true,
 4:   "version": "0.0.0",
 5:   "type": "module",
 6:   "scripts": {
 7:     "dev": "vite --host",
 8:     "build": "tsc -b && vite build",
 9:     "lint": "eslint .",
10:     "preview": "vite preview"
11:   },
12:   "dependencies": {
13:     "@tailwindcss/vite": "^4.1.18",
14:     "clsx": "^2.1.1",
15:     "framer-motion": "^12.33.0",
16:     "html5-qrcode": "^2.3.8",
17:     "lucide-react": "^0.563.0",
18:     "qrcode.react": "^4.2.0",
19:     "react": "^19.2.0",
20:     "react-dom": "^19.2.0",
21:     "recharts": "^3.7.0",
22:     "socket.io-client": "^4.8.3",
23:     "tailwind-merge": "^3.4.0",
24:     "tailwindcss": "^4.1.18",
25:     "zustand": "^5.0.11"
26:   },
27:   "devDependencies": {
28:     "@eslint/js": "^9.39.1",
29:     "@types/node": "^24.10.1",
30:     "@types/react": "^19.2.5",
31:     "@types/react-dom": "^19.2.3",
32:     "@vitejs/plugin-react-swc": "^4.2.2",
33:     "eslint": "^9.39.1",
34:     "eslint-plugin-react-hooks": "^7.0.1",
35:     "eslint-plugin-react-refresh": "^0.4.24",
36:     "globals": "^16.5.0",
37:     "typescript": "~5.9.3",
38:     "typescript-eslint": "^8.46.4",
39:     "vite": "^7.2.4"
40:   }
41: }
</file>

<file path="client/src/App.tsx">
  1: // client/src/App.tsx
  2: import { useState, useEffect, useRef, useMemo } from "react";
  3: import {
  4:   Sun,
  5:   Moon,
  6:   Wifi,
  7:   Share2,
  8:   LogOut,
  9:   RefreshCw,
 10:   Terminal,
 11: } from "lucide-react";
 12: 
 13: // NEW HOOKS
 14: import { useTheme } from "./hooks/useTheme";
 15: import { useSwarm } from "./contexts/SwarmContext";
 16: import { usePersistentIdentity } from "./hooks/usePersistentIdentity";
 17: import { useMediaQuery } from "./hooks/useMediaQuery";
 18: 
 19: // COMPONENTS
 20: import { VelocityMonitor } from "./features/dashboard/VelocityMonitor";
 21: import { ActiveSwarm } from "./features/dashboard/ActiveSwarm";
 22: import { ResourceStats } from "./features/dashboard/ResourceStats";
 23: import { JobGauge } from "./features/dashboard/JobGauge";
 24: import { ThrottleControl } from "./features/dashboard/ThrottleControl";
 25: import { LiveTerminal } from "./features/terminal/LiveTerminal";
 26: import { DeviceConnector } from "./features/connection/DeviceConnector";
 27: import { SwarmControls } from "./features/dashboard/SwarmControls";
 28: 
 29: export default function App() {
 30:   const isMobile = useMediaQuery("(max-width: 768px)");
 31:   const [showMobileTerminal, setShowMobileTerminal] = useState(false);
 32:   const [activeTab, setActiveTab] = useState("Dashboard");
 33:   const [isModalOpen, setIsModalOpen] = useState(false);
 34:   const { isDark, toggleTheme } = useTheme();
 35:   const { swarmToken } = usePersistentIdentity();
 36:   const { snapshot, devices, isConnected, logs, actions } = useSwarm();
 37: 
 38:   const {
 39:     setRunState,
 40:     setThrottle: setGlobalThrottle,
 41:     runLocalBenchmark,
 42:     toggleDevice,
 43:     generateInviteToken,
 44:     leaveSwarm,
 45:     manualJoin,
 46:   } = actions;
 47: 
 48:   const [localThrottle, setLocalThrottle] = useState(40);
 49:   const debounceTimer = useRef<NodeJS.Timeout | null>(null);
 50: 
 51:   const totalResources = useMemo(
 52:     () =>
 53:       snapshot?.resources || {
 54:         totalCores: 0,
 55:         totalMemory: 0,
 56:         totalGPUs: 0,
 57:         onlineCount: 0,
 58:       },
 59:     [snapshot],
 60:   );
 61:   const stats = useMemo(
 62:     () =>
 63:       snapshot?.stats || {
 64:         totalJobs: 0,
 65:         activeJobs: 0,
 66:         pendingJobs: 0,
 67:         completedJobs: 0,
 68:         globalVelocity: 0,
 69:         globalThrottle: 40,
 70:       },
 71:     [snapshot],
 72:   );
 73: 
 74:   const isRunning = snapshot?.runState === "RUNNING";
 75:   const isGuest =
 76:     new URLSearchParams(window.location.search).has("invite") || !!swarmToken;
 77: 
 78:   useEffect(() => {
 79:     if (stats.globalThrottle !== undefined)
 80:       setLocalThrottle(stats.globalThrottle);
 81:   }, [stats.globalThrottle]);
 82: 
 83:   const handleThrottleChange = (val: number) => {
 84:     setLocalThrottle(val);
 85:     if (debounceTimer.current) clearTimeout(debounceTimer.current);
 86:     debounceTimer.current = setTimeout(() => setGlobalThrottle(val), 300);
 87:   };
 88: 
 89:   return (
 90:     <div className="min-h-screen bg-surface-muted p-4 md:p-8 font-sans antialiased text-text-main">
 91:       <header className="max-w-7xl mx-auto flex items-center mb-8 bg-surface-white/90 backdrop-blur-md px-6 py-4 rounded-4xl border border-white shadow-lg sticky top-4 z-50 w-full">
 92:         <div className="flex items-center gap-4 flex-1 basis-0">
 93:           <div className="w-12 h-12 bg-surface-white rounded-2xl flex items-center justify-center shadow-soft-depth border border-white relative overflow-hidden group">
 94:             <svg
 95:               viewBox="0 0 512 512"
 96:               className="w-10 h-10 transition-transform duration-500 group-hover:scale-110"
 97:             >
 98:               <path
 99:                 d="M256 120V256M256 256L140 380M256 256L372 380"
100:                 stroke="#1a1a1e"
101:                 strokeWidth="48"
102:                 strokeLinecap="round"
103:                 strokeLinejoin="round"
104:               />
105:               <path
106:                 d="M256 130V256M256 256L150 370M256 256L362 370"
107:                 stroke="#ff7d54"
108:                 strokeWidth="24"
109:                 strokeLinecap="round"
110:                 strokeLinejoin="round"
111:               />
112:               <circle cx="256" cy="256" r="55" fill="#1a1a1e" />
113:               <circle
114:                 cx="256"
115:                 cy="256"
116:                 r="30"
117:                 fill="#ff7d54"
118:                 className="animate-pulse"
119:               />
120:             </svg>
121:           </div>
122:           <div className="flex flex-col justify-center -space-y-1">
123:             <span className="text-lg md:text-xl font-black tracking-tighter text-gray-800 leading-tight">
124:               Ostrich-Legs
125:             </span>
126:             <div
127:               className={`flex items-center gap-1.5 text-[9px] font-bold ${isConnected ? "text-green-600" : "text-amber-500 animate-pulse"}`}
128:             >
129:               {isConnected ? (
130:                 <Wifi size={10} />
131:               ) : (
132:                 <RefreshCw size={10} className="animate-spin" />
133:               )}
134:               {isConnected ? "CONNECTED" : "ESTABLISHING LINK..."}
135:             </div>
136:           </div>
137:           <nav className="absolute left-1/2 -translate-x-1/2 hidden lg:flex items-center gap-1 bg-gray-100/80 p-1.5 rounded-2xl shadow-inner border border-gray-200/50">
138:             {["Dashboard", "Monitoring"].map((tab) => (
139:               <button
140:                 key={tab}
141:                 onClick={() => setActiveTab(tab)}
142:                 className={`px-6 py-2 rounded-xl text-xs font-bold transition-all ${activeTab === tab ? "bg-white text-brand-orange shadow-sm border border-gray-100" : "text-text-muted hover:text-text-main"}`}
143:               >
144:                 {tab}
145:               </button>
146:             ))}
147:           </nav>
148:           <div className="ml-auto flex items-center gap-3">
149:             {isConnected && (
150:               <button
151:                 onClick={leaveSwarm}
152:                 className="flex items-center gap-2.5 bg-red-50 text-red-600 px-5 py-2.5 rounded-2xl text-[11px] font-bold border border-red-100 hover:bg-red-500 hover:text-white transition-all uppercase tracking-wider shadow-sm"
153:               >
154:                 <LogOut size={16} />{" "}
155:                 <span className="hidden sm:inline">
156:                   {isGuest ? "Leave Swarm" : "Exit Session"}
157:                 </span>
158:               </button>
159:             )}
160:             <button
161:               onClick={toggleTheme}
162:               className="p-2 hover:bg-surface-white rounded-xl transition-all border border-transparent hover:border-border-soft"
163:               title="Toggle Appearance"
164:             >
165:               {isDark ? (
166:                 <Sun size={20} className="text-brand-orange" />
167:               ) : (
168:                 <Moon size={20} className="text-text-muted" />
169:               )}
170:             </button>
171:             <button
172:               onClick={() => setIsModalOpen(true)}
173:               className="p-2 hover:bg-gray-100 rounded-xl"
174:             >
175:               <Share2 size={20} className="text-text-muted" />
176:             </button>
177:           </div>
178:         </div>
179:       </header>
180:       <main className="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-12 gap-8 pb-12">
181:         {activeTab === "Dashboard" ? (
182:           <>
183:             <div className="lg:col-span-8 space-y-8 flex flex-col">
184:               <VelocityMonitor
185:                 velocity={stats.globalVelocity}
186:                 throttle={localThrottle}
187:               />
188:               <ResourceStats stats={stats} onlineCount={devices.length} />
189:               <div className="flex-1 min-h-100">
190:                 <ActiveSwarm
191:                   devices={devices}
192:                   onBenchmark={runLocalBenchmark}
193:                   onToggle={toggleDevice}
194:                 />
195:               </div>
196:               {isMobile && (
197:                 <div className="mt-6 border-t pt-6">
198:                   <button
199:                     onClick={() => setShowMobileTerminal(!showMobileTerminal)}
200:                     className="w-full flex items-center justify-center gap-2.5 bg-gray-900 text-white py-3.5 rounded-2xl font-bold text-sm"
201:                   >
202:                     <Terminal size={18} />{" "}
203:                     {showMobileTerminal ? "Hide System Logs" : "Show Live Logs"}
204:                   </button>
205:                   {showMobileTerminal && (
206:                     <div className="mt-4 h-80 rounded-3xl overflow-hidden border border-border-soft shadow-inner">
207:                       <LiveTerminal logs={logs} />
208:                     </div>
209:                   )}
210:                 </div>
211:               )}
212:             </div>
213:             <div className="lg:col-span-4 space-y-8">
214:               <JobGauge
215:                 total={stats.totalJobs}
216:                 completed={stats.completedJobs}
217:               />
218:               <SwarmControls
219:                 status={snapshot?.runState || "STOPPED"}
220:                 onToggle={() => setRunState(isRunning ? "PAUSED" : "RUNNING")}
221:                 onStop={() => setRunState("STOPPED")}
222:               />
223:               <ThrottleControl
224:                 value={localThrottle}
225:                 onChange={handleThrottleChange}
226:                 totalGPUs={totalResources.totalGPUs}
227:                 totalCores={totalResources.totalCores}
228:                 totalMemory={totalResources.totalMemory}
229:               />
230:             </div>
231:           </>
232:         ) : (
233:           <div className="lg:col-span-12 h-[80vh]">
234:             <LiveTerminal logs={logs} />
235:           </div>
236:         )}
237:       </main>
238:       <DeviceConnector
239:         isOpen={isModalOpen}
240:         onClose={() => setIsModalOpen(false)}
241:         onRegenerateToken={generateInviteToken}
242:         onManualJoin={manualJoin}
243:         onLeave={leaveSwarm}
244:         isGuest={isGuest}
245:       />
246:     </div>
247:   );
248: }
</file>

<file path="client/src/components/Card.tsx">
 1: import { type ReactNode } from "react";
 2: import { clsx, type ClassValue } from "clsx";
 3: import { twMerge } from "tailwind-merge";
 4: 
 5: function cn(...inputs: ClassValue[]) {
 6:   return twMerge(clsx(inputs));
 7: }
 8: 
 9: interface CardProps {
10:   children: ReactNode;
11:   className?: string;
12:   variant?: "flat" | "elevated" | "glass";
13: }
14: 
15: export const Card = ({
16:   children,
17:   className,
18:   variant = "elevated",
19: }: CardProps) => {
20:   const variants = {
21:     flat: "bg-surface-white border border-border-soft",
22:     elevated: "soft-card",
23:     glass: "bg-white/70 backdrop-blur-md border border-white/20 shadow-lg",
24:   };
25: 
26:   return <div className={cn(variants[variant], className)}>{children}</div>;
27: };
</file>

<file path="client/src/components/ErrorBoundary.tsx">
 1: // client/src/components/ErrorBoundary.tsx - NEW FILE
 2: import { Component, type ErrorInfo, type ReactNode } from "react";
 3: 
 4: interface Props {
 5:   children: ReactNode;
 6:   fallback?: ReactNode;
 7: }
 8: 
 9: interface State {
10:   hasError: boolean;
11:   error?: Error;
12: }
13: 
14: export class ErrorBoundary extends Component<Props, State> {
15:   state: State = { hasError: false };
16: 
17:   static getDerivedStateFromError(error: Error): State {
18:     return { hasError: true, error };
19:   }
20: 
21:   componentDidCatch(error: Error, errorInfo: ErrorInfo) {
22:     console.error("ErrorBoundary caught:", error, errorInfo);
23:     // Could send to error tracking service here
24:   }
25: 
26:   render() {
27:     if (this.state.hasError) {
28:       return (
29:         this.props.fallback || (
30:           <div className="min-h-screen flex items-center justify-center bg-surface-muted">
31:             <div className="bg-white p-8 rounded-2xl shadow-lg max-w-md text-center">
32:               <h2 className="text-xl font-bold text-red-600 mb-4">
33:                 Something went wrong
34:               </h2>
35:               <p className="text-gray-600 mb-4">
36:                 The application encountered an error. Please refresh the page.
37:               </p>
38:               <button
39:                 onClick={() => window.location.reload()}
40:                 className="bg-brand-orange text-white px-6 py-2 rounded-xl font-bold"
41:               >
42:                 Reload Application
43:               </button>
44:             </div>
45:           </div>
46:         )
47:       );
48:     }
49: 
50:     return this.props.children;
51:   }
52: }
</file>

<file path="client/src/contexts/SwarmContext.tsx">
 1: // client/src/contexts/SwarmContext.tsx
 2: import { createContext, useContext, type ReactNode, useMemo } from "react";
 3: import {
 4:   type SwarmSnapshot,
 5:   type DeviceInfo,
 6:   type SwarmStatus,
 7: } from "../core/types";
 8: import { useSocket } from "../hooks/useSocket";
 9: import { useSwarmStore } from "../core/swarmStore";
10: import { useWorker } from "../hooks/useWorker";
11: 
12: interface SwarmContextType {
13:   snapshot: SwarmSnapshot | null;
14:   devices: DeviceInfo[];
15:   isConnected: boolean;
16:   logs: string[];
17:   actions: {
18:     setRunState: (state: SwarmStatus) => void;
19:     setThrottle: (value: number) => void;
20:     toggleDevice: (id: string, enabled: boolean) => void;
21:     runLocalBenchmark: () => void;
22:     generateInviteToken: () => Promise<string>;
23:     leaveSwarm: () => void;
24:     manualJoin: (code: string) => Promise<void>;
25:   };
26: }
27: 
28: const SwarmContext = createContext<SwarmContextType | undefined>(undefined);
29: 
30: export const SwarmProvider = ({ children }: { children: ReactNode }) => {
31:   const { snapshot, isConnected, logs } = useSwarmStore();
32: 
33:   // 1. Initialize Worker Logic
34:   const { runLocalBenchmark, executeJob } = useWorker();
35: 
36:   // 2. Initialize Socket Logic with Worker Bridge
37:   const socketActions = useSocket(executeJob);
38: 
39:   const devices = useMemo(
40:     () => (snapshot ? Object.values(snapshot.devices) : []),
41:     [snapshot],
42:   );
43: 
44:   const value = useMemo(
45:     () => ({
46:       snapshot,
47:       devices,
48:       isConnected,
49:       logs,
50:       actions: {
51:         ...socketActions,
52:         runLocalBenchmark, // Now provided by the real useWorker hook
53:       },
54:     }),
55:     [snapshot, devices, isConnected, logs, socketActions, runLocalBenchmark],
56:   );
57: 
58:   return (
59:     <SwarmContext.Provider value={value}>{children}</SwarmContext.Provider>
60:   );
61: };
62: 
63: export const useSwarm = () => {
64:   const context = useContext(SwarmContext);
65:   if (!context) throw new Error("useSwarm must be used within a SwarmProvider");
66:   return context;
67: };
</file>

<file path="client/src/core/constants.ts">
1: export const MAX_SAFE_THROTTLE_PERCENT = 75; // Hard cap – never exceed this % of device cores
</file>

<file path="client/src/core/SocketManager.ts">
 1: import { io, Socket } from "socket.io-client";
 2: 
 3: class SocketManager {
 4:   private socket: Socket | null = null;
 5:   private currentToken: string | null = null;
 6: 
 7:   get(persistentId: string, token: string | null = null) {
 8:     const t = token || "";
 9:     // Ensure we don't recreate the socket if identity and token haven't changed
10:     if (this.socket?.connected && this.currentToken === t) {
11:       return this.socket;
12:     }
13: 
14:     // Token mismatch or disconnected: Kill and rebuild
15:     this.socket?.disconnect();
16:     this.currentToken = t;
17: 
18:     const url = window.location.hostname.includes("trycloudflare.com")
19:       ? "/"
20:       : `http://${window.location.hostname}:3000`;
21: 
22:     this.socket = io(url, {
23:       query: { persistentId, token: t },
24:       auth: { token: t },
25:       transports: ["websocket", "polling"],
26:       reconnection: true,
27:       reconnectionDelay: 800,
28:       path: "/socket.io/",
29:     });
30: 
31:     return this.socket;
32:   }
33: 
34:   disconnect() {
35:     this.socket?.disconnect();
36:     this.socket = null;
37:     this.currentToken = null;
38:   }
39: }
40: 
41: export const socketManager = new SocketManager();
</file>

<file path="client/src/core/swarmStore.ts">
 1: import { create } from "zustand";
 2: import { type SwarmSnapshot } from "../core/types";
 3: import { type LogLevel } from "@shared/socket/states";
 4: 
 5: interface SwarmState {
 6:   snapshot: SwarmSnapshot | null;
 7:   logs: string[];
 8:   isConnected: boolean;
 9:   setSnapshot: (s: SwarmSnapshot | null) => void;
10:   setConnected: (c: boolean) => void;
11:   addLog: (level: LogLevel, message: string) => void;
12: }
13: 
14: export const useSwarmStore = create<SwarmState>((set) => ({
15:   snapshot: null,
16:   logs: [],
17:   isConnected: false,
18:   setSnapshot: (s) => set({ snapshot: s }),
19:   setConnected: (c) => set({ isConnected: c }),
20:   addLog: (level, message) =>
21:     set((state) => {
22:       const time = new Date().toLocaleTimeString().split(" ")[0];
23:       const newLog = `[${time}] [${level}] ${message}`;
24:       return { logs: [...state.logs.slice(-49), newLog] };
25:     }),
26: }));
</file>

<file path="client/src/core/theme.css">
 1: @import "tailwindcss";
 2: 
 3: @layer base {
 4:   :root {
 5:     --surface-white: #fcfcfd;
 6:     --surface-muted: #f3f4f6;
 7:     --text-main: #1a1a1e;
 8:     --text-muted: #6b7280;
 9:     --border-soft: rgba(0, 0, 0, 0.05);
10:     /* Light Mode Neumorphism */
11:     --card-shadow: 8px 8px 16px #d1d5db, -8px -8px 16px #ffffff;
12:     --inner-shadow: inset 2px 2px 5px #d1d5db, inset -5px -5px 10px #ffffff;
13:   }
14: 
15:   .dark {
16:     /* ELEVATED CHARCOAL (Allows for highlights) */
17:     --surface-white: #1e1e22; 
18:     --surface-muted: #121214;
19:     
20:     --text-main: #fcfcfd;
21:     --text-muted: #94a3b8;
22:     --border-soft: rgba(255, 255, 255, 0.03);
23:     
24:     /* DARK MODE NEUMORPHISM (The "Pop") */
25:     --card-shadow: 10px 10px 20px #0b0b0d, -5px -5px 15px #2a2a2f;
26:     --inner-shadow: inset 4px 4px 8px #0b0b0d, inset -4px -4px 8px #2a2a2f;
27:     
28:     color-scheme: dark;
29:   }
30: }
31: 
32: @layer components {
33:   .soft-card {
34:     @apply bg-surface-white border border-border-soft rounded-[24px] p-6 transition-all duration-300;
35:     box-shadow: var(--card-shadow);
36:   }
37: 
38:   /* Concave effect for inputs and progress tracks */
39:   .soft-inset {
40:     @apply bg-surface-muted rounded-xl;
41:     box-shadow: var(--inner-shadow);
42:   }
43: }
44: 
45:   /* Fix for the Dashboard navigation and header glass effect */
46:   .backdrop-blur-md {
47:     @apply dark:bg-surface-white/80 dark:border-white/5;
48:   }
49:   
50:   /* Modern Scrollbar */
51:   ::-webkit-scrollbar {
52:     width: 6px;
53:   }
54:   ::-webkit-scrollbar-thumb {
55:     @apply bg-gray-200 rounded-full hover:bg-gray-300;
56:   }
57: }
58: @custom-variant dark (&:where(.dark, .dark *));
59: @keyframes scan {
60:   0% {
61:     top: 10%;
62:   }
63:   50% {
64:     top: 90%;
65:   }
66:   100% {
67:     top: 10%;
68:   }
69: }
70: @keyframes shake {
71:   0%,
72:   100% {
73:     transform: translateX(0);
74:   }
75:   25% {
76:     transform: translateX(-4px);
77:   }
78:   75% {
79:     transform: translateX(4px);
80:   }
81: }
82: .animate-shake {
83:   animation: shake 0.2s ease-in-out 0s 2;
84: }
</file>

<file path="client/src/core/types.ts">
 1: /** * Strict Domain Model for Ostrich Swarm
 2:  */
 3: 
 4: export type SwarmStatus = "IDLE" | "RUNNING" | "PAUSED" | "STOPPED";
 5: export type DeviceType = "DESKTOP" | "MOBILE" | "COLAB" | "SERVER";
 6: export type JobType = "MATH_STRESS" | "MAT_MUL" | "TEXT_TOKENIZE";
 7: 
 8: export interface DeviceCapabilities {
 9:   cpuCores: number;
10:   memoryGB: number;
11:   gpuAvailable: boolean;
12:   gpuName?: string;
13: }
14: 
15: export interface DeviceInfo {
16:   id: string;
17:   name: string;
18:   type: DeviceType;
19:   status: "ONLINE" | "BUSY" | "OFFLINE" | "DISABLED";
20:   capabilities: DeviceCapabilities;
21:   opsScore: number;
22:   totalJobsCompleted: number;
23:   lastHeartbeat: number;
24: }
25: 
26: export interface SwarmResources {
27:   totalCores: number;
28:   totalMemory: number;
29:   totalGPUs: number;
30:   onlineCount: number;
31: }
32: 
33: export interface Job {
34:   id: string;
35:   type: JobType;
36:   complexity: number;
37:   data: any;
38: }
39: 
40: export interface SwarmSnapshot {
41:   runState: SwarmStatus;
42:   devices: Record<string, DeviceInfo>;
43:   stats: {
44:     totalJobs: number;
45:     activeJobs: number;
46:     pendingJobs: number;
47:     completedJobs: number;
48:     globalVelocity: number;
49:     globalThrottle?: number;
50:   };
51:   resources: SwarmResources;
52: }
</file>

<file path="client/src/features/connection/DeviceConnector.tsx">
  1: // client/src/features/connection/DeviceConnector.tsx
  2: import { QRCodeSVG } from "qrcode.react";
  3: import {
  4:   X,
  5:   Copy,
  6:   RefreshCw,
  7:   LogOut,
  8:   ArrowRight,
  9:   Camera,
 10:   Smartphone,
 11: } from "lucide-react";
 12: import { Card } from "../../components/Card";
 13: import { useEffect, useState, useCallback, useRef } from "react";
 14: import { Html5Qrcode } from "html5-qrcode";
 15: 
 16: interface DeviceConnectorProps {
 17:   readonly isOpen: boolean;
 18:   readonly onClose: () => void;
 19:   readonly onRegenerateToken: () => Promise<string>;
 20:   readonly onManualJoin: (code: string) => Promise<void>;
 21:   readonly onLeave: () => void;
 22:   readonly isGuest: boolean;
 23: }
 24: 
 25: export const DeviceConnector = ({
 26:   isOpen,
 27:   onClose,
 28:   onRegenerateToken,
 29:   onManualJoin,
 30:   onLeave,
 31:   isGuest,
 32: }: DeviceConnectorProps) => {
 33:   const [token, setToken] = useState<string>("");
 34:   const [inputCode, setInputCode] = useState<string>("");
 35:   const [isLoading, setIsLoading] = useState(false);
 36:   const [isScanning, setIsScanning] = useState(false);
 37:   const [showSuccess, setShowSuccess] = useState(false);
 38:   const [isError, setIsError] = useState(false);
 39:   const scannerRef = useRef<Html5Qrcode | null>(null);
 40: 
 41:   const handleRegenerate = useCallback(async () => {
 42:     if (isGuest || isLoading) return;
 43:     setIsLoading(true);
 44:     try {
 45:       const newToken = await onRegenerateToken();
 46:       setToken(newToken);
 47:     } catch (err) {
 48:       console.error("[UI] Token Generation Failed", err);
 49:     } finally {
 50:       setIsLoading(false);
 51:     }
 52:   }, [onRegenerateToken, isGuest, isLoading]);
 53: 
 54:   const stopScanner = useCallback(async () => {
 55:     if (scannerRef.current?.isScanning) {
 56:       await scannerRef.current.stop();
 57:     }
 58:     setIsScanning(false);
 59:   }, []);
 60: 
 61:   const startScanner = useCallback(async () => {
 62:     setIsScanning(true);
 63:     setTimeout(async () => {
 64:       const element = document.getElementById("reader");
 65:       if (!element) {
 66:         setIsScanning(false);
 67:         return;
 68:       }
 69:       try {
 70:         const html5QrCode = new Html5Qrcode("reader");
 71:         scannerRef.current = html5QrCode;
 72:         await html5QrCode.start(
 73:           { facingMode: "environment" },
 74:           { fps: 20, qrbox: { width: 220, height: 220 }, aspectRatio: 1.0 },
 75:           async (decodedText) => {
 76:             const code = decodedText.includes("invite=")
 77:               ? decodedText.split("invite=")[1].split("&")[0]
 78:               : decodedText.trim();
 79: 
 80:             await stopScanner();
 81:             handleJoinProtocol(code);
 82:           },
 83:           () => {},
 84:         );
 85:       } catch (err) {
 86:         setIsScanning(false);
 87:       }
 88:     }, 150);
 89:   }, [stopScanner]);
 90: 
 91:   const handleJoinProtocol = async (code: string) => {
 92:     setIsLoading(true);
 93:     setIsError(false);
 94:     try {
 95:       await onManualJoin(code);
 96:       setShowSuccess(true);
 97:       setTimeout(() => {
 98:         onClose();
 99:         setShowSuccess(false);
100:         setInputCode("");
101:       }, 1200);
102:     } catch (err) {
103:       setIsError(true);
104:       setTimeout(() => setIsError(false), 1000);
105:     } finally {
106:       setIsLoading(false);
107:     }
108:   };
109: 
110:   useEffect(() => {
111:     if (isOpen && !isGuest && !token && !isLoading) handleRegenerate();
112:   }, [isOpen, isGuest, token, isLoading, handleRegenerate]);
113: 
114:   useEffect(() => {
115:     const handleEsc = (e: KeyboardEvent) => {
116:       if (e.key === "Escape") onClose();
117:     };
118:     if (isOpen) document.addEventListener("keydown", handleEsc);
119:     return () => document.removeEventListener("keydown", handleEsc);
120:   }, [isOpen, onClose]);
121: 
122:   useEffect(() => {
123:     if (!isOpen && isScanning) stopScanner();
124:   }, [isOpen, isScanning, stopScanner]);
125: 
126:   if (!isOpen) return null;
127: 
128:   return (
129:     <div
130:       className="fixed inset-0 z-50 flex items-center justify-center bg-gray-900/60 backdrop-blur-md p-6"
131:       onClick={onClose}
132:     >
133:       <div className="modal-content" onClick={(e) => e.stopPropagation()}>
134:         <Card
135:           className="max-w-sm w-full relative p-6 space-y-6"
136:           variant="elevated"
137:         >
138:           <button
139:             onClick={onClose}
140:             className="absolute top-4 right-4 p-2 hover:bg-gray-100 rounded-full transition-colors"
141:           >
142:             <X size={18} className="text-text-muted" />
143:           </button>
144:           <div className="text-center space-y-4">
145:             <h3 className="text-xl font-bold">Swarm Access</h3>
146:             {isGuest ? (
147:               <div className="p-4 bg-red-50 border border-red-100 rounded-2xl space-y-3">
148:                 <p className="text-[10px] font-black text-red-500 uppercase">
149:                   Swarm Guest Mode
150:                 </p>
151:                 <button
152:                   onClick={onLeave}
153:                   className="w-full flex items-center justify-center gap-2 bg-red-500 text-white py-3 rounded-xl font-bold text-xs hover:bg-red-600"
154:                 >
155:                   <LogOut size={14} /> Exit Swarm
156:                 </button>
157:               </div>
158:             ) : (
159:               <div className="space-y-6">
160:                 <div className="flex bg-gray-100/80 p-1 rounded-2xl shadow-inner border border-gray-200/50 mx-auto w-fit">
161:                   <button
162:                     onClick={stopScanner}
163:                     className={`flex items-center gap-2 px-4 py-1.5 rounded-xl text-[10px] font-black uppercase tracking-wider transition-all ${!isScanning ? "bg-white text-brand-orange shadow-sm" : "text-text-muted"}`}
164:                   >
165:                     <Smartphone size={12} /> Share
166:                   </button>
167:                   <button
168:                     onClick={startScanner}
169:                     className={`flex items-center gap-2 px-4 py-1.5 rounded-xl text-[10px] font-black uppercase tracking-wider transition-all ${isScanning ? "bg-white text-brand-orange shadow-sm" : "text-text-muted"}`}
170:                   >
171:                     <Camera size={12} /> Scan
172:                   </button>
173:                 </div>
174:                 {!isScanning ? (
175:                   <div className="space-y-4 animate-in fade-in slide-in-from-bottom-2">
176:                     <div className="relative inline-block p-4 bg-white border border-border-soft rounded-3xl shadow-sm">
177:                       {isLoading && (
178:                         <div className="absolute inset-0 z-10 bg-white/80 flex items-center justify-center rounded-3xl">
179:                           <RefreshCw
180:                             size={24}
181:                             className="animate-spin text-brand-orange"
182:                           />
183:                         </div>
184:                       )}
185:                       <QRCodeSVG
186:                         value={token || "OSTRICH_WAITING"}
187:                         size={180}
188:                         level="M"
189:                         includeMargin
190:                       />
191:                     </div>
192:                     <div className="bg-gray-100 p-3 rounded-xl border border-dashed flex items-center justify-between">
193:                       <div className="text-left">
194:                         <p className="text-[9px] font-black text-gray-400 uppercase">
195:                           Join Code
196:                         </p>
197:                         <p className="font-mono font-bold text-brand-orange">
198:                           {token || "GENERATING..."}
199:                         </p>
200:                       </div>
201:                       <div className="flex gap-1">
202:                         <button
203:                           onClick={handleRegenerate}
204:                           className="p-2 hover:bg-white rounded-lg"
205:                         >
206:                           <RefreshCw
207:                             size={16}
208:                             className={isLoading ? "animate-spin" : ""}
209:                           />
210:                         </button>
211:                         <button
212:                           onClick={() =>
213:                             token && navigator.clipboard.writeText(token)
214:                           }
215:                           className="p-2 hover:bg-white rounded-lg"
216:                         >
217:                           <Copy size={16} />
218:                         </button>
219:                       </div>
220:                     </div>
221:                   </div>
222:                 ) : (
223:                   <div className="animate-in fade-in zoom-in-95">
224:                     <div className="relative w-full aspect-square max-w-60 mx-auto bg-black rounded-[40px] border-8 border-surface-white overflow-hidden shadow-inner">
225:                       <div
226:                         id="reader"
227:                         className="w-full h-full [&_video]:object-cover [&_video]:rounded-[32px]"
228:                       />
229:                       <div className="absolute inset-0 border-2 border-brand-orange/30 rounded-[32px] pointer-events-none">
230:                         <div className="absolute top-0 left-0 w-full h-2 bg-brand-orange/50 shadow-[0_0_15px_rgba(255,125,84,0.8)] animate-[scan_2s_linear_infinite]" />
231:                       </div>
232:                     </div>
233:                   </div>
234:                 )}
235:               </div>
236:             )}
237:           </div>
238:           <div className="border-t pt-6 space-y-3">
239:             <div className="flex gap-2">
240:               <input
241:                 type="text"
242:                 maxLength={6}
243:                 value={inputCode}
244:                 onChange={(e) => {
245:                   setIsError(false);
246:                   setInputCode(e.target.value.toUpperCase());
247:                 }}
248:                 placeholder="ENTER CODE"
249:                 className={`flex-1 bg-gray-100 border rounded-xl px-4 py-3 font-mono font-bold text-sm focus:outline-brand-orange transition-all ${isError ? "border-red-500 animate-shake" : "border-border-soft"}`}
250:               />
251:               <button
252:                 onClick={() => handleJoinProtocol(inputCode)}
253:                 disabled={inputCode.length < 4 || isLoading || showSuccess}
254:                 className={`p-3 rounded-xl transition-all duration-200 ${showSuccess ? "bg-green-500" : isError ? "bg-red-500" : "bg-gray-900"} text-white`}
255:               >
256:                 {isLoading ? (
257:                   <RefreshCw size={20} className="animate-spin" />
258:                 ) : (
259:                   <ArrowRight size={20} />
260:                 )}
261:               </button>
262:             </div>
263:           </div>
264:         </Card>
265:       </div>
266:     </div>
267:   );
268: };
</file>

<file path="client/src/features/dashboard/ActiveSwarm.tsx">
  1: import { Smartphone, Laptop, Server, Cpu, Play } from "lucide-react";
  2: import { Card } from "../../components/Card";
  3: import { type DeviceInfo } from "../../core/types";
  4: 
  5: interface ActiveSwarmProps {
  6:   devices: DeviceInfo[];
  7:   onBenchmark: () => void;
  8:   onToggle: (id: string, state: boolean) => void;
  9: }
 10: 
 11: export const ActiveSwarm = ({
 12:   devices,
 13:   onBenchmark,
 14:   onToggle,
 15: }: ActiveSwarmProps) => {
 16:   const getIcon = (type: string) => {
 17:     switch (type) {
 18:       case "MOBILE":
 19:         return <Smartphone size={18} />;
 20:       case "SERVER":
 21:         return <Server size={18} />;
 22:       case "COLAB":
 23:         return <Cpu size={18} />;
 24:       default:
 25:         return <Laptop size={18} />;
 26:     }
 27:   };
 28: 
 29:   return (
 30:     <Card className="flex flex-col h-full bg-surface-white relative overflow-hidden p-4 sm:p-6">
 31:       <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 gap-4">
 32:         <div>
 33:           <h3 className="font-bold text-lg text-text-main">Swarm Nodes</h3>
 34:           <p className="text-xs text-text-muted">Manage active resources</p>
 35:         </div>
 36:         <button
 37:           onClick={onBenchmark}
 38:           className="w-full sm:w-auto flex items-center justify-center gap-2 bg-gray-900 hover:bg-black text-white px-4 py-2.5 rounded-xl text-xs font-bold transition-all active:scale-95 shadow-lg shadow-gray-900/20"
 39:         >
 40:           <Play size={12} fill="currentColor" />
 41:           Benchmark All
 42:         </button>
 43:       </div>
 44: 
 45:       <div className="flex-1 overflow-y-auto space-y-3 pr-1 custom-scrollbar">
 46:         {devices.map((device) => {
 47:           const isDisabled = device.status === "DISABLED";
 48:           const isLocal =
 49:             device.id.includes("node-") || device.name === "Local Host";
 50: 
 51:           return (
 52:             <div
 53:               key={device.id}
 54:               className={`flex flex-col md:flex-row md:items-center justify-between p-4 rounded-2xl border transition-all duration-300 gap-4 ${
 55:                 isDisabled
 56:                   ? "bg-gray-50 border-transparent opacity-60"
 57:                   : "bg-white border-gray-100 hover:border-brand-orange/30 shadow-sm"
 58:               }`}
 59:             >
 60:               {/* Left Section: Identity */}
 61:               <div className="flex items-center gap-3">
 62:                 <div
 63:                   className={`p-3 rounded-xl shrink-0 ${
 64:                     isDisabled
 65:                       ? "bg-gray-200 text-gray-400"
 66:                       : "bg-surface-muted text-brand-orange"
 67:                   }`}
 68:                 >
 69:                   {getIcon(device.type)}
 70:                 </div>
 71:                 <div className="min-w-0">
 72:                   <div className="flex items-center gap-2 flex-wrap">
 73:                     <h4 className="text-sm font-bold text-text-main truncate">
 74:                       {device.name}
 75:                     </h4>
 76:                     {isLocal && (
 77:                       <span className="text-[9px] bg-brand-orange/10 text-brand-orange px-1.5 py-0.5 rounded font-bold border border-brand-orange/20 uppercase tracking-tighter">
 78:                         YOU
 79:                       </span>
 80:                     )}
 81:                   </div>
 82:                   <div className="flex items-center gap-2 mt-0.5">
 83:                     <span
 84:                       className={`w-1.5 h-1.5 rounded-full shrink-0 ${
 85:                         isDisabled
 86:                           ? "bg-gray-400"
 87:                           : device.status === "ONLINE"
 88:                             ? "bg-green-500"
 89:                             : "bg-amber-500"
 90:                       }`}
 91:                     />
 92:                     <span className="text-[10px] font-bold text-text-muted uppercase truncate">
 93:                       {device.status === "ONLINE"
 94:                         ? `${device.capabilities.cpuCores} Cores Online`
 95:                         : device.status}
 96:                     </span>
 97:                   </div>
 98:                 </div>
 99:               </div>
100: 
101:               {/* Right Section: Stats & Toggle */}
102:               <div className="flex items-center justify-between md:justify-end gap-4 md:gap-8 border-t md:border-t-0 pt-3 md:pt-0">
103:                 <div className="flex gap-6">
104:                   {/* Job Counter */}
105:                   <div className="text-left md:text-right min-w-15">
106:                     <div className="font-mono text-sm font-black text-text-main">
107:                       {device.totalJobsCompleted || 0}
108:                     </div>
109:                     <div className="text-[9px] font-bold text-text-muted uppercase tracking-tighter">
110:                       Jobs
111:                     </div>
112:                   </div>
113: 
114:                   {/* OPS Score */}
115:                   <div className="text-left md:text-right min-w-17.5">
116:                     <div className="font-mono text-sm font-black text-brand-orange">
117:                       {device.opsScore > 0
118:                         ? device.opsScore.toLocaleString()
119:                         : "---"}
120:                     </div>
121:                     <div className="text-[9px] font-bold text-text-muted uppercase tracking-tighter">
122:                       OPS Score
123:                     </div>
124:                   </div>
125:                 </div>
126: 
127:                 <button
128:                   onClick={() => onToggle(device.id, isDisabled)}
129:                   className={`w-11 h-6 rounded-full p-1 transition-colors relative shrink-0 ${
130:                     !isDisabled ? "bg-green-500" : "bg-gray-300"
131:                   }`}
132:                 >
133:                   <div
134:                     className={`w-4 h-4 rounded-full bg-white shadow-sm transition-transform duration-200 ${
135:                       !isDisabled ? "translate-x-5" : "translate-x-0"
136:                     }`}
137:                   />
138:                 </button>
139:               </div>
140:             </div>
141:           );
142:         })}
143: 
144:         {devices.length === 0 && (
145:           <div className="text-center py-10">
146:             <p className="text-sm text-text-muted italic">
147:               Waiting for swarm nodes...
148:             </p>
149:           </div>
150:         )}
151:       </div>
152:     </Card>
153:   );
154: };
</file>

<file path="client/src/features/dashboard/JobGauge.tsx">
 1: import { Card } from "../../components/Card";
 2: 
 3: interface Props {
 4:   readonly total: number;
 5:   readonly completed: number;
 6: }
 7: 
 8: export const JobGauge = ({ total, completed }: Props) => {
 9:   const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
10:   const radius = 45;
11:   const circumference = 2 * Math.PI * radius;
12:   const strokeDashoffset = circumference - (percentage / 100) * circumference;
13: 
14:   return (
15:     <Card className="flex flex-col items-center justify-center p-6 bg-surface-white">
16:       <div className="relative w-40 h-40 mb-4">
17:         {/* Rotated SVG container to start from 12 o'clock */}
18:         <svg className="w-full h-full -rotate-90" viewBox="0 0 128 128">
19:           {/* Background Track */}
20:           {/* JobGauge.tsx line 24 */}
21:           <circle
22:             cx="64"
23:             cy="64"
24:             r={radius}
25:             stroke="var(--color-surface-muted)" // Dynamic color
26:             strokeWidth="12"
27:             fill="transparent"
28:             strokeLinecap="round"
29:           />
30:           {/* Active Progress */}
31:           <circle
32:             cx="64"
33:             cy="64"
34:             r={radius}
35:             stroke="#ff7d54"
36:             strokeWidth="12"
37:             fill="transparent"
38:             strokeDasharray={circumference}
39:             strokeDashoffset={strokeDashoffset}
40:             strokeLinecap="round"
41:             className="transition-all duration-1000 ease-out"
42:           />
43:         </svg>
44: 
45:         {/* Center Text (Counter-rotated to stay upright) */}
46:         <div className="absolute inset-0 flex flex-col items-center justify-center">
47:           <span className="text-3xl font-black text-text-main">{total}</span>
48:           <span className="text-[10px] font-bold text-text-muted uppercase tracking-widest">
49:             Total Jobs
50:           </span>
51:         </div>
52:       </div>
53: 
54:       <div className="w-full space-y-2 px-2">
55:         <div className="flex justify-between text-[10px] font-bold text-text-muted uppercase">
56:           <span>Progress</span>
57:           <span>{percentage}%</span>
58:         </div>
59:         <div className="w-full h-2 bg-gray-100 rounded-full overflow-hidden shadow-inner">
60:           <div
61:             className="h-full bg-brand-orange transition-all duration-500"
62:             style={{ width: `${percentage}%` }}
63:           />
64:         </div>
65:       </div>
66:     </Card>
67:   );
68: };
</file>

<file path="client/src/features/dashboard/ResourceStats.tsx">
 1: import { Database, Zap, Activity } from "lucide-react";
 2: import { Card } from "../../components/Card";
 3: import { type SwarmStats } from "../../core/types";
 4: 
 5: interface Props {
 6:   stats: SwarmStats;
 7:   onlineCount: number;
 8: }
 9: 
10: export const ResourceStats = ({ stats, onlineCount }: Props) => {
11:   return (
12:     <div className="grid grid-cols-1 md:grid-cols-3 gap-5">
13:       <StatItem
14:         label="Online Nodes"
15:         value={onlineCount}
16:         icon={<Database size={18} className="text-blue-600" />}
17:         gradient="from-blue-50 to-blue-100/50"
18:         border="border-blue-100"
19:       />
20:       <StatItem
21:         label="Active Jobs"
22:         value={stats.activeJobs}
23:         icon={<Activity size={18} className="text-brand-orange" />}
24:         gradient="from-orange-50 to-orange-100/50"
25:         border="border-orange-100"
26:       />
27:       <StatItem
28:         label="Pending"
29:         value={stats.pendingJobs}
30:         icon={<Zap size={18} className="text-purple-600" />}
31:         gradient="from-purple-50 to-purple-100/50"
32:         border="border-purple-100"
33:       />
34:     </div>
35:   );
36: };
37: 
38: const StatItem = ({ label, value, icon, gradient, border }: any) => (
39:   <Card
40:     className={`p-5 bg-linear-to-br ${gradient} border ${border} hover:-translate-y-1 transition-transform duration-300 shadow-sm`}
41:   >
42:     <div className="flex justify-between items-start">
43:       <div>
44:         <p className="text-[10px] font-black text-text-muted uppercase tracking-widest mb-2">
45:           {label}
46:         </p>
47:         <p className="text-3xl font-black text-text-main tracking-tight">
48:           {value.toLocaleString()}
49:         </p>
50:       </div>
51:       <div className="p-3 bg-white rounded-xl shadow-sm border border-white/50">
52:         {icon}
53:       </div>
54:     </div>
55:   </Card>
56: );
</file>

<file path="client/src/features/dashboard/SwarmControls.tsx">
  1: import { Play, Pause, Square } from "lucide-react";
  2: import { Card } from "../../components/Card";
  3: 
  4: interface SwarmControlsProps {
  5:   readonly status: "IDLE" | "RUNNING" | "PAUSED" | "STOPPED";
  6:   readonly onToggle: () => void;
  7:   readonly onStop: () => void;
  8: }
  9: 
 10: export const SwarmControls = ({
 11:   status,
 12:   onToggle,
 13:   onStop,
 14: }: SwarmControlsProps) => {
 15:   const isRunning = status === "RUNNING";
 16: 
 17:   return (
 18:     <Card className="p-5 bg-surface-white">
 19:       <h3 className="font-bold text-sm text-text-muted uppercase tracking-widest mb-4">
 20:         Master Control
 21:       </h3>
 22: 
 23:       <div className="grid grid-cols-2 gap-4">
 24:         {/* Start/Pause: Orange by default, Emerald on Hover */}
 25:         <button
 26:           onClick={() => {
 27:             console.log("CLICKED TOGGLE");
 28:             onToggle();
 29:           }}
 30:           className={`
 31:             h-20 rounded-2xl flex flex-col items-center justify-center gap-2 transition-all duration-200 active:scale-[0.95]
 32:             border group
 33:             ${
 34:               isRunning
 35:                 ? "bg-brand-orange/5 border-brand-orange/20 shadow-inner"
 36:                 : "bg-surface-white shadow-[6px_6px_12px_#d1d5db,-6px_-6px_12px_#ffffff] border-white hover:bg-emerald-50 hover:border-emerald-100"
 37:             }
 38:           `}
 39:         >
 40:           <div
 41:             className={`p-2 rounded-full transition-colors ${
 42:               isRunning
 43:                 ? "bg-brand-orange text-white shadow-[0_0_10px_rgba(255,125,84,0.4)]"
 44:                 : "text-text-muted bg-gray-100 group-hover:bg-emerald-100 group-hover:text-emerald-600"
 45:             }`}
 46:           >
 47:             {isRunning ? (
 48:               <Pause size={24} fill="currentColor" />
 49:             ) : (
 50:               <Play size={24} fill="currentColor" className="ml-0.5" />
 51:             )}
 52:           </div>
 53:           <span
 54:             className={`text-[10px] font-black uppercase transition-colors ${
 55:               isRunning
 56:                 ? "text-brand-orange"
 57:                 : "text-text-muted group-hover:text-emerald-600"
 58:             }`}
 59:           >
 60:             {isRunning ? "Pause Swarm" : "Start Swarm"}
 61:           </span>
 62:         </button>
 63: 
 64:         {/* Kill Process: Gray by default, Red on Hover */}
 65:         <button
 66:           onClick={() => {
 67:             if (
 68:               window.confirm(
 69:                 "KILL PROCESS? This will terminate all active local threads.",
 70:               )
 71:             ) {
 72:               onStop();
 73:             }
 74:           }}
 75:           className={`
 76:             h-20 rounded-2xl flex flex-col items-center justify-center gap-2 transition-all duration-200 active:scale-[0.98]
 77:             border group
 78:             ${
 79:               status === "STOPPED"
 80:                 ? "bg-red-50 border-red-200 shadow-inner"
 81:                 : "bg-surface-white shadow-[6px_6px_12px_#d1d5db,-6px_-6px_12px_#ffffff] border-white hover:bg-red-50 hover:border-red-100"
 82:             }
 83:           `}
 84:         >
 85:           <div
 86:             className={`p-2 rounded-full transition-colors ${
 87:               status === "STOPPED"
 88:                 ? "bg-red-500 text-white"
 89:                 : "text-text-muted bg-gray-100 group-hover:bg-red-100 group-hover:text-red-500"
 90:             }`}
 91:           >
 92:             <Square size={24} fill="currentColor" />
 93:           </div>
 94:           <span
 95:             className={`text-[10px] font-black uppercase transition-colors ${
 96:               status === "STOPPED"
 97:                 ? "text-red-600"
 98:                 : "text-text-muted group-hover:text-red-600"
 99:             }`}
100:           >
101:             {status === "STOPPED" ? "System Killed" : "Kill Process"}
102:           </span>
103:         </button>
104:       </div>
105: 
106:       {/* Status LED Panel */}
107:       <div className="mt-6 flex items-center justify-between soft-inset p-3 border border-black/5 dark:border-white/5">
108:         <span className="text-xs font-bold text-text-muted">System State</span>
109:         <div className="flex items-center gap-2">
110:           <div
111:             className={`w-2 h-2 rounded-full ${
112:               isRunning
113:                 ? "bg-brand-orange shadow-[0_0_8px_rgba(255,125,84,0.8)]"
114:                 : "bg-red-500"
115:             }`}
116:           />
117:           <span className="font-mono text-xs font-bold text-text-main">
118:             {status}
119:           </span>
120:         </div>
121:       </div>
122:     </Card>
123:   );
124: };
</file>

<file path="client/src/features/dashboard/ThrottleControl.tsx">
 1: import { Card } from "../../components/Card";
 2: import { Cpu, Server, Box } from "lucide-react";
 3: import { MAX_SAFE_THROTTLE_PERCENT } from "../../core/constants";
 4: 
 5: interface Props {
 6:   value: number;
 7:   onChange: (val: number) => void;
 8:   totalCores: number;
 9:   totalMemory: number;
10:   totalGPUs: number;
11: }
12: 
13: export const ThrottleControl = ({
14:   value,
15:   onChange,
16:   totalCores = 0,
17:   totalMemory = 0,
18:   totalGPUs = 0,
19: }: Props) => {
20:   const safeValue = Math.min(value, MAX_SAFE_THROTTLE_PERCENT);
21:   const percent = safeValue / 100;
22: 
23:   const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
24:     const newVal = parseInt(e.target.value);
25:     onChange(Math.min(newVal, MAX_SAFE_THROTTLE_PERCENT)); // hard clamp
26:   };
27: 
28:   return (
29:     <Card className="relative overflow-hidden group p-5 bg-surface-white">
30:       <div className="flex justify-between items-center mb-6">
31:         <div>
32:           <h3 className="font-bold text-sm text-text-muted uppercase tracking-widest">
33:             Global Allocation
34:           </h3>
35:           <p className="text-2xl font-black text-text-main">{safeValue}%</p>
36:         </div>
37: 
38:         <div className="flex flex-wrap gap-2 justify-end max-w-45">
39:           <div className="flex items-center gap-1.5 bg-gray-50 px-2 py-1 rounded-lg border border-gray-100">
40:             <Cpu size={12} className="text-brand-orange" />
41:             <span className="text-[10px] font-bold text-gray-600">
42:               {Math.round(totalCores * percent)} / {totalCores}
43:             </span>
44:           </div>
45:           <div className="flex items-center gap-1.5 bg-gray-50 px-2 py-1 rounded-lg border border-gray-100">
46:             <Server size={12} className="text-blue-500" />
47:             <span className="text-[10px] font-bold text-gray-600">
48:               {Math.round(totalMemory * percent)} GB
49:             </span>
50:           </div>
51:           <div
52:             className={`flex items-center gap-1.5 px-2 py-1 rounded-lg border ${totalGPUs > 0 ? "bg-purple-50 border-purple-100" : "bg-gray-50 border-gray-100 opacity-50"}`}
53:           >
54:             <Box
55:               size={12}
56:               className={totalGPUs > 0 ? "text-purple-600" : "text-gray-400"}
57:             />
58:             <span
59:               className={`text-[10px] font-bold ${totalGPUs > 0 ? "text-purple-700" : "text-gray-400"}`}
60:             >
61:               {totalGPUs} GPU{totalGPUs !== 1 ? "s" : ""}
62:             </span>
63:           </div>
64:         </div>
65:       </div>
66: 
67:       <input
68:         type="range"
69:         min="10"
70:         max="100"
71:         step="5"
72:         value={safeValue}
73:         onChange={handleChange}
74:         className="w-full h-2 bg-gray-100 rounded-lg appearance-none cursor-pointer accent-brand-orange transition-all hover:bg-gray-200"
75:       />
76: 
77:       <div className="flex justify-between mt-3 text-[10px] font-bold text-text-muted uppercase tracking-tighter">
78:         <span>Eco Mode</span>
79:         <span>Balanced</span>
80:         <span>Max Performance</span>
81:       </div>
82: 
83:       <div className="text-[9px] text-amber-600 mt-2 text-center font-medium">
84:         Hard safety cap: {MAX_SAFE_THROTTLE_PERCENT}% (prevents device freeze)
85:       </div>
86:     </Card>
87:   );
88: };
</file>

<file path="client/src/features/dashboard/VelocityMonitor.tsx">
  1: import { useEffect, useRef } from "react";
  2: import { Card } from "../../components/Card";
  3: import { Activity } from "lucide-react";
  4: 
  5: interface VelocityMonitorProps {
  6:   readonly velocity: number;
  7:   readonly throttle: number;
  8: }
  9: 
 10: export const VelocityMonitor = ({
 11:   velocity,
 12:   throttle,
 13: }: VelocityMonitorProps) => {
 14:   const canvasRef = useRef<HTMLCanvasElement>(null);
 15:   const dataRef = useRef<number[]>(new Array(60).fill(0));
 16:   const requestRef = useRef<number>(0);
 17: 
 18:   // 1. OPTIMIZATION: Frame Rate Throttling
 19:   const getColor = (val: number) => {
 20:     if (val < 30) return "#22c55e";
 21:     if (val < 70) return "#ff7d54";
 22:     return "#ef4444";
 23:   };
 24:   const lastFrameTime = useRef<number>(0);
 25:   const FRAME_INTERVAL = 1000 / 30; // 30 FPS target
 26: 
 27:   useEffect(() => {
 28:     const canvas = canvasRef.current;
 29:     if (!canvas) return;
 30: 
 31:     const ctx = canvas.getContext("2d", { alpha: false });
 32:     if (!ctx) return;
 33: 
 34:     const dpr = window.devicePixelRatio || 1;
 35:     const rect = canvas.getBoundingClientRect();
 36:     canvas.width = rect.width * dpr;
 37:     canvas.height = rect.height * dpr;
 38:     ctx.scale(dpr, dpr);
 39: 
 40:     // 2. UPDATED ANIMATION LOOP
 41:     const animate = (timestamp: number) => {
 42:       // Check if enough time has passed to render the next frame
 43:       if (timestamp - lastFrameTime.current < FRAME_INTERVAL) {
 44:         requestRef.current = requestAnimationFrame(animate);
 45:         return;
 46:       }
 47:       lastFrameTime.current = timestamp;
 48: 
 49:       // Update Data
 50:       dataRef.current.shift();
 51:       dataRef.current.push(velocity);
 52: 
 53:       const isDark = document.documentElement.classList.contains("dark");
 54:       ctx.fillStyle = isDark ? "#1e1e22" : "#fcfcfd"; // Match --surface-white
 55:       ctx.fillRect(0, 0, rect.width, rect.height);
 56: 
 57:       const activeColor = getColor(throttle);
 58:       const step = rect.width / (dataRef.current.length - 1);
 59:       const dynamicMax = Math.max(Math.max(...dataRef.current) * 1.2, 100);
 60: 
 61:       // Draw Gradient Path
 62:       ctx.beginPath();
 63:       ctx.moveTo(0, rect.height);
 64:       dataRef.current.forEach((val, i) => {
 65:         const x = i * step;
 66:         const normalized = Math.min(val / dynamicMax, 1);
 67:         const y = rect.height - normalized * rect.height * 0.7 - 20;
 68:         ctx.lineTo(x, y);
 69:       });
 70:       ctx.lineTo(rect.width, rect.height);
 71:       const gradient = ctx.createLinearGradient(0, 0, 0, rect.height);
 72:       gradient.addColorStop(0, `${activeColor}33`);
 73:       gradient.addColorStop(1, `${activeColor}00`);
 74:       ctx.fillStyle = gradient;
 75:       ctx.fill();
 76: 
 77:       // Draw Stroke
 78:       ctx.beginPath();
 79:       ctx.lineWidth = 2;
 80:       ctx.lineJoin = "round";
 81:       ctx.strokeStyle = activeColor;
 82:       dataRef.current.forEach((val, i) => {
 83:         const x = i * step;
 84:         const normalized = Math.min(val / dynamicMax, 1);
 85:         const y = rect.height - normalized * rect.height * 0.7 - 20;
 86:         if (i === 0) ctx.moveTo(x, y);
 87:         else ctx.lineTo(x, y);
 88:       });
 89:       ctx.stroke();
 90: 
 91:       requestRef.current = requestAnimationFrame(animate);
 92:     };
 93: 
 94:     requestRef.current = requestAnimationFrame(animate);
 95: 
 96:     return () => {
 97:       cancelAnimationFrame(requestRef.current);
 98:     };
 99:   }, [velocity, throttle]);
100: 
101:   useEffect(() => {
102:     const canvas = canvasRef.current;
103:     if (!canvas) return;
104: 
105:     const ctx = canvas.getContext("2d", { alpha: false });
106:     if (!ctx) return;
107: 
108:     const resizeCanvas = () => {
109:       const rect = canvas.getBoundingClientRect();
110:       const dpr = window.devicePixelRatio || 1;
111:       canvas.width = rect.width * dpr;
112:       canvas.height = rect.height * dpr;
113:       ctx.scale(dpr, dpr);
114:     };
115: 
116:     resizeCanvas();
117: 
118:     const resizeObserver = new ResizeObserver(resizeCanvas);
119:     resizeObserver.observe(canvas.parentElement!);
120: 
121:     return () => resizeObserver.disconnect();
122:   }, []);
123: 
124:   return (
125:     <Card className="h-80 flex flex-col relative overflow-hidden bg-surface-white border border-border-soft shadow-soft-depth">
126:       <div className="flex justify-between items-center mb-4 z-10 px-5 pt-5">
127:         <div>
128:           <h3 className="font-bold text-lg text-text-main flex items-center gap-2">
129:             <Activity
130:               className={throttle > 70 ? "text-red-500" : "text-brand-orange"}
131:               size={20}
132:             />
133:             Live Compute Velocity
134:           </h3>
135:           <p className="text-xs text-text-muted mt-1">
136:             Real-time operations per second
137:           </p>
138:         </div>
139:         <div className="bg-surface-muted/50 px-4 py-2 rounded-xl border border-white/50 shadow-inner backdrop-blur-sm">
140:           <span
141:             className="text-3xl font-black tabular-nums tracking-tight"
142:             style={{ color: getColor(throttle) }}
143:           >
144:             {velocity.toLocaleString()}
145:           </span>
146:           <span className="text-[10px] font-bold text-text-muted ml-1 uppercase">
147:             OPS/s
148:           </span>
149:         </div>
150:       </div>
151:       <div className="flex-1 w-full min-h-0 relative px-5 pb-5">
152:         <canvas
153:           ref={canvasRef}
154:           className="w-full h-full rounded-xl border border-black/5 shadow-inner"
155:         />
156:       </div>
157:     </Card>
158:   );
159: };
</file>

<file path="client/src/features/terminal/LiveTerminal.tsx">
 1: import { useEffect, useRef, memo } from "react";
 2: import { Terminal, Activity } from "lucide-react";
 3: import { Card } from "../../components/Card";
 4: 
 5: interface Props {
 6:   logs: string[];
 7: }
 8: 
 9: const LogLine = memo(({ log, index }: { log: string; index: number }) => {
10:   const isErr = log.includes("[ERR]");
11:   const isSys = log.includes("[SYS]");
12:   const isNet = log.includes("[NET]");
13: 
14:   return (
15:     <div className="flex gap-3 leading-relaxed border-b border-gray-100/30 pb-1 last:border-0">
16:       <span className="text-gray-400 select-none font-bold w-8">
17:         {(index + 1).toString().padStart(3, "0")}
18:       </span>
19:       <span
20:         className={`font-medium ${isErr ? "text-red-500" : isSys ? "text-blue-600" : isNet ? "text-green-600" : "text-gray-600"}`}
21:       >
22:         {log}
23:       </span>
24:     </div>
25:   );
26: });
27: 
28: LogLine.displayName = "LogLine";
29: 
30: export const LiveTerminal = ({ logs }: Props) => {
31:   const scrollRef = useRef<HTMLDivElement>(null);
32: 
33:   useEffect(() => {
34:     if (scrollRef.current) {
35:       scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
36:     }
37:   }, [logs]);
38: 
39:   return (
40:     <Card className="h-full flex flex-col relative overflow-hidden bg-surface-white border border-border-soft shadow-soft-depth">
41:       <div className="flex items-center justify-between px-5 py-3 bg-[#e9ecef] border-b border-white rounded-t-xl shadow-sm z-10">
42:         <div className="flex items-center gap-2.5">
43:           <Terminal size={12} className="text-text-main" />
44:           <span className="text-[10px] font-black text-text-main/80 tracking-widest uppercase">
45:             System Log
46:           </span>
47:         </div>
48:         <div className="flex bg-surface-white px-3 py-1 rounded-lg border border-white/50 shadow-inner">
49:           <Activity
50:             size={10}
51:             className="text-brand-orange animate-pulse mr-2"
52:           />
53:           <span className="text-[9px] font-bold text-brand-orange uppercase">
54:             Realtime
55:           </span>
56:         </div>
57:       </div>
58: 
59:       <div
60:         ref={scrollRef}
61:         className="flex-1 p-5 font-mono text-[11px] overflow-y-auto space-y-1 bg-surface-muted/30"
62:       >
63:         {logs.length === 0 && (
64:           <span className="text-gray-400 italic">
65:             Listening for swarm events...
66:           </span>
67:         )}
68:         {logs.map((log, i) => (
69:           <LogLine key={i} log={log} index={i} />
70:         ))}
71:       </div>
72:     </Card>
73:   );
74: };
</file>

<file path="client/src/hooks/useMediaQuery.ts">
 1: import { useState, useEffect } from "react";
 2: 
 3: export function useMediaQuery(query: string): boolean {
 4:   const [matches, setMatches] = useState(
 5:     () => window.matchMedia(query).matches,
 6:   );
 7: 
 8:   useEffect(() => {
 9:     const media = window.matchMedia(query);
10:     const listener = () => setMatches(media.matches);
11:     media.addEventListener("change", listener);
12:     return () => media.removeEventListener("change", listener);
13:   }, [query]);
14: 
15:   return matches;
16: }
</file>

<file path="client/src/hooks/usePersistentIdentity.ts">
 1: import { useState, useEffect, useCallback } from "react";
 2: 
 3: const SWARM_TOKEN_KEY = "ostrich_swarm_token";
 4: 
 5: export const usePersistentIdentity = () => {
 6:   const [identity, setIdentity] = useState({ id: "", name: "" });
 7:   const [swarmToken, setSwarmToken] = useState<string | null>(null);
 8: 
 9:   useEffect(() => {
10:     // 1. Identity Logic (Existing)
11:     let storedId = localStorage.getItem("ostrich_device_id");
12:     let storedName = localStorage.getItem("ostrich_device_name");
13: 
14:     if (!storedId || storedId === "undefined") {
15:       const newId = `node-${Math.random().toString(36).substring(2, 11)}`;
16:       localStorage.setItem("ostrich_device_id", newId);
17:       storedId = newId;
18:     }
19: 
20:     if (!storedName) {
21:       const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
22:       storedName = isMobile ? "Mobile Node" : "Desktop Node";
23:       localStorage.setItem("ostrich_device_name", storedName);
24:     }
25:     setIdentity({ id: storedId, name: storedName });
26: 
27:     // 2. Swarm Persistence Logic (New)
28:     const storedToken = sessionStorage.getItem(SWARM_TOKEN_KEY);
29:     const urlToken = new URLSearchParams(window.location.search).get("invite");
30: 
31:     if (urlToken) {
32:       // New join via URL link
33:       sessionStorage.setItem(SWARM_TOKEN_KEY, urlToken);
34:       setSwarmToken(urlToken);
35:     } else if (storedToken) {
36:       // RELOAD PROTECTION: Restore state first, then update URL for consistency
37:       setSwarmToken(storedToken);
38:       const url = new URL(window.location.href);
39:       url.searchParams.set("invite", storedToken);
40:       window.history.replaceState({}, "", url.toString());
41:     } else {
42:       setSwarmToken(null);
43:     }
44:   }, []);
45:   // NEW: Function to lock in a token from ANY source (QR/Manual/Link)
46:   const saveSwarmToken = useCallback((token: string) => {
47:     sessionStorage.setItem(SWARM_TOKEN_KEY, token);
48:     setSwarmToken(token);
49: 
50:     // Update URL so a browser refresh behaves like a link-join
51:     const url = new URL(window.location.href);
52:     url.searchParams.set("invite", token);
53:     window.history.replaceState({}, "", url.toString());
54:   }, []);
55: 
56:   const clearSwarmToken = useCallback(() => {
57:     sessionStorage.removeItem(SWARM_TOKEN_KEY);
58:     setSwarmToken(null);
59:     const url = new URL(window.location.href);
60:     url.searchParams.delete("invite");
61:     window.history.replaceState({}, "", url.toString());
62:   }, []);
63: 
64:   return { identity, swarmToken, clearSwarmToken, saveSwarmToken }; // Added isHydrated
65: };
</file>

<file path="client/src/hooks/useSocket.ts">
  1: // client/src/hooks/useSocket.ts
  2: import { useCallback, useEffect } from "react";
  3: import { socketManager } from "../core/SocketManager";
  4: import { SocketEvents } from "@shared/socket/events";
  5: import { useSwarmStore } from "../core/swarmStore";
  6: import { usePersistentIdentity } from "./usePersistentIdentity";
  7: import { type SwarmStatus, type Job } from "../core/types";
  8: 
  9: export const useSocket = (onJobReceived?: (job: Job) => void) => {
 10:   const { identity, swarmToken, saveSwarmToken, clearSwarmToken } =
 11:     usePersistentIdentity();
 12:   const { setSnapshot, setConnected, addLog, snapshot } = useSwarmStore();
 13: 
 14:   const getSocket = useCallback(() => {
 15:     return socketManager.get(identity.id, swarmToken);
 16:   }, [identity.id, swarmToken]);
 17: 
 18:   useEffect(() => {
 19:     if (!identity.id || identity.id === "loading-identity") return;
 20: 
 21:     const socket = getSocket();
 22: 
 23:     socket.on(SocketEvents.CONNECT, () => {
 24:       setConnected(true);
 25:       addLog("NET", "Swarm Link Established");
 26:       socket.emit(SocketEvents.DEVICE_REGISTER, {
 27:         name: localStorage.getItem("ostrich_device_name") || "Local Node",
 28:         capabilities: {
 29:           cpuCores: navigator.hardwareConcurrency || 4,
 30:           memoryGB: (navigator as any).deviceMemory || 8,
 31:           gpuAvailable: !!(navigator as any).gpu,
 32:         },
 33:       });
 34:       // Immediately request work if the swarm is already running
 35:       socket.emit(SocketEvents.JOB_REQUEST_BATCH);
 36:     });
 37: 
 38:     socket.on("disconnect", () => setConnected(false));
 39: 
 40:     socket.on(SocketEvents.SWARM_SNAPSHOT, (data) => {
 41:       const previousState = snapshot?.runState;
 42:       setSnapshot(data);
 43:       // If state just changed to RUNNING, kickstart the pipeline
 44:       if (previousState !== "RUNNING" && data.runState === "RUNNING") {
 45:         socket.emit(SocketEvents.JOB_REQUEST_BATCH);
 46:       }
 47:     });
 48: 
 49:     socket.on(SocketEvents.JOB_BATCH_DISPATCH, (jobs: Job[]) => {
 50:       if (onJobReceived) {
 51:         jobs.forEach((job) => onJobReceived(job));
 52:       }
 53:     });
 54: 
 55:     socket.on(SocketEvents.SYSTEM_LOG, (p) => addLog(p.level, p.message));
 56: 
 57:     return () => {
 58:       socket.off(SocketEvents.CONNECT);
 59:       socket.off("disconnect");
 60:       socket.off(SocketEvents.SWARM_SNAPSHOT);
 61:       socket.off(SocketEvents.JOB_BATCH_DISPATCH);
 62:       socket.off(SocketEvents.SYSTEM_LOG);
 63:     };
 64:   }, [
 65:     identity.id,
 66:     getSocket,
 67:     setConnected,
 68:     setSnapshot,
 69:     addLog,
 70:     onJobReceived,
 71:     snapshot?.runState,
 72:   ]);
 73: 
 74:   // Orchestration Actions
 75:   const setRunState = (s: SwarmStatus) =>
 76:     getSocket().emit(SocketEvents.SWARM_SET_STATE, s);
 77:   const setThrottle = (v: number) =>
 78:     getSocket().emit(SocketEvents.SWARM_SET_THROTTLE, v);
 79:   const toggleDevice = (id: string, enabled: boolean) =>
 80:     getSocket().emit("cmd:toggle_device", { id, enabled });
 81: 
 82:   const manualJoin = async (code: string) => {
 83:     saveSwarmToken(code);
 84:     const socket = socketManager.get(identity.id, code);
 85:     return new Promise<void>((res, rej) => {
 86:       socket.once("connect", () => res());
 87:       socket.once("connect_error", (err) => rej(err));
 88:       setTimeout(() => rej(new Error("Join Timeout")), 5000);
 89:     });
 90:   };
 91: 
 92:   const leaveSwarm = () => {
 93:     clearSwarmToken();
 94:     socketManager.disconnect();
 95:     window.location.href = window.location.origin;
 96:   };
 97: 
 98:   const generateInviteToken = () =>
 99:     new Promise<string>((res) => getSocket().emit("auth:generate_token", res));
100: 
101:   return {
102:     setRunState,
103:     setThrottle,
104:     toggleDevice,
105:     manualJoin,
106:     leaveSwarm,
107:     generateInviteToken,
108:   };
109: };
</file>

<file path="client/src/hooks/useTheme.ts">
 1: import { useState, useEffect } from "react";
 2: 
 3: export const useTheme = () => {
 4:   const [isDark, setIsDark] = useState(() => {
 5:     const saved = localStorage.getItem("ostrich_theme");
 6:     if (saved) return saved === "dark";
 7:     return window.matchMedia("(prefers-color-scheme: dark)").matches;
 8:   });
 9: 
10:   useEffect(() => {
11:     const root = window.document.documentElement;
12:     if (isDark) {
13:       root.classList.add("dark");
14:       localStorage.setItem("ostrich_theme", "dark");
15:     } else {
16:       root.classList.remove("dark");
17:       localStorage.setItem("ostrich_theme", "light");
18:     }
19:   }, [isDark]);
20: 
21:   return { isDark, toggleTheme: () => setIsDark(!isDark) };
22: };
</file>

<file path="client/src/hooks/useWorker.ts">
  1: // client/src/hooks/useWorker.ts
  2: import { useEffect, useRef, useCallback } from "react";
  3: import { useSwarmStore } from "../core/swarmStore";
  4: import { socketManager } from "../core/SocketManager";
  5: import { SocketEvents } from "@shared/socket/events";
  6: import { usePersistentIdentity } from "./usePersistentIdentity";
  7: import { MAX_SAFE_THROTTLE_PERCENT } from "../core/constants";
  8: import ComputeWorker from "../utils/compute.worker?worker";
  9: import { metrics } from "../utils/metrics";
 10: 
 11: export const useWorker = () => {
 12:   const workerRef = useRef<Worker | null>(null);
 13:   const { identity, swarmToken } = usePersistentIdentity();
 14:   const { snapshot, addLog } = useSwarmStore();
 15: 
 16:   const handleWorkerMessage = useCallback(
 17:     (e: MessageEvent) => {
 18:       const {
 19:         type,
 20:         score,
 21:         chunkId,
 22:         result,
 23:         error,
 24:         message,
 25:         level,
 26:         durationMs,
 27:       } = e.data;
 28:       const socket = socketManager.get(identity.id, swarmToken);
 29: 
 30:       switch (type) {
 31:         case "WORKER_LOG":
 32:           addLog(level || "SYS", message);
 33:           break;
 34:         case "BENCHMARK_COMPLETE":
 35:           socket.emit(SocketEvents.BENCHMARK_RESULT, { score });
 36:           addLog("CPU", `Benchmark: ${score.toLocaleString()} OPS/s`);
 37:           break;
 38:         case "JOB_COMPLETE":
 39:           if (durationMs) {
 40:             metrics.record("job_execution_time", durationMs);
 41:           }
 42:           socket.emit(SocketEvents.JOB_COMPLETE, {
 43:             chunkId,
 44:             result,
 45:             workerId: identity.id,
 46:             durationMs,
 47:           });
 48:           socket.emit(SocketEvents.JOB_REQUEST_BATCH);
 49:           break;
 50:         case "JOB_ERROR":
 51:           addLog("ERR", `Job ${chunkId} failed: ${error}`);
 52:           socket.emit(SocketEvents.JOB_COMPLETE, {
 53:             chunkId,
 54:             error,
 55:             workerId: identity.id,
 56:           });
 57:           socket.emit(SocketEvents.JOB_REQUEST_BATCH);
 58:           break;
 59:       }
 60:     },
 61:     [identity.id, swarmToken, addLog],
 62:   );
 63: 
 64:   // Initialize Worker
 65:   useEffect(() => {
 66:     if (!workerRef.current) {
 67:       workerRef.current = new ComputeWorker();
 68:     }
 69:     workerRef.current.onmessage = handleWorkerMessage;
 70: 
 71:     return () => {
 72:       workerRef.current?.terminate();
 73:       workerRef.current = null;
 74:     };
 75:   }, [handleWorkerMessage]);
 76: 
 77:   // Sync Throttle with Worker Thread Pool
 78:   useEffect(() => {
 79:     if (!workerRef.current) return;
 80: 
 81:     const globalThrottle = snapshot?.stats.globalThrottle ?? 40;
 82:     const safeThrottle =
 83:       Math.min(globalThrottle, MAX_SAFE_THROTTLE_PERCENT) / 100;
 84: 
 85:     workerRef.current.postMessage({
 86:       type: "CONFIG_UPDATE",
 87:       payload: { throttle: safeThrottle },
 88:     });
 89:   }, [snapshot?.stats.globalThrottle]);
 90: 
 91:   const runLocalBenchmark = useCallback(() => {
 92:     const socket = socketManager.get(identity.id, swarmToken);
 93:     socket.emit(SocketEvents.HEARTBEAT, { lastInteraction: Date.now() });
 94:     addLog("SYS", "Manual Benchmark Triggered");
 95:     workerRef.current?.postMessage({ type: "BENCHMARK" });
 96:   }, [identity.id, swarmToken, addLog]);
 97: 
 98:   const executeJob = useCallback((job: any) => {
 99:     workerRef.current?.postMessage({ type: "EXECUTE_JOB", payload: job });
100:   }, []);
101: 
102:   return { runLocalBenchmark, executeJob };
103: };
</file>

<file path="client/src/main.tsx">
 1: import { StrictMode } from "react";
 2: import { createRoot } from "react-dom/client";
 3: import "./core/theme.css";
 4: import App from "./App.tsx";
 5: import { ErrorBoundary } from "./components/ErrorBoundary.tsx";
 6: import { SwarmProvider } from "./contexts/SwarmContext.tsx";
 7: 
 8: createRoot(document.getElementById("root")!).render(
 9:   <StrictMode>
10:     <ErrorBoundary>
11:       <SwarmProvider>
12:         <App />
13:       </SwarmProvider>
14:     </ErrorBoundary>
15:   </StrictMode>,
16: );
</file>

<file path="client/src/utils/compute.worker.ts">
  1: /// <reference lib="webworker" />
  2: 
  3: import { MAX_SAFE_THROTTLE_PERCENT } from "../core/constants";
  4: 
  5: const TOTAL_CORES = navigator.hardwareConcurrency || 4;
  6: const RESERVED_CORES = TOTAL_CORES > 8 ? 2 : 1;
  7: const LOGICAL_CORES = Math.max(1, TOTAL_CORES - RESERVED_CORES);
  8: 
  9: const threadPool = new Map();
 10: let throttleLimit = 0.3;
 11: let nextWorkerId = 0;
 12: 
 13: const WGSL_SHADER = `
 14: @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
 15: @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
 16: @group(0) @binding(2) var<storage, read_write> result : array<f32>;
 17: @group(0) @binding(3) var<uniform> uniforms : vec2<f32>;
 18: 
 19: @compute @workgroup_size(64)
 20: fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
 21:   let index = global_id.x;
 22:   let size = u32(uniforms.x);
 23:   if (index >= size * size) { return; }
 24:   let row = index / size;
 25:   let col = index % size;
 26:   var sum = 0.0;
 27:   for (var k = 0u; k < size; k = k + 1u) {
 28:     sum = sum + matrixA[row * size + k] * matrixB[k * size + col];
 29:   }
 30:   result[index] = sum;
 31: }
 32: `;
 33: 
 34: const createSubWorker = (_wId: number) => {
 35:   // CRITICAL: This block MUST be pure Vanilla JS. No TS 'as' or types.
 36:   const code = `
 37:     let device = null;
 38:     let computePipeline = null;
 39:     let gpuReady = false;
 40: 
 41:     const runCpuStress = (iterations) => {
 42:       let sum = 0;
 43:       for (let i = 0; i < (iterations || 100000); i++) {
 44:         sum += Math.sqrt(i) * Math.sin(i);
 45:       }
 46:       return sum;
 47:     };
 48: 
 49:     async function initWebGPU() {
 50:       if (!navigator.gpu) return false;
 51:       try {
 52:         const adapter = await navigator.gpu.requestAdapter();
 53:         if (!adapter) return false;
 54:         device = await adapter.requestDevice();
 55:         const shaderModule = device.createShaderModule({ code: \`${WGSL_SHADER}\` });
 56:         computePipeline = device.createComputePipeline({
 57:           layout: 'auto',
 58:           compute: { module: shaderModule, entryPoint: "main" }
 59:         });
 60:         return true;
 61:       } catch(e) { return false; }
 62:     }
 63: 
 64:     const initPromise = initWebGPU().then(ok => {
 65:       gpuReady = ok;
 66:       self.postMessage({ type: "WORKER_LOG", level: "GPU", message: ok ? "WebGPU Kernel Ready" : "WebGPU Init Failed: Using CPU Fallback" });
 67:     });
 68: 
 69:     self.onmessage = async (e) => {
 70:       await initPromise;
 71:       const { type, payload } = e.data;
 72: 
 73:       if (type === "EXECUTE_JOB") {
 74:         const start = performance.now();
 75:         let result = 0;
 76:         try {
 77:           // Actual math execution
 78:           result = runCpuStress(payload.data?.iterations || 100000);
 79:           self.postMessage({ type: "JOB_COMPLETE", chunkId: payload.id, result, durationMs: performance.now() - start });
 80:           
 81:           
 82:         } catch (err) {
 83:           self.postMessage({ type: "JOB_ERROR", chunkId: payload.id, error: err.message });
 84:         }
 85:       }
 86: 
 87:       if (type === "BENCHMARK") {
 88:         const start = performance.now();
 89:         runCpuStress(1000000);
 90:         const score = Math.round(1000 / ((performance.now() - start) / 1000));
 91:         self.postMessage({ type: "BENCHMARK_COMPLETE", score });
 92:       }
 93:     };
 94:   `;
 95:   const blob = new Blob([code], { type: "application/javascript" });
 96:   const objectUrl = URL.createObjectURL(blob);
 97:   const worker = new Worker(objectUrl);
 98: 
 99:   // Cleanup the URL immediately after the worker is initialized to free memory
100:   // The worker remains active as the browser has already loaded the script
101:   URL.revokeObjectURL(objectUrl);
102: 
103:   return { worker, objectUrl: "" }; // objectUrl no longer needed
104: };
105: 
106: const applyConfig = () => {
107:   const safeThrottle = Math.min(throttleLimit, MAX_SAFE_THROTTLE_PERCENT / 100);
108:   const target = Math.max(1, Math.floor(LOGICAL_CORES * safeThrottle));
109: 
110:   if (target > threadPool.size) {
111:     for (let i = threadPool.size; i < target; i++) {
112:       const wId = nextWorkerId++;
113:       const { worker } = createSubWorker(wId);
114:       worker.onmessage = (ev) => self.postMessage(ev.data);
115:       threadPool.set(wId, { worker, busy: false });
116:     }
117:   } else if (target < threadPool.size) {
118:     const toRemove = Array.from(threadPool.entries())
119:       .filter(([, data]) => !data.busy)
120:       .slice(0, threadPool.size - target);
121: 
122:     toRemove.forEach(([id, data]) => {
123:       data.worker.terminate();
124:       threadPool.delete(id);
125:     });
126:   }
127: };
128: 
129: self.onmessage = (e) => {
130:   const { type, payload } = e.data;
131:   if (type === "CONFIG_UPDATE") {
132:     throttleLimit = payload.throttle;
133:     applyConfig();
134:     return;
135:   }
136: 
137:   // Find free worker
138:   const workers = Array.from(threadPool.values());
139:   const freeWorker = workers.find((t) => !t.busy) || workers[0]; // Fallback to first if all busy
140: 
141:   if (freeWorker) {
142:     if (type === "EXECUTE_JOB") freeWorker.busy = true;
143:     const originalHandler = freeWorker.worker.onmessage;
144:     freeWorker.worker.onmessage = (ev: any) => {
145:       freeWorker.busy = false;
146:       freeWorker.worker.onmessage = originalHandler;
147:       self.postMessage(ev.data);
148:     };
149:     freeWorker.worker.postMessage({ type, payload });
150:   }
151: };
</file>

<file path="client/src/utils/metrics.ts">
 1: export class MetricsCollector {
 2:   private metrics: Map<string, number[]> = new Map();
 3: 
 4:   /**
 5:    * Records a new data point for a specific metric.
 6:    * Limits storage to the last 1000 values to prevent memory leaks.
 7:    */
 8:   record(metric: string, value: number) {
 9:     if (!this.metrics.has(metric)) {
10:       this.metrics.set(metric, []);
11:     }
12: 
13:     const stream = this.metrics.get(metric)!;
14:     stream.push(value);
15: 
16:     // Keep last 1000 values (Memory Boundary)
17:     if (stream.length > 1000) {
18:       stream.shift();
19:     }
20:   }
21: 
22:   /**
23:    * Calculates the moving average for a metric.
24:    */
25:   getAverage(metric: string): number {
26:     const values = this.metrics.get(metric) || [];
27:     if (values.length === 0) return 0;
28:     const sum = values.reduce((a, b) => a + b, 0);
29:     return sum / values.length;
30:   }
31: 
32:   /**
33:    * Returns the most recent value recorded.
34:    */
35:   getLatest(metric: string): number {
36:     const values = this.metrics.get(metric) || [];
37:     return values.length > 0 ? values[values.length - 1] : 0;
38:   }
39: }
40: 
41: // Export a singleton instance for app-wide tracking
42: export const metrics = new MetricsCollector();
</file>

<file path="client/tsconfig.app.json">
 1: {
 2:   "compilerOptions": {
 3:     "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
 4:     "target": "ES2022",
 5:     "useDefineForClassFields": true,
 6:     "lib": ["ES2022", "DOM", "DOM.Iterable"],
 7:     "module": "ESNext",
 8:     "types": ["vite/client", "node"],
 9:     "skipLibCheck": true,
10:     "baseUrl": ".",
11:     "paths": {
12:       "@shared/*": ["../shared/*"]
13:     },
14:     /* Bundler mode */
15:     "moduleResolution": "bundler",
16:     "allowImportingTsExtensions": true,
17:     "verbatimModuleSyntax": true,
18:     "moduleDetection": "force",
19:     "noEmit": true,
20:     "jsx": "react-jsx",
21: 
22:     /* Linting */
23:     "strict": true,
24:     "noUnusedLocals": true,
25:     "noUnusedParameters": true,
26:     "erasableSyntaxOnly": true,
27:     "noFallthroughCasesInSwitch": true,
28:     "noUncheckedSideEffectImports": true
29:   },
30:   "include": ["src"]
31: }
</file>

<file path="client/tsconfig.json">
1: {
2:   "files": [],
3:   "references": [
4:     { "path": "./tsconfig.app.json" },
5:     { "path": "./tsconfig.node.json" }
6:   ]
7: }
</file>

<file path="client/tsconfig.node.json">
 1: {
 2:   "compilerOptions": {
 3:     "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
 4:     "target": "ES2023",
 5:     "lib": ["ES2023"],
 6:     "module": "ESNext",
 7:     "types": ["node"],
 8:     "skipLibCheck": true,
 9: 
10:     /* Bundler mode */
11:     "moduleResolution": "bundler",
12:     "allowImportingTsExtensions": true,
13:     "verbatimModuleSyntax": true,
14:     "moduleDetection": "force",
15:     "noEmit": true,
16: 
17:     /* Linting */
18:     "strict": true,
19:     "noUnusedLocals": true,
20:     "noUnusedParameters": true,
21:     "erasableSyntaxOnly": true,
22:     "noFallthroughCasesInSwitch": true,
23:     "noUncheckedSideEffectImports": true
24:   },
25:   "include": ["vite.config.ts"]
26: }
</file>

<file path="client/vite.config.ts">
 1: import { defineConfig } from "vite";
 2: import react from "@vitejs/plugin-react-swc";
 3: import tailwindcss from "@tailwindcss/vite";
 4: import path from "path";
 5: // https://vite.dev/config/
 6: export default defineConfig({
 7:   plugins: [react(), tailwindcss()],
 8:   server: {
 9:     allowedHosts: true,
10:     host: true,
11:     proxy: {
12:       // Forward all requests starting with /api to the backend
13:       "/api": {
14:         target: "http://localhost:3000",
15:         changeOrigin: true,
16:       },
17:       // Also proxy the socket.io connection
18:       "/socket.io": {
19:         target: "http://localhost:3000",
20:         secure: false,
21:         changeOrigin: true,
22:         ws: true,
23:       },
24:     },
25:   },
26:   resolve: {
27:     alias: {
28:       // Points @shared to the actual folder outside /client
29:       "@shared": path.resolve(__dirname, "../shared"),
30:     },
31:   },
32: });
</file>

<file path="server/package.json">
 1: {
 2:   "name": "ostrich-server",
 3:   "version": "1.0.0",
 4:   "type": "module",
 5:   "scripts": {
 6:     "dev": "bun src/index.ts"
 7:   },
 8:   "dependencies": {
 9:     "cors": "^2.8.6",
10:     "express": "^5.2.1",
11:     "http": "^0.0.1-security",
12:     "socket.io": "^4.8.3"
13:   },
14:   "devDependencies": {
15:     "@types/cors": "^2.8.13",
16:     "@types/express": "^4.17.17",
17:     "@types/node": "^25.2.1",
18:     "ts-node": "^10.9.1",
19:     "typescript": "^5.1.6"
20:   }
21: }
</file>

<file path="server/src/core/types.ts">
 1: // server/src/core/types.ts
 2: export type DeviceType = "DESKTOP" | "MOBILE" | "COLAB" | "SERVER";
 3: export type JobType = "MATH_STRESS" | "MAT_MUL" | "TEXT_TOKENIZE";
 4: // Added REGISTERED to the flow
 5: export type DeviceConnectionStatus =
 6:   | "OFFLINE"
 7:   | "ONLINE"
 8:   | "BUSY"
 9:   | "DISABLED"
10:   | "REGISTERED";
11: 
12: export interface DeviceCapabilities {
13:   cpuCores: number;
14:   memoryGB: number;
15:   gpuAvailable: boolean;
16:   gpuName?: string;
17: }
18: 
19: export interface DeviceInfo {
20:   id: string;
21:   name: string;
22:   type: DeviceType;
23:   status: DeviceConnectionStatus;
24:   capabilities: DeviceCapabilities;
25:   opsScore: number;
26:   totalJobsCompleted: number;
27:   lastHeartbeat: number;
28:   lastUserInteraction: number;
29:   swarmId?: string;
30: }
31: 
32: // ... rest of the file remains same
33: export interface SwarmResources {
34:   totalCores: number;
35:   totalMemory: number;
36:   totalGPUs: number;
37:   onlineCount: number;
38: }
39: 
40: export interface Job {
41:   id: string;
42:   type: JobType;
43:   complexity: number;
44:   data: any;
45: }
46: 
47: export interface SwarmSnapshot {
48:   runState: "IDLE" | "RUNNING" | "PAUSED" | "STOPPED";
49:   devices: Record<string, DeviceInfo>;
50:   stats: {
51:     totalJobs: number;
52:     activeJobs: number;
53:     pendingJobs: number;
54:     completedJobs: number;
55:     globalVelocity: number;
56:     globalThrottle: number;
57:   };
58:   resources: SwarmResources;
59: }
</file>

<file path="server/src/index.ts">
  1: import { Server } from "socket.io";
  2: import { DeviceManager } from "./managers/DeviceManager";
  3: import { JobScheduler } from "./managers/JobScheduler";
  4: import { AuthManager } from "./managers/AuthManager";
  5: import { type SwarmSnapshot } from "./core/types";
  6: import { SocketEvents } from "@shared/socket/events";
  7: import { type LogLevel, type SystemLogPayload } from "@shared/socket/states";
  8: 
  9: const io = new Server(3000, {
 10:   cors: { origin: "*" },
 11:   transports: ["websocket", "polling"],
 12: });
 13: 
 14: const deviceManager = new DeviceManager();
 15: const jobScheduler = new JobScheduler();
 16: const authManager = new AuthManager();
 17: 
 18: const activeSwarmIds = new Set<string>();
 19: const swarmStates = new Map<string, SwarmSnapshot["runState"]>();
 20: const swarmCompletedCounts = new Map<string, number>();
 21: const swarmThrottles = new Map<string, number>();
 22: 
 23: /**
 24:  * Global System Logger
 25:  * Broadcasts to terminal and server console
 26:  */
 27: const systemLog = (
 28:   swarmId: string,
 29:   level: LogLevel,
 30:   message: string,
 31:   source: string = "CORE",
 32: ) => {
 33:   const payload: SystemLogPayload = {
 34:     level,
 35:     message,
 36:     timestamp: Date.now(),
 37:     source,
 38:   };
 39:   io.to(swarmId).emit(SocketEvents.SYSTEM_LOG, payload);
 40: };
 41: 
 42: // Auth Middleware (as we fixed in Phase 0)
 43: // server/src/index.ts
 44: 
 45: io.use((socket, next) => {
 46:   const token = socket.handshake.auth.token || socket.handshake.query.token;
 47:   const persistentId = socket.handshake.query.persistentId as string;
 48: 
 49:   if (!persistentId) return next(new Error("MISSING_PERSISTENT_ID"));
 50: 
 51:   // Master Mode: No token provided or token is empty
 52:   const isEmptyToken =
 53:     !token || token === "null" || token === "undefined" || token === "";
 54: 
 55:   if (isEmptyToken) {
 56:     socket.data.swarmId = persistentId; // Host joins their own swarm
 57:     return next();
 58:   }
 59: 
 60:   // Worker Mode: Validate the invite code against active sessions
 61:   const targetSwarm = authManager.validateToken(token as string);
 62: 
 63:   if (targetSwarm) {
 64:     socket.data.swarmId = targetSwarm; // Restore joined membership
 65:     return next();
 66:   }
 67: 
 68:   // Reject connection if the token is invalid or expired
 69:   return next(new Error("JOIN_CODE_INVALID"));
 70: });
 71: 
 72: io.on("connection", (socket) => {
 73:   const persistentId = socket.handshake.query.persistentId as string;
 74:   const swarmId = socket.data.swarmId;
 75:   activeSwarmIds.add(swarmId);
 76: 
 77:   socket.join(swarmId);
 78:   systemLog(
 79:     swarmId,
 80:     "NET",
 81:     `Socket connected: ${persistentId.slice(0, 8)}`,
 82:     "GATEWAY",
 83:   );
 84: 
 85:   // Protocol: Registration
 86:   socket.on(SocketEvents.DEVICE_REGISTER, (data) => {
 87:     deviceManager.register(persistentId, data.name, data.capabilities, swarmId);
 88:     // FIX: Register device in scheduler to initialize quotas
 89:     const device = deviceManager.getDevice(persistentId);
 90:     if (device) jobScheduler.registerDevice(device);
 91: 
 92:     systemLog(swarmId, "SYS", `Node Registered: ${data.name}`, "AUTH");
 93:     deviceManager.heartbeat(persistentId);
 94:     broadcastState(swarmId);
 95:   });
 96: 
 97:   // Protocol: Heartbeat
 98:   socket.on(SocketEvents.HEARTBEAT, (data) => {
 99:     deviceManager.heartbeat(persistentId, data);
100:   });
101: 
102:   // Protocol: Job Pipeline
103:   socket.on(SocketEvents.JOB_REQUEST_BATCH, () => {
104:     const currentState = swarmStates.get(swarmId);
105:     const device = deviceManager.getDevice(persistentId);
106: 
107:     if (!device || device.status === "OFFLINE" || currentState !== "RUNNING")
108:       return;
109: 
110:     // FIX: Use the new batch distribution method
111:     const batch = jobScheduler.getJobBatchForDevice(device, 10); // Requesting larger batches for high-perf
112: 
113:     if (batch.length > 0) {
114:       socket.emit(SocketEvents.JOB_BATCH_DISPATCH, batch);
115:     }
116:   });
117: 
118:   socket.on(SocketEvents.JOB_COMPLETE, (payload) => {
119:     // FIX: Release the job slot in the scheduler regardless of success/error
120:     jobScheduler.releaseJobSlot(persistentId);
121:     if (!payload.error) {
122:       swarmCompletedCounts.set(
123:         swarmId,
124:         (swarmCompletedCounts.get(swarmId) || 0) + 1,
125:       );
126:       const device = deviceManager.getDevice(persistentId);
127:       if (device) device.totalJobsCompleted++;
128:     } else {
129:       systemLog(
130:         swarmId,
131:         "ERR",
132:         `Job ${payload.chunkId} failed on ${persistentId}`,
133:         "COMPUTE",
134:       );
135:     }
136:   });
137: 
138:   // --- ADD THIS HANDLER ---
139:   socket.on("auth:generate_token", (callback: (token: string) => void) => {
140:     try {
141:       const token = authManager.generateToken(swarmId);
142:       if (!token) {
143:         systemLog(
144:           swarmId,
145:           "WARN",
146:           "Invite code generation rate limited (5/min)",
147:           "AUTH",
148:         );
149:         callback("");
150:         return;
151:       }
152:       systemLog(swarmId, "SYS", `Generated new invite code: ${token}`, "AUTH");
153:       callback(token);
154:     } catch (err) {
155:       console.error("Token generation error:", err);
156:       callback("");
157:     }
158:   });
159:   // Swarm Controls
160:   socket.on(SocketEvents.SWARM_SET_STATE, (state) => {
161:     swarmStates.set(swarmId, state);
162:     systemLog(swarmId, "SYS", `Swarm state changed to ${state}`, "MASTER");
163:     broadcastState(swarmId);
164:   });
165: 
166:   socket.on(SocketEvents.SWARM_SET_THROTTLE, (val) => {
167:     swarmThrottles.set(swarmId, val);
168:     io.to(swarmId).emit(SocketEvents.SWARM_THROTTLE_SYNC, val);
169:   });
170: 
171:   socket.on(SocketEvents.BENCHMARK_RESULT, (data) => {
172:     deviceManager.updateScore(persistentId, data.score);
173:     systemLog(
174:       swarmId,
175:       "CPU",
176:       `Benchmark: ${data.score.toLocaleString()} OPS`,
177:       persistentId,
178:     );
179:     const device = deviceManager.getDevice(persistentId);
180:     if (device) jobScheduler.registerDevice(device);
181:     broadcastState(swarmId);
182:   });
183: 
184:   // --- ADD THIS HANDLER TO THE SERVER ---
185:   socket.on(
186:     "cmd:toggle_device",
187:     ({ id, enabled }: { id: string; enabled: boolean }) => {
188:       deviceManager.toggleDevice(id, enabled);
189: 
190:       systemLog(
191:         swarmId,
192:         enabled ? "SYS" : "WARN",
193:         `Node ${id.slice(0, 8)} was ${enabled ? "enabled" : "disabled"} by Master`,
194:         "ORCHESTRATOR",
195:       );
196: 
197:       // Force update to all nodes so the UI updates immediately
198:       broadcastState(swarmId);
199:     },
200:   );
201: 
202:   // --- ADD THIS HANDLER FOR THE GENERATOR ---
203: 
204:   socket.on("disconnect", () => {
205:     // Check if room is empty before removing swarmId from broadcaster
206:     const room = io.sockets.adapter.rooms.get(swarmId);
207:     if (!room || room.size === 0) {
208:       activeSwarmIds.delete(swarmId);
209:     }
210:     systemLog(
211:       swarmId,
212:       "NET",
213:       `Node offline: ${persistentId.slice(0, 8)}`,
214:       "GATEWAY",
215:     );
216:   });
217: });
218: 
219: /**
220:  * Single Global Snapshot Loop
221:  * Prevents interval leaks
222:  */
223: let broadcastDebounce: NodeJS.Timeout | null = null;
224: 
225: function broadcastState(swarmId: string) {
226:   if (broadcastDebounce) clearTimeout(broadcastDebounce);
227: 
228:   broadcastDebounce = setTimeout(() => {
229:     const resources = deviceManager.getAvailableResources(swarmId);
230:     const queue = jobScheduler.getQueueStats();
231:     const allDevices = deviceManager.getDevicesBySwarm(swarmId);
232:     const currentState = swarmStates.get(swarmId) || "STOPPED";
233:     const completedCount = swarmCompletedCounts.get(swarmId) || 0;
234:     const currentThrottle = swarmThrottles.get(swarmId) || 40;
235: 
236:     const totalOpsScore = allDevices
237:       .filter((d) => d.status !== "OFFLINE" && d.status !== "DISABLED")
238:       .reduce((sum, d) => sum + (d.opsScore || 0), 0);
239: 
240:     const snapshot: SwarmSnapshot = {
241:       runState: currentState,
242:       devices: allDevices.reduce((acc, d) => ({ ...acc, [d.id]: d }), {}),
243:       stats: {
244:         totalJobs: completedCount + queue.pending,
245:         activeJobs: currentState === "RUNNING" ? resources.onlineCount : 0,
246:         pendingJobs: queue.pending,
247:         completedJobs: completedCount,
248:         globalVelocity:
249:           currentState === "RUNNING"
250:             ? Math.round(totalOpsScore * (currentThrottle / 100))
251:             : 0,
252:         globalThrottle: currentThrottle,
253:       },
254:       resources,
255:     };
256: 
257:     io.to(swarmId).emit(SocketEvents.SWARM_SNAPSHOT, snapshot);
258:   }, 50);
259: }
260: 
261: // Tick all active swarms every 2s
262: setInterval(() => {
263:   activeSwarmIds.forEach((id) => {
264:     // Only broadcast if there are actually sockets in that room
265:     const room = io.sockets.adapter.rooms.get(id);
266:     if (room && room.size > 0) {
267:       broadcastState(id);
268:     } else {
269:       activeSwarmIds.delete(id);
270:     }
271:   });
272: }, 2000);
273: // Periodic Weight Recalculation (Every 10s)
274: // Re-calculates device weights based on live benchmark (opsScore) averages
275: setInterval(() => {
276:   activeSwarmIds.forEach((swarmId) => {
277:     const devices = deviceManager.getDevicesBySwarm(swarmId);
278:     devices.forEach((d) => {
279:       if (d.status !== "OFFLINE" && d.status !== "DISABLED") {
280:         jobScheduler.registerDevice(d);
281:       }
282:     });
283:   });
284: }, 10000);
285: console.log("🚀 Ostrich Swarm Coordinator [PHASE 2] Online");
</file>

<file path="server/src/managers/AuthManager.ts">
 1: export class AuthManager {
 2:   private activeTokens = new Map<
 3:     string,
 4:     { swarmId: string; expiresAt: number }
 5:   >();
 6:   private readonly TOKEN_TTL_MS = 24 * 60 * 60 * 1000;
 7:   private tokenGenerationLog = new Map<string, number[]>(); // swarmId -> timestamps
 8:   constructor() {
 9:     setInterval(() => this.cleanup(), 30000);
10:   }
11: 
12:   /**
13:    * Generates a unique 6-digit alphanumeric token for a specific swarm.
14:    */
15:   public generateToken(swarmId: string): string | null {
16:     const now = Date.now();
17:     let generations = this.tokenGenerationLog.get(swarmId) || [];
18:     const oneMinuteAgo = now - 60000;
19:     generations = generations.filter((t) => t > oneMinuteAgo);
20: 
21:     if (generations.length >= 5) {
22:       return null; // Rate limited
23:     }
24: 
25:     generations.push(now);
26:     this.tokenGenerationLog.set(swarmId, generations);
27: 
28:     const token = Math.random().toString(36).substring(2, 8).toUpperCase();
29:     this.activeTokens.set(token, {
30:       swarmId,
31:       expiresAt: Date.now() + this.TOKEN_TTL_MS,
32:     });
33: 
34:     return token;
35:   }
36: 
37:   /**
38:    * Validates a token and returns the associated swarmId.
39:    * This is the "Party Join" mechanism.
40:    */
41:   public validateToken(token: string): string | null {
42:     const data = this.activeTokens.get(token);
43: 
44:     if (!data) return null;
45: 
46:     if (Date.now() > data.expiresAt) {
47:       this.activeTokens.delete(token);
48:       return null;
49:     }
50: 
51:     return data.swarmId;
52:   }
53: 
54:   private cleanup() {
55:     const now = Date.now();
56:     for (const [token, data] of this.activeTokens.entries()) {
57:       if (now > data.expiresAt) this.activeTokens.delete(token);
58:     }
59:   }
60: }
</file>

<file path="server/src/managers/DeviceManager.ts">
  1: import {
  2:   type DeviceInfo,
  3:   type DeviceCapabilities,
  4:   type DeviceType,
  5: } from "../core/types";
  6: 
  7: export class DeviceManager {
  8:   private devices = new Map<string, DeviceInfo>();
  9:   // 60s for offline (allows for long reloads/bad signal), 5mins for full deletion
 10:   private readonly OFFLINE_THRESHOLD = 60000;
 11:   private readonly DELETE_THRESHOLD = 300000;
 12:   constructor() {
 13:     setInterval(() => this.cleanup(), 5000);
 14:   }
 15: 
 16:   public register(
 17:     id: string,
 18:     name: string,
 19:     caps: DeviceCapabilities,
 20:     swarmId: string,
 21:   ) {
 22:     const existing = this.devices.get(id);
 23:     let type: DeviceType = "DESKTOP";
 24: 
 25:     if (name.toLowerCase().includes("mobile")) {
 26:       type = "MOBILE";
 27:     } else if (name.toLowerCase().includes("colab")) {
 28:       type = "COLAB";
 29:     } else if (caps.gpuAvailable && caps.memoryGB > 16) {
 30:       type = "SERVER";
 31:     }
 32:     this.devices.set(id, {
 33:       id,
 34:       name,
 35:       type,
 36:       status: "ONLINE", // Move to ONLINE immediately if registering/re-registering
 37:       capabilities: caps,
 38:       opsScore: existing?.opsScore || 0,
 39:       totalJobsCompleted: existing?.totalJobsCompleted || 0,
 40:       lastHeartbeat: Date.now(),
 41:       lastUserInteraction: Date.now(),
 42:       swarmId,
 43:     });
 44:   }
 45: 
 46:   public heartbeat(id: string, data?: { lastInteraction: number }) {
 47:     const device = this.devices.get(id);
 48:     if (!device) return;
 49: 
 50:     device.lastHeartbeat = Date.now();
 51:     if (data?.lastInteraction)
 52:       device.lastUserInteraction = data.lastInteraction;
 53: 
 54:     // If they heartbeat, they are ONLINE
 55:     if (device.status === "OFFLINE" || device.status === "REGISTERED") {
 56:       device.status = "ONLINE";
 57:     }
 58:   }
 59: 
 60:   public toggleDevice(id: string, enabled: boolean) {
 61:     const device = this.devices.get(id);
 62:     if (device) device.status = enabled ? "ONLINE" : "DISABLED";
 63:   }
 64: 
 65:   public updateScore(id: string, score: number) {
 66:     const device = this.devices.get(id);
 67:     if (device) device.opsScore = score;
 68:   }
 69: 
 70:   public getDevicesBySwarm(swarmId: string) {
 71:     return Array.from(this.devices.values()).filter(
 72:       (d) => d.swarmId === swarmId,
 73:     );
 74:   }
 75: 
 76:   public getAvailableResources(swarmId: string) {
 77:     let [totalCores, totalMemory, totalGPUs, onlineCount] = [0, 0, 0, 0];
 78: 
 79:     this.getDevicesBySwarm(swarmId).forEach((d) => {
 80:       if (
 81:         d.status === "ONLINE" ||
 82:         d.status === "BUSY" ||
 83:         d.status === "REGISTERED"
 84:       ) {
 85:         totalCores += d.capabilities.cpuCores;
 86:         totalMemory += d.capabilities.memoryGB;
 87:         if (d.capabilities.gpuAvailable) totalGPUs++;
 88:         onlineCount++;
 89:       }
 90:     });
 91: 
 92:     return { totalCores, totalMemory, totalGPUs, onlineCount };
 93:   }
 94: 
 95:   public getDevice(id: string) {
 96:     return this.devices.get(id);
 97:   }
 98: 
 99:   public remove(id: string) {
100:     this.devices.delete(id);
101:   }
102: 
103:   private cleanup() {
104:     const now = Date.now();
105:     this.devices.forEach((device, id) => {
106:       const diff = now - device.lastHeartbeat;
107: 
108:       if (diff > this.DELETE_THRESHOLD) {
109:         this.devices.delete(id);
110:       } else if (
111:         device.status !== "DISABLED" &&
112:         diff > this.OFFLINE_THRESHOLD
113:       ) {
114:         device.status = "OFFLINE";
115:       }
116:     });
117:   }
118: }
</file>

<file path="server/src/managers/JobScheduler.ts">
  1: import { type Job, type DeviceInfo } from "../core/types";
  2: 
  3: interface DeviceJobQuota {
  4:   deviceId: string;
  5:   weight: number;
  6:   activeJobs: number;
  7:   maxConcurrent: number;
  8: }
  9: 
 10: export class JobScheduler {
 11:   private jobQueue: Job[] = [];
 12:   private deviceQuotas = new Map<string, DeviceJobQuota>();
 13:   private deviceWeights = new Map<string, number>();
 14:   private totalWeight = 0;
 15:   private readonly MAX_QUEUE_SIZE = 5000;
 16: 
 17:   constructor() {
 18:     setInterval(() => this.generateJobs(), 1000);
 19:   }
 20: 
 21:   private generateJobs() {
 22:     if (this.jobQueue.length > this.MAX_QUEUE_SIZE) return;
 23:     for (let i = 0; i < 100; i++) {
 24:       const isGpuTask = Math.random() > 0.7;
 25:       this.jobQueue.push({
 26:         id: `job-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`,
 27:         type: isGpuTask ? "MAT_MUL" : "MATH_STRESS",
 28:         complexity: Math.floor(Math.random() * 10) + 1,
 29:         data: isGpuTask ? { size: 1024 } : { iterations: 100000 },
 30:       });
 31:     }
 32:   }
 33: 
 34:   private calculateWeight(device: DeviceInfo): number {
 35:     const cpu = (device.capabilities.cpuCores || 4) * 10;
 36:     const gpu = device.capabilities.gpuAvailable ? 50 : 0;
 37:     const score = Math.min((device.opsScore || 0) / 1000, 100);
 38:     return Math.max(1, cpu + gpu + score);
 39:   }
 40: 
 41:   public registerDevice(device: DeviceInfo) {
 42:     const weight = this.calculateWeight(device);
 43:     const old = this.deviceWeights.get(device.id) || 0;
 44:     this.totalWeight += weight - old;
 45:     this.deviceWeights.set(device.id, weight);
 46: 
 47:     this.deviceQuotas.set(device.id, {
 48:       deviceId: device.id,
 49:       weight,
 50:       activeJobs: 0,
 51:       maxConcurrent: Math.max(10, (device.capabilities.cpuCores || 4) * 4),
 52:     });
 53:   }
 54: 
 55:   public getJobBatchForDevice(
 56:     device: DeviceInfo,
 57:     requestedCount: number = 10,
 58:   ): Job[] {
 59:     const quota = this.deviceQuotas.get(device.id);
 60:     if (!quota) {
 61:       this.registerDevice(device);
 62:       return this.getJobBatchForDevice(device, requestedCount);
 63:     }
 64: 
 65:     const availableSlots = quota.maxConcurrent - quota.activeJobs;
 66:     if (availableSlots <= 0) return [];
 67: 
 68:     const weight = this.deviceWeights.get(device.id) || 1;
 69:     const share = Math.max(
 70:       1,
 71:       Math.floor((weight / Math.max(1, this.totalWeight)) * requestedCount * 3),
 72:     );
 73: 
 74:     const batchSize = Math.min(share, availableSlots, this.jobQueue.length);
 75: 
 76:     const batch: Job[] = [];
 77:     const preferred = device.capabilities.gpuAvailable
 78:       ? "MAT_MUL"
 79:       : "MATH_STRESS";
 80: 
 81:     for (let i = 0; i < batchSize; i++) {
 82:       let idx = this.jobQueue.findIndex((j) => j.type === preferred);
 83:       if (idx === -1) idx = 0;
 84:       if (idx < this.jobQueue.length) {
 85:         batch.push(this.jobQueue.splice(idx, 1)[0]);
 86:         quota.activeJobs++;
 87:       }
 88:     }
 89:     return batch;
 90:   }
 91: 
 92:   public releaseJobSlot(deviceId: string, durationMs?: number) {
 93:     const quota = this.deviceQuotas.get(deviceId);
 94:     if (quota && quota.activeJobs > 0) {
 95:       quota.activeJobs--;
 96: 
 97:       // If we got duration data, we could refine the weight here
 98:       if (durationMs && durationMs > 0) {
 99:         // Example: Penalize weight if jobs are taking > 2000ms
100:         const latencyImpact = durationMs > 2000 ? 0.95 : 1.02;
101:         quota.weight *= latencyImpact;
102:       }
103:     }
104:   }
105: 
106:   public getQueueStats() {
107:     return {
108:       pending: this.jobQueue.length,
109:       active: Array.from(this.deviceQuotas.values()).reduce(
110:         (sum, q) => sum + q.activeJobs,
111:         0,
112:       ),
113:     };
114:   }
115: }
</file>

<file path="server/tsconfig.json">
 1: {
 2:   "compilerOptions": {
 3:     "target": "ES2023",
 4:     "lib": ["ES2023"],
 5:     "module": "ESNext",
 6:     "types": ["node"],
 7:     "skipLibCheck": true,
 8:     "baseUrl": ".",
 9:     "paths": {
10:       "@shared/*": ["../shared/*"]
11:     },
12: 
13:     /* Bundler mode */
14:     "moduleResolution": "bundler",
15:     "allowImportingTsExtensions": true,
16:     "verbatimModuleSyntax": true,
17:     "moduleDetection": "force",
18:     "noEmit": true,
19: 
20:     /* Linting */
21:     "strict": true,
22:     "noUnusedLocals": true,
23:     "noUnusedParameters": true,
24:     "erasableSyntaxOnly": true,
25:     "noFallthroughCasesInSwitch": true,
26:     "noUncheckedSideEffectImports": true
27:   }
28: }
</file>

<file path="shared/socket/events.ts">
 1: export const SocketEvents = {
 2:   // Connection Lifecycle
 3:   CONNECT: "connect",
 4:   DISCONNECT: "disconnect",
 5:   CONNECTION_ERROR: "connect_error",
 6: 
 7:   // Identity & Registration
 8:   DEVICE_REGISTER: "device:register",
 9:   DEVICE_READY: "device:ready",
10:   HEARTBEAT: "heartbeat",
11: 
12:   // Swarm Orchestration
13:   SWARM_SNAPSHOT: "swarm:snapshot",
14:   SWARM_SET_STATE: "cmd:set_run_state",
15:   SWARM_SET_THROTTLE: "cmd:set_throttle",
16:   SWARM_THROTTLE_SYNC: "swarm:throttle_sync",
17: 
18:   // Job Pipeline
19:   JOB_REQUEST_BATCH: "job:request_batch",
20:   JOB_BATCH_DISPATCH: "job:batch",
21:   JOB_COMPLETE: "job:complete",
22: 
23:   // Diagnostics & Terminal
24:   SYSTEM_LOG: "sys:log",
25:   BENCHMARK_START: "cmd:run_benchmark",
26:   BENCHMARK_RESULT: "benchmark:result",
27: } as const;
28: 
29: export type SocketEvent = (typeof SocketEvents)[keyof typeof SocketEvents];
</file>

<file path="shared/socket/payloads.ts">
 1: import { SwarmRunState, DeviceConnectionStatus, LogLevel } from "./states";
 2: 
 3: export interface DeviceRegisterPayload {
 4:   name: string;
 5:   capabilities: {
 6:     cpuCores: number;
 7:     memoryGB: number;
 8:     gpuAvailable: boolean;
 9:     gpuName?: string;
10:   };
11: }
12: 
13: export interface JobCompletePayload {
14:   chunkId: string;
15:   workerId: string;
16:   result?: any;
17:   error?: string;
18:   durationMs?: number;
19: }
20: 
21: export interface SwarmSnapshotPayload {
22:   runState: SwarmRunState;
23:   devices: Record<string, any>; // Will be refined in Phase 2
24:   stats: {
25:     totalJobs: number;
26:     completedJobs: number;
27:     activeJobs: number;
28:     globalVelocity: number;
29:     globalThrottle: number;
30:   };
31: }
</file>

<file path="shared/socket/states.ts">
 1: // Strict states for the compute engine
 2: export type SwarmRunState = "IDLE" | "RUNNING" | "PAUSED" | "STOPPED";
 3: 
 4: // Device lifecycle states
 5: export type DeviceConnectionStatus = "OFFLINE" | "ONLINE" | "BUSY" | "DISABLED";
 6: 
 7: // Log levels for the Terminal
 8: export type LogLevel = "SYS" | "NET" | "CPU" | "GPU" | "ERR" | "WARN";
 9: 
10: export interface SystemLogPayload {
11:   level: LogLevel;
12:   message: string;
13:   timestamp: number;
14:   source?: string;
15: }
</file>

</files>
