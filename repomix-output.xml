This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
Architecture.md
client/.gitignore
client/eslint.config.js
client/index.html
client/package.json
client/public/favicon.svg
client/public/logo.svg
client/README.md
client/src/App.tsx
client/src/components/Card.tsx
client/src/core/theme.css
client/src/core/types.ts
client/src/features/connection/DeviceConnector.tsx
client/src/features/dashboard/ActiveSwarm.tsx
client/src/features/dashboard/JobGauge.tsx
client/src/features/dashboard/ResourceStats.tsx
client/src/features/dashboard/SwarmControls.tsx
client/src/features/dashboard/ThrottleControl.tsx
client/src/features/dashboard/VelocityMonitor.tsx
client/src/features/terminal/LiveTerminal.tsx
client/src/hooks/usePersistentIdentity.ts
client/src/hooks/useSwarmEngine.ts
client/src/main.tsx
client/src/utils/compute.worker.ts
client/tsconfig.app.json
client/tsconfig.json
client/tsconfig.node.json
client/vite.config.ts
OstrichLegs.png
Resource_share-COLAB.ipynb
server/package.json
server/src/core/types.ts
server/src/index.ts
server/src/managers/AuthManager.ts
server/src/managers/DeviceManager.ts
server/src/managers/JobScheduler.ts
server/tsconfig.json
shared/socket/events.ts
shared/socket/payloads.ts
shared/socket/states.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
node_modules/

# Markdowns for notes
AGENTS.md
PROJECT_CONTEXT.md

# Repomix
repomix.config.json
repomix-output.xml

# Images
flowchartinsp.png
</file>

<file path="Architecture.md">
Client Architecture Plan: Ostrich-Legs
Resource Impact Analysis & CPU Usage Investigation

---

1. EXECUTIVE SUMMARY
   

---

2. COMPLETE FILE ARCHITECTURE
   D:\JOB\Ostrich-Legs\client\
   â”œâ”€â”€ Configuration Layer
   â”‚ â”œâ”€â”€ vite.config.ts # Build tool configuration
   â”‚ â”œâ”€â”€ tsconfig\*.json # TypeScript configurations (3 files)
   â”‚ â”œâ”€â”€ eslint.config.js # Linting rules
   â”‚ â””â”€â”€ package.json # Dependencies & scripts
   â”‚
   â”œâ”€â”€ Entry Points
   â”‚ â”œâ”€â”€ index.html # HTML entry
   â”‚ â”œâ”€â”€ src/main.tsx # React DOM mount
   â”‚ â””â”€â”€ src/App.tsx # Root component
   â”‚
   â”œâ”€â”€ Core Hooks (CPU-Intensive)
   â”‚ â”œâ”€â”€ src/hooks/useComputeSwarm.ts # Main orchestration hook
   â”‚ â””â”€â”€ src/hooks/usePersistentIdentity.ts # Device ID management
   â”‚
   â”œâ”€â”€ Web Workers (Maximum CPU)
   â”‚ â””â”€â”€ src/utils/worker.ts # Worker manager + sub-workers
   â”‚
   â”œâ”€â”€ UI Components
   â”‚ â”œâ”€â”€ src/components/ui/
   â”‚ â”‚ â”œâ”€â”€ Card.tsx # Layout wrapper
   â”‚ â”‚ â”œâ”€â”€ Badge.tsx # Status indicators
   â”‚ â”‚ â””â”€â”€ ThemeToggle.tsx # Dark/light mode
   â”‚ â”‚
   â”‚ â””â”€â”€ src/components/dashboard/
   â”‚ â”œâ”€â”€ GpuStatusMonitor.tsx # Canvas velocity chart [HIGH CPU]
   â”‚ â”œâ”€â”€ SwarmDashboard.tsx # Device list & stats
   â”‚ â”œâ”€â”€ StatusMonitor.tsx # Recharts (unused)
   â”‚ â”œâ”€â”€ LiveTerminal.tsx # Log console
   â”‚ â”œâ”€â”€ DeviceHealth.tsx # Benchmark display
   â”‚ â”œâ”€â”€ ThrottleControl.tsx # CPU slider
   â”‚ â”œâ”€â”€ SwarmControls.tsx # Start/Pause buttons
   â”‚ â””â”€â”€ DeviceConnector.tsx # QR code modal
   â”‚
   â”œâ”€â”€ Styles
   â”‚ â””â”€â”€ src/index.css # Tailwind v4 + custom CSS
   â”‚
   â””â”€â”€ Assets
   â””â”€â”€ src/assets/react.svg # Static asset

---

3. RESOURCE IMPACT BY FILE
   CRITICAL CPU CONSUMERS ðŸ”´
   src/utils/worker.ts - HIGHEST IMPACT
   Resource Profile:

- CPU: 70-100% when active (intentional - this IS the compute engine)
- Memory: 50-200MB depending on thread pool size
- GPU: Uses WebGPU when available (2 billion ops/matrix)
  Architecture:
  Main Thread
  â””â”€â”€ OstrichWorker (Manager)
  â””â”€â”€ Thread Pool (Dynamic 1-N workers)
  â””â”€â”€ Sub-Workers (Created via Blob URLs)
  â”œâ”€â”€ GPU Kernel (WGSL shader)
  â””â”€â”€ CPU Kernel (Math loops)
  Resource Hotspots:

1. Lines 15-38: WGSL shader compilation (one-time, expensive)
2. Lines 41-186: Sub-worker factory - creates workers via new Blob() + URL.createObjectURL()
3. Lines 46-59: CPU stress test - Math.sqrt(i) \* Math.sin(i) in tight loop
4. Lines 85-134: GPU matrix multiplication - 1000Ã—1000 = 2 billion operations
5. Lines 188-241: Dynamic thread pool scaling based on throttleLimit
   Impact Assessment:

- Development Mode: Workers run at full throttle regardless of dev server
- Thread Creation: Each sub-worker is a separate JS context (memory overhead)
- Blob URLs: URL.createObjectURL creates memory pressure if not revoked properly

---

src/hooks/useComputeSwarm.ts - HIGH IMPACT
Resource Profile:

- CPU: 5-15% from intervals and socket handling
- Memory: Low (~5MB)
- Network: Continuous WebSocket traffic
  Critical Sections:
  Lines 101-112: UI Sync Loop
  const uiInterval = setInterval(() => {
  setCompletedCount((prev) => {
  if (prev !== completedCountRef.current) {
  return completedCountRef.current; // State update every 500ms
  }
  return prev;
  });
  }, 500);
- Impact: Forces React re-evaluation every 500ms even if value unchanged
- Optimization: Use requestAnimationFrame instead, or only update on actual change
  Lines 114-131: Auto-Request Loop
  const interval = setInterval(() => {
  if (socketRef.current?.connected) {
  socketRef.current.emit("job:request_batch"); // Every 1000ms when running
  }
  }, 1000);
- Impact: Network overhead + server load
- Note: This is likely the intended behavior for distributed computing
  Lines 30-98: Master Setup Effect
- Creates Web Worker (lines 32-33)
- Socket.io connection with reconnection (lines 62-67)
- Event listeners for: connect, snapshot, join codes, benchmarks, job batches

---

src/components/dashboard/GpuStatusMonitor.tsx - MEDIUM-HIGH IMPACT
Resource Profile:

- CPU: 10-20% from canvas rendering
- GPU: Moderate (2D canvas acceleration)
- Memory: Low (60 data points buffer)
  Critical Sections:
  Lines 66-137: Animation Loop
  const draw = () => {
  // ... canvas drawing logic ...
  animationFrameId = requestAnimationFrame(draw); // 60 FPS continuous
  };
  draw();
- Impact: Runs at 60fps continuously, even when tab not visible
- Drawing Operations:
  - Lines 71: clearRect every frame
  - Lines 79-88: Grid drawing (4 lines)
  - Lines 100-125: Chart with gradients (60 iterations)
  - Lines 128-135: Text rendering
    Lines 54-64: Data Sampling Interval
    const dataInterval = setInterval(() => {
    const delta = countRef.current - prevCountRef.current;
    // ... push new data point every 500ms
    }, 500);
    Canvas Resizing (Lines 47-51):
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width _ dpr; // High-DPI scaling
    canvas.height = rect.height _ dpr;
    ctx.scale(dpr, dpr);
- Impact: Double memory on retina displays

---

MODERATE IMPACT ðŸŸ¡
vite.config.ts - DEV MODE ONLY
Resource Profile:

- CPU: 20-40% during HMR (Hot Module Replacement)
- Memory: 100-300MB for dev server
- Disk: File watching overhead
  Configuration Analysis:
- Line 7: @vitejs/plugin-react-swc - Uses SWC (Rust-based, fast but memory hungry)
- Lines 9-20: Proxy configuration forwards /api and /socket.io to port 3000
- Issue: --host flag exposes to network, increasing overhead
  Why bun run dev is slow:

1. SWC compilation in real-time
2. File system watching with fs.watch
3. Proxy middleware processing
4. Source map generation
5. CSS processing (Tailwind v4)

---

src/App.tsx - MODERATE IMPACT
Resource Profile:

- CPU: 5-10% from re-renders
- Memory: 20-50MB (depends on device list size)
  Optimization Strategies Used (Good):
- Lines 16-21: Memoized components prevent cascading re-renders
- Lines 58-96: useMemo for expensive stats calculation
- Lines 28-30: useCallback for log function
  Potential Issues:
- Lines 44-45: completedCount updates trigger swarmStats recalculation (line 83)
- Lines 142-180: All memoized components still receive new props on every parent render

---

src/components/dashboard/LiveTerminal.tsx - LOW-MODERATE
Resource Profile:

- CPU: 2-5% from scrolling animation
- Memory: Grows with log history (capped at 19 lines)
  Lines 15-19: Scroll Effect
  useEffect(() => {
  if (logsEndRef.current) {
  logsEndRef.current.scrollIntoView({ behavior: "smooth" });
  }
  }, [logs]); // Runs on every new log entry

---

LOW IMPACT ðŸŸ¢
| File | Impact | Notes |
|------|--------|-------|
| main.tsx | Minimal | Simple React mount |
| usePersistentIdentity.ts | Minimal | One-time localStorage read |
| Card.tsx | Minimal | Presentational |
| ThemeToggle.tsx | Minimal | User-triggered only |
| index.css | Low | Some CSS animations (grain effect) |

---

4. CPU USAGE BREAKDOWN (Development Mode)
   When Running bun run dev:
   Total CPU Usage: 40-150% (multi-core)
   Breakdown by Component:
   â”œâ”€â”€ Vite Dev Server 20-40%
   â”‚ â”œâ”€â”€ SWC Compilation 10-20%
   â”‚ â”œâ”€â”€ File Watching 5-10%
   â”‚ â”œâ”€â”€ HMR Processing 5-10%
   â”‚ â””â”€â”€ Proxy Middleware 2-5%
   â”‚
   â”œâ”€â”€ Web Workers 30-100% (INTENTIONAL)
   â”‚ â”œâ”€â”€ Thread Pool 20-80%
   â”‚ â”œâ”€â”€ GPU Compute 0-50% (if WebGPU available)
   â”‚ â””â”€â”€ CPU Math Kernels 10-50%
   â”‚
   â”œâ”€â”€ React/UI 10-25%
   â”‚ â”œâ”€â”€ Canvas Animation 10-20%
   â”‚ â”œâ”€â”€ State Updates 3-8%
   â”‚ â”œâ”€â”€ Socket.io Events 2-5%
   â”‚ â””â”€â”€ Component Rendering 1-3%
   â”‚
   â””â”€â”€ Browser Overhead 5-10%
   â”œâ”€â”€ Garbage Collection 2-5%
   â”œâ”€â”€ DOM Updates 2-4%
   â””â”€â”€ Event Loop 1-2%

---

5. SPECIFIC BOTTLENECKS IDENTIFIED
   Bottleneck 1: Continuous Animation (GpuStatusMonitor.tsx:67)
   const draw = () => {
   // ... draws every frame
   animationFrameId = requestAnimationFrame(draw); // NEVER STOPS
   };
   Issue: Animation runs even when:

- Tab is backgrounded
- Swarm is IDLE
- Window is minimized
  Fix Strategy:
  // Use Page Visibility API
  document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
  cancelAnimationFrame(animationFrameId);
  } else {
  draw();
  }
  });

---

Bottleneck 2: Unnecessary State Sync (useComputeSwarm.ts:101-112)
setInterval(() => {
setCompletedCount((prev) => {
if (prev !== completedCountRef.current) {
return completedCountRef.current;
}
return prev;
});
}, 500);
Issue: Checks state every 500ms even when no jobs complete
Fix Strategy:
// Only update when value actually changes
useEffect(() => {
const checkInterval = setInterval(() => {
if (completedCountRef.current !== lastEmittedRef.current) {
setCompletedCount(completedCountRef.current);
lastEmittedRef.current = completedCountRef.current;
}
}, 500);
}, []);

---

Bottleneck 3: Canvas Full Redraw Every Frame (GpuStatusMonitor.tsx:71-125)
Issue: Redraws entire 60-point chart at 60fps (3600 operations/sec)
Optimization Options:

1. Double Buffering: Draw to offscreen canvas, swap
2. Incremental Drawing: Only draw new data points
3. Reduce FPS: Cap at 30fps for charts (sufficient for data viz)
4. WebGL: For truly high-performance rendering

---

Bottleneck 4: Worker Thread Overhead (worker.ts:41-186)
Issue: Each sub-worker is created via Blob URL
const blob = new Blob([code], { type: "application/javascript" });
const objectUrl = URL.createObjectURL(blob);
return { worker: new Worker(objectUrl), objectUrl };
Memory Impact:

- Each worker context: ~5-10MB
- Thread pool default: LOGICAL_CORES \* 0.3 (e.g., 8 cores = 2-3 workers)
- Total: 15-30MB just for worker overhead

---

Bottleneck 5: Vite SWC in Bun (vite.config.ts:7)
Issue: You're using Bun runtime with SWC (Rust-based) compiler

- SWC is optimized for Node.js
- Bun has its own native bundler that's faster
- Running SWC under Bun adds translation overhead

---

6. OPTIMIZATION RECOMMENDATIONS
   Immediate Wins (Low Effort, High Impact)
1. Pause Canvas When Idle
   - Add visibility checking to GpuStatusMonitor
   - Pause animation when status === 'IDLE'
1. Throttle State Updates
   - Reduce UI sync interval from 500ms to 1000-2000ms
   - Use requestAnimationFrame + timestamp checking
1. Optimize Vite Dev
   - Use bunx --bun vite instead of bun run dev (native Bun compilation)
   - Or switch to npm run dev with Node for SWC optimization
1. Add Worker Throttling
   - Respect throttle setting even in dev mode
   - Add devMode: low-power option
     Medium-Term Improvements
1. Canvas Optimization
   - Implement dirty-rectangle rendering
   - Use will-change: contents CSS hint
   - Consider switching to WebGL for complex charts
1. Web Worker Pool
   - Pre-allocate workers at startup
   - Reuse workers instead of terminating/creating
   - Use SharedArrayBuffer for zero-copy communication
1. React Optimizations
   - Add React.memo to pure components (already partially done)
   - Virtualize device list if >50 devices
   - Use useDeferredValue for non-urgent updates
     Long-Term Architecture
1. Separate Dev/Prod Worker Behavior
   - Workers auto-pause in dev mode when no activity
   - Separate development bundle without heavy compute
1. Replace Canvas with WebGL
   - Use Three.js or raw WebGL for velocity charts
   - GPU-accelerated rendering reduces CPU load
1. Bun-Native Build
   - Create Bun-native worker implementation
   - Use Bun's built-in bundler instead of Vite

---

7. FILE-BY-FILE OPTIMIZATION CHECKLIST
   High Priority

- [ ] GpuStatusMonitor.tsx: Add visibility-aware animation pausing
- [ ] useComputeSwarm.ts: Reduce sync interval, optimize effect deps
- [ ] worker.ts: Add dev-mode throttling, optimize thread pool scaling
      Medium Priority
- [ ] vite.config.ts: Evaluate Bun-native alternatives
- [ ] App.tsx: Add useDeferredValue for stats
- [ ] LiveTerminal.tsx: Virtualize long log lists
      Low Priority
- [ ] index.css: Optimize grain texture (CSS containment)
- [ ] SwarmDashboard.tsx: Virtualize device list
- [ ] ThemeToggle.tsx: Preload theme to avoid flash

---

8. MEASURING IMPROVEMENTS
   Use these Chrome DevTools metrics:
1. Performance Tab: Record 10 seconds of activity
   - Look for long frames (>16ms)
   - Check "Scripting" vs "Rendering" time
1. Memory Tab: Take heap snapshots
   - Monitor Worker-related memory
   - Check for detached DOM nodes
1. Network Tab: Monitor WebSocket traffic
   - Batch job requests should dominate
   - Watch for unnecessary polling
1. Bun Built-in Profiler:
   bun --inspect run dev

---

9. SUMMARY
   Your CPU usage is expected behavior for a distributed computing client that:

- Runs continuous mathematical computations
- Maintains real-time WebSocket connections
- Renders high-frequency data visualizations
- Uses Vite's development server with HMR
  The heavy load is primarily from:

1. Intentional compute work (Web Workers) - 70-100%
2. Vite dev server overhead - 20-40%
3. Canvas animation - 10-20%
   Quick fixes to try immediately:
4. Switch to bunx --bun vite for native Bun performance
5. Add if (status === 'IDLE') return null; to GpuStatusMonitor when not running
6. Reduce setInterval in useComputeSwarm from 500ms to 2000ms
</file>

<file path="client/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="client/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="client/public/favicon.svg">
<svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="leg-grad" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#ff7d54" />
      <stop offset="100%" style="stop-color:#ffb09c" />
    </linearGradient>
    <filter id="shadow" x="-20%" y="-20%" width="150%" height="150%">
      <stop offset="0%" style="stop-color:#ff7d54" />
      <feDropShadow dx="0" dy="2" stdDeviation="2" flood-opacity="0.2"/>
    </filter>
  </defs>
  <circle cx="50" cy="50" r="45" fill="#fcfcfd" stroke="rgba(0,0,0,0.05)" stroke-width="2" />
  <path d="M35 25L50 45L65 25" stroke="url(#leg-grad)" stroke-width="8" stroke-linecap="round" stroke-linejoin="round" filter="url(#shadow)"/>
  <path d="M50 45V75" stroke="url(#leg-grad)" stroke-width="8" stroke-linecap="round" filter="url(#shadow)"/>
  <circle cx="50" cy="45" r="5" fill="#1a1a1e" />
</svg>
</file>

<file path="client/public/logo.svg">
<svg width="512" height="512" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="metal" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#fcfcfd" />
      <stop offset="100%" style="stop-color:#d1d5db" />
    </linearGradient>
    <radialGradient id="glow" cx="50%" cy="50%" r="50%">
      <stop offset="0%" style="stop-color:#ff7d54" />
      <stop offset="100%" style="stop-color:#ffb09c" />
    </radialGradient>
    <filter id="neo-shadow" x="-20%" y="-20%" width="150%" height="150%">
      <feDropShadow dx="0" dy="12" stdDeviation="15" flood-color="#ff7d54" flood-opacity="0.2"/>
    </filter>
  </defs>

  <circle cx="256" cy="256" r="220" fill="url(#metal)" stroke="#ffffff" stroke-width="8" />
  <circle cx="256" cy="256" r="200" fill="transparent" stroke="rgba(0,0,0,0.03)" stroke-width="20" />

  <g filter="url(#neo-shadow)">
    <path d="M256 120V256M256 256L140 380M256 256L372 380" stroke="#1a1a1e" stroke-width="48" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M256 130V256M256 256L150 370M256 256L362 370" stroke="url(#glow)" stroke-width="24" stroke-linecap="round" stroke-linejoin="round"/>
  </g>

  <circle cx="256" cy="256" r="50" fill="#1a1a1e" />
  <circle cx="256" cy="256" r="30" fill="url(#glow)">
    <animate attributeName="opacity" values="0.7;1;0.7" dur="2s" repeatCount="indefinite" />
  </circle>
</svg>
</file>

<file path="client/README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is currently not compatible with SWC. See [this issue](https://github.com/vitejs/vite-plugin-react/issues/428) for tracking the progress.

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
</file>

<file path="client/src/components/Card.tsx">
import { type ReactNode } from "react";
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

interface CardProps {
  children: ReactNode;
  className?: string;
  variant?: "flat" | "elevated" | "glass";
}

export const Card = ({
  children,
  className,
  variant = "elevated",
}: CardProps) => {
  const variants = {
    flat: "bg-surface-white border border-border-soft",
    elevated: "soft-card",
    glass: "bg-white/70 backdrop-blur-md border border-white/20 shadow-lg",
  };

  return <div className={cn(variants[variant], className)}>{children}</div>;
};
</file>

<file path="client/src/core/theme.css">
@import "tailwindcss";

@theme {
  /* Neuronix Color Palette */
  --color-brand-orange: #ff7d54;
  --color-brand-peach: #ffb09c;
  --color-surface-white: #fcfcfd;
  --color-surface-muted: #f3f4f6;
  --color-text-main: #1a1a1e;
  --color-text-muted: #6b7280;
  --color-border-soft: rgba(0, 0, 0, 0.05);

  /* Elevation (Neumorphism) */
  --shadow-soft-depth:
    0 10px 25px -5px rgba(0, 0, 0, 0.03), 0 8px 10px -6px rgba(0, 0, 0, 0.03);
  --shadow-card: 0 20px 40px -12px rgba(0, 0, 0, 0.05);
  --shadow-inset: inset 0 2px 4px 0 rgba(0, 0, 0, 0.05);

  /* Radii */
  --radius-xl: 24px;
  --radius-2xl: 32px;
}

:root {
  background-color: var(--color-surface-muted);
  color: var(--color-text-main);
  font-family: "Inter", sans-serif;
}

@layer components {
  /* The Neuronix Soft Card */
  .soft-card {
    @apply bg-surface-white border border-border-soft shadow-card rounded-2xl p-6 transition-all;
  }

  /* Modern Scrollbar */
  ::-webkit-scrollbar {
    width: 6px;
  }
  ::-webkit-scrollbar-thumb {
    @apply bg-gray-200 rounded-full hover:bg-gray-300;
  }
}
@keyframes scan {
  0% {
    top: 10%;
  }
  50% {
    top: 90%;
  }
  100% {
    top: 10%;
  }
}
</file>

<file path="client/src/features/dashboard/JobGauge.tsx">
import { Card } from "../../components/Card";

interface Props {
  readonly total: number;
  readonly completed: number;
}

export const JobGauge = ({ total, completed }: Props) => {
  const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
  const radius = 45;
  const circumference = 2 * Math.PI * radius;
  const strokeDashoffset = circumference - (percentage / 100) * circumference;

  return (
    <Card className="flex flex-col items-center justify-center p-6 bg-surface-white">
      <div className="relative w-40 h-40 mb-4">
        {/* Rotated SVG container to start from 12 o'clock */}
        <svg className="w-full h-full -rotate-90" viewBox="0 0 128 128">
          {/* Background Track */}
          <circle
            cx="64"
            cy="64"
            r={radius}
            stroke="#f3f4f6"
            strokeWidth="12"
            fill="transparent"
            strokeLinecap="round"
          />
          {/* Active Progress */}
          <circle
            cx="64"
            cy="64"
            r={radius}
            stroke="#ff7d54"
            strokeWidth="12"
            fill="transparent"
            strokeDasharray={circumference}
            strokeDashoffset={strokeDashoffset}
            strokeLinecap="round"
            className="transition-all duration-1000 ease-out"
          />
        </svg>

        {/* Center Text (Counter-rotated to stay upright) */}
        <div className="absolute inset-0 flex flex-col items-center justify-center">
          <span className="text-3xl font-black text-text-main">{total}</span>
          <span className="text-[10px] font-bold text-text-muted uppercase tracking-widest">
            Total Jobs
          </span>
        </div>
      </div>

      <div className="w-full space-y-2 px-2">
        <div className="flex justify-between text-[10px] font-bold text-text-muted uppercase">
          <span>Progress</span>
          <span>{percentage}%</span>
        </div>
        <div className="w-full h-2 bg-gray-100 rounded-full overflow-hidden shadow-inner">
          <div
            className="h-full bg-brand-orange transition-all duration-500"
            style={{ width: `${percentage}%` }}
          />
        </div>
      </div>
    </Card>
  );
};
</file>

<file path="client/src/features/dashboard/ResourceStats.tsx">
import { Database, Zap, Activity } from "lucide-react";
import { Card } from "../../components/Card";
import { type SwarmStats } from "../../core/types";

interface Props {
  stats: SwarmStats;
  onlineCount: number;
}

export const ResourceStats = ({ stats, onlineCount }: Props) => {
  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-5">
      <StatItem
        label="Online Nodes"
        value={onlineCount}
        icon={<Database size={18} className="text-blue-600" />}
        gradient="from-blue-50 to-blue-100/50"
        border="border-blue-100"
      />
      <StatItem
        label="Active Jobs"
        value={stats.activeJobs}
        icon={<Activity size={18} className="text-brand-orange" />}
        gradient="from-orange-50 to-orange-100/50"
        border="border-orange-100"
      />
      <StatItem
        label="Pending"
        value={stats.pendingJobs}
        icon={<Zap size={18} className="text-purple-600" />}
        gradient="from-purple-50 to-purple-100/50"
        border="border-purple-100"
      />
    </div>
  );
};

const StatItem = ({ label, value, icon, gradient, border }: any) => (
  <Card
    className={`p-5 bg-linear-to-br ${gradient} border ${border} hover:-translate-y-1 transition-transform duration-300 shadow-sm`}
  >
    <div className="flex justify-between items-start">
      <div>
        <p className="text-[10px] font-black text-text-muted uppercase tracking-widest mb-2">
          {label}
        </p>
        <p className="text-3xl font-black text-text-main tracking-tight">
          {value.toLocaleString()}
        </p>
      </div>
      <div className="p-3 bg-white rounded-xl shadow-sm border border-white/50">
        {icon}
      </div>
    </div>
  </Card>
);
</file>

<file path="client/src/features/dashboard/ThrottleControl.tsx">
import { Card } from "../../components/Card";
import { Cpu, Server, Box } from "lucide-react"; // Added Box for GPU icon

interface Props {
  value: number;
  onChange: (val: number) => void;
  totalCores: number;
  totalMemory: number;
  totalGPUs: number; // New Prop
}

export const ThrottleControl = ({
  value,
  onChange,
  totalCores = 0,
  totalMemory = 0,
  totalGPUs = 0,
}: Props) => {
  const percent = value / 100;

  return (
    <Card className="relative overflow-hidden group p-5 bg-surface-white">
      <div className="flex justify-between items-center mb-6">
        <div>
          <h3 className="font-bold text-sm text-text-muted uppercase tracking-widest">
            Global Allocation
          </h3>
          <p className="text-2xl font-black text-text-main">{value}%</p>
        </div>

        {/* Resource Badges */}
        <div className="flex flex-wrap gap-2 justify-end max-w-45">
          {/* CPU */}
          <div className="flex items-center gap-1.5 bg-gray-50 px-2 py-1 rounded-lg border border-gray-100">
            <Cpu size={12} className="text-brand-orange" />
            <span className="text-[10px] font-bold text-gray-600">
              {Math.round(totalCores * percent)} / {totalCores}
            </span>
          </div>

          {/* RAM */}
          <div className="flex items-center gap-1.5 bg-gray-50 px-2 py-1 rounded-lg border border-gray-100">
            <Server size={12} className="text-blue-500" />
            <span className="text-[10px] font-bold text-gray-600">
              {Math.round(totalMemory * percent)} GB
            </span>
          </div>

          {/* GPU (New) */}
          <div
            className={`flex items-center gap-1.5 px-2 py-1 rounded-lg border ${totalGPUs > 0 ? "bg-purple-50 border-purple-100" : "bg-gray-50 border-gray-100 opacity-50"}`}
          >
            <Box
              size={12}
              className={totalGPUs > 0 ? "text-purple-600" : "text-gray-400"}
            />
            <span
              className={`text-[10px] font-bold ${totalGPUs > 0 ? "text-purple-700" : "text-gray-400"}`}
            >
              {totalGPUs} GPU{totalGPUs !== 1 ? "s" : ""}
            </span>
          </div>
        </div>
      </div>

      <input
        type="range"
        min="10"
        max="100"
        step="10"
        value={value}
        onChange={(e) => onChange(parseInt(e.target.value))}
        className="w-full h-2 bg-gray-100 rounded-lg appearance-none cursor-pointer accent-brand-orange transition-all hover:bg-gray-200"
      />

      <div className="flex justify-between mt-3 text-[10px] font-bold text-text-muted uppercase tracking-tighter">
        <span>Eco Mode</span>
        <span>Balanced</span>
        <span>Max Performance</span>
      </div>
    </Card>
  );
};
</file>

<file path="client/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="client/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="Resource_share-COLAB.ipynb">
{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "uh_ss-Sq2pN9"
      },
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "5CmKm_o41_8T",
        "outputId": "cc41c109-c90e-4631-a457-0c804a1f8be1"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "\u001b[?25l   \u001b[90mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\u001b[0m \u001b[32m0.0/82.1 kB\u001b[0m \u001b[31m?\u001b[0m eta \u001b[36m-:--:--\u001b[0m\r\u001b[2K   \u001b[90mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\u001b[0m \u001b[32m82.1/82.1 kB\u001b[0m \u001b[31m4.3 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25h\u001b[?25l   \u001b[90mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\u001b[0m \u001b[32m0.0/59.8 kB\u001b[0m \u001b[31m?\u001b[0m eta \u001b[36m-:--:--\u001b[0m\r\u001b[2K   \u001b[90mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\u001b[0m \u001b[32m59.8/59.8 kB\u001b[0m \u001b[31m4.0 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25h"
          ]
        }
      ],
      "source": [
        "!pip install python-socketio --quiet\n"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# @title Ostrich Legs Worker Node (v4.0 - Adaptive Benchmark & Polling)\n",
        "# @markdown Run this cell to join the compute swarm!\n",
        "\n",
        "import sys\n",
        "import subprocess\n",
        "import time\n",
        "import json\n",
        "import os\n",
        "import uuid\n",
        "import threading\n",
        "import platform\n",
        "import numpy as np\n",
        "\n",
        "# --- 1. INSTALL DEPENDENCIES ---\n",
        "try:\n",
        "    import socketio\n",
        "except ImportError:\n",
        "    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"python-socketio[client]\", \"requests\"])\n",
        "    import socketio\n"
      ],
      "metadata": {
        "id": "WhzaxOm_QbZA"
      },
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# Try importing Torch for GPU support\n",
        "HAS_GPU = False\n",
        "try:\n",
        "    import torch\n",
        "    if torch.cuda.is_available():\n",
        "        HAS_GPU = True\n",
        "        print(f\"ðŸš€ GPU DETECTED: {torch.cuda.get_device_name(0)}\")\n",
        "    else:\n",
        "        print(\"âš ï¸ GPU not found. Falling back to CPU.\")\n",
        "except ImportError:\n",
        "    print(\"âš ï¸ PyTorch not installed. Falling back to CPU.\")\n"
      ],
      "metadata": {
        "id": "VTIB47esQgO7"
      },
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# --- 4. KERNELS ---\n",
        "\n",
        "def run_stress_test(iterations):\n",
        "    \"\"\"CPU Bound Stress Test\"\"\"\n",
        "    start = time.time()\n",
        "    count = int(iterations or 100000)\n",
        "    # CPU heavy vector math\n",
        "    x = np.random.rand(int(count/100))\n",
        "    np.sin(x) * np.sqrt(x)\n",
        "    return float(time.time() - start)\n",
        "\n",
        "def run_matrix_mul(data):\n",
        "    \"\"\"Hybrid GPU/CPU Matrix Multiplication\"\"\"\n",
        "    start = time.time()\n",
        "\n",
        "    # Extract dimensions (default 300 for normal jobs)\n",
        "    size = int(data.get('size', 300))\n",
        "\n",
        "    if HAS_GPU:\n",
        "        # GPU PATH\n",
        "        a = torch.rand(size, size, device='cuda')\n",
        "        b = torch.rand(size, size, device='cuda')\n",
        "        torch.matmul(a, b)\n",
        "        torch.cuda.synchronize()\n",
        "    else:\n",
        "        # CPU PATH\n",
        "        a = np.random.rand(size, size)\n",
        "        b = np.random.rand(size, size)\n",
        "        np.dot(a, b)\n",
        "\n",
        "    return float(time.time() - start)\n",
        "\n",
        "def process_job(job):\n",
        "    global last_work_time\n",
        "    if not sio.connected: return False\n",
        "\n",
        "    job_id = job['id']\n",
        "    job_type = job['type']\n",
        "    job_data = job['data']\n",
        "\n",
        "    try:\n",
        "        duration = 0\n",
        "        if job_type == 'MATH_STRESS':\n",
        "            duration = run_stress_test(job_data.get('iterations', 50000))\n",
        "        elif job_type == 'MAT_MUL':\n",
        "            duration = run_matrix_mul(job_data)\n",
        "\n",
        "        last_work_time = time.time()\n",
        "\n",
        "        if sio.connected:\n",
        "            sio.emit('job:complete', {\n",
        "                'chunkId': job_id,\n",
        "                'result': 'Calculated',\n",
        "                'durationMs': duration * 1000,\n",
        "                'workerId': DEVICE_ID,\n",
        "                'timestamp': time.time() * 1000\n",
        "            })\n",
        "            return True\n",
        "    except Exception as e:\n",
        "        print(f\"\\nJob Error: {e}\")\n",
        "        if sio.connected:\n",
        "            sio.emit('job:complete', {\n",
        "                'chunkId': job_id,\n",
        "                'error': str(e),\n",
        "                'workerId': DEVICE_ID\n",
        "            })\n",
        "        return False\n",
        "\n",
        "# --- 5. EVENTS ---\n",
        "\n",
        "@sio.event\n",
        "def connect():\n",
        "    print(f\"\\nâœ… Connected! ID: {DEVICE_ID}\")\n",
        "\n",
        "    # Detect System Info\n",
        "    import multiprocessing\n",
        "    cores = multiprocessing.cpu_count()\n",
        "    mem = 12\n",
        "\n",
        "    sio.emit('device:register', {\n",
        "        'name': DEVICE_NAME,\n",
        "        'type': 'COLAB',\n",
        "        'capabilities': {\n",
        "            'cpuCores': cores,\n",
        "            'memoryGB': mem,\n",
        "            'gpuAvailable': HAS_GPU,\n",
        "            # If GPU, we can handle huge concurrency because CUDA is parallel\n",
        "            'maxConcurrency': cores * 4 if HAS_GPU else cores,\n",
        "            'supportedJobs': ['MATH_STRESS', 'MAT_MUL']\n",
        "        }\n",
        "    })\n",
        "\n",
        "@sio.on('job:batch')\n",
        "def on_batch(jobs):\n",
        "    global is_working\n",
        "    is_working = True\n",
        "    print(f\"\\rðŸ“¦ Batch: {len(jobs)} | GPU: {'ON' if HAS_GPU else 'OFF'}\", end=\"\")\n",
        "\n",
        "    for job in jobs:\n",
        "        if not sio.connected: break\n",
        "        process_job(job)\n",
        "\n",
        "    is_working = False\n",
        "\n",
        "    # Pull next batch\n",
        "    if sio.connected:\n",
        "        sio.emit('job:request_batch')\n",
        "\n",
        "@sio.on('cmd:run_benchmark')\n",
        "def on_benchmark():\n",
        "    print(\"\\nðŸš€ Starting Benchmark...\", end=\"\")\n",
        "    try:\n",
        "        start = time.time()\n",
        "        score = 0\n",
        "\n",
        "        if HAS_GPU:\n",
        "            # CASE A: GPU (Heavy Matrix Mul)\n",
        "            size = 1000\n",
        "            a = torch.rand(size, size, device='cuda')\n",
        "            b = torch.rand(size, size, device='cuda')\n",
        "            torch.matmul(a, b)\n",
        "            torch.cuda.synchronize()\n",
        "\n",
        "            duration = time.time() - start\n",
        "            # Formula: 2 Billion Ops / Seconds\n",
        "            score = int(2000000000 / (duration + 0.00001))\n",
        "            print(f\" [GPU MODE] Score: {score:,}\")\n",
        "\n",
        "        else:\n",
        "            # CASE B: CPU (Simple Loop)\n",
        "            # 5 Million Iterations\n",
        "            count = 5000000\n",
        "            x = np.random.rand(int(count/100))\n",
        "            np.sin(x) * np.sqrt(x)\n",
        "\n",
        "            duration = time.time() - start\n",
        "            # Formula: Iterations / Seconds\n",
        "            score = int(count / (duration + 0.00001))\n",
        "            print(f\" [CPU MODE] Score: {score:,}\")\n",
        "\n",
        "        sio.emit('benchmark:result', {'score': score})\n",
        "\n",
        "    except Exception as e:\n",
        "        print(f\" Benchmark Failed: {e}\")\n",
        "\n",
        "@sio.event\n",
        "def disconnect():\n",
        "    print(\"\\nâŒ Disconnected from server.\")\n",
        "\n",
        "# --- 6. BACKGROUND POLLER ---\n",
        "def poller_loop():\n",
        "    while True:\n",
        "        try:\n",
        "            # If idle for >1s, ask for work\n",
        "            if sio.connected and not is_working:\n",
        "                if time.time() - last_work_time > 1.0:\n",
        "                    sio.emit('job:request_batch')\n",
        "            time.sleep(1.0)\n",
        "        except:\n",
        "            pass\n"
      ],
      "metadata": {
        "id": "ou5a0ug1Qsqj"
      },
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# --- 3. IDENTITY ---\n",
        "id_file = \"device_identity.txt\"\n",
        "if os.path.exists(id_file):\n",
        "    with open(id_file, \"r\") as f:\n",
        "        DEVICE_ID = f.read().strip()\n",
        "else:\n",
        "    DEVICE_ID = f\"colab-{str(uuid.uuid4())[:8]}\"\n",
        "    with open(id_file, \"w\") as f:\n",
        "        f.write(DEVICE_ID)\n",
        "\n",
        "sio = socketio.Client(reconnection=True, reconnection_delay=5)\n",
        "is_working = False\n",
        "last_work_time = time.time()\n"
      ],
      "metadata": {
        "id": "3x1KtBgcQvKl"
      },
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# --- 2. CONFIGURATION ---\n",
        "SERVER_URL = \"https://public-pride-bought-sys.trycloudflare.com/\" # @param {type:\"string\"}\n",
        "DEVICE_NAME = \"Colab-Node-01\" # @param {type:\"string\"}\n",
        "\n",
        "\n",
        "\n",
        "# --- 7. MAIN START ---\n",
        "def main():\n",
        "    print(f\"ðŸš€ Initializing Worker {DEVICE_ID}...\")\n",
        "\n",
        "    # Start Poller\n",
        "    t = threading.Thread(target=poller_loop, daemon=True)\n",
        "    t.start()\n",
        "\n",
        "    # Auth URL\n",
        "    auth_url = f\"{SERVER_URL}?persistentId={DEVICE_ID}\"\n",
        "\n",
        "    while True:\n",
        "        try:\n",
        "            if not sio.connected:\n",
        "                print(f\"Connecting to {SERVER_URL}...\")\n",
        "                sio.connect(auth_url, transports=['websocket', 'polling'])\n",
        "                sio.wait()\n",
        "        except KeyboardInterrupt:\n",
        "            print(\"\\nStopping...\")\n",
        "            break\n",
        "        except Exception as e:\n",
        "            print(f\"Connection Error: {e}\")\n",
        "            time.sleep(5)\n"
      ],
      "metadata": {
        "id": "5zJYP80nQ3Z8"
      },
      "execution_count": 1,
      "outputs": []
    },
    {
      "cell_type": "code",
      "execution_count": 2,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 158
        },
        "id": "dfTz0baT1GI1",
        "collapsed": true,
        "outputId": "eaf27aba-a478-4785-e2b5-82adfa6fcdbd"
      },
      "outputs": [
        {
          "output_type": "error",
          "ename": "NameError",
          "evalue": "name 'main' is not defined",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
            "\u001b[0;32m/tmp/ipython-input-217905245.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0;32mif\u001b[0m \u001b[0m__name__\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;34m'__main__'\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 2\u001b[0;31m     \u001b[0mmain\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
            "\u001b[0;31mNameError\u001b[0m: name 'main' is not defined"
          ]
        }
      ],
      "source": [
        "if __name__ == '__main__':\n",
        "    main()"
      ]
    },
    {
      "cell_type": "code",
      "source": [],
      "metadata": {
        "id": "_Fi0UHRcQ_ws"
      },
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "gpuType": "T4"
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    },
    "accelerator": "GPU"
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
</file>

<file path="server/src/managers/JobScheduler.ts">
import { type Job, type DeviceInfo } from "../core/types";

export class JobScheduler {
  private jobQueue: Job[] = [];

  constructor() {
    // Generate dummy jobs periodically (Low overhead: just pushing objects)
    setInterval(() => this.generateJobs(), 2000);
  }

  private generateJobs() {
    if (this.jobQueue.length > 500) return; // Prevent memory overflow

    // Create 50 lightweight job objects
    for (let i = 0; i < 50; i++) {
      const isGpuTask = Math.random() > 0.7; // 30% GPU tasks
      this.jobQueue.push({
        id: `job-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
        type: isGpuTask ? "MAT_MUL" : "MATH_STRESS",
        complexity: Math.floor(Math.random() * 10) + 1,
        data: isGpuTask ? { size: 1024 } : { iterations: 100000 },
      });
    }
  }

  public getJobForDevice(device: DeviceInfo): Job | null {
    if (device.status === "DISABLED" || device.status === "OFFLINE")
      return null;

    // Capability-based Scheduling
    const preferredType = device.capabilities.gpuAvailable
      ? "MAT_MUL"
      : "MATH_STRESS";

    // Find best match
    const index = this.jobQueue.findIndex((j) => j.type === preferredType);

    if (index !== -1) {
      return this.jobQueue.splice(index, 1)[0];
    }

    // Fallback: take any job
    return this.jobQueue.shift() || null;
  }

  public getQueueStats() {
    return {
      pending: this.jobQueue.length,
      active: 0, // In a real DB this would be tracked
    };
  }
}
</file>

<file path="shared/socket/events.ts">
export const SocketEvents = {
  // Connection Lifecycle
  CONNECT: "connect",
  DISCONNECT: "disconnect",
  CONNECTION_ERROR: "connect_error",

  // Identity & Registration
  DEVICE_REGISTER: "device:register",
  DEVICE_READY: "device:ready",
  HEARTBEAT: "heartbeat",

  // Swarm Orchestration
  SWARM_SNAPSHOT: "swarm:snapshot",
  SWARM_SET_STATE: "cmd:set_run_state",
  SWARM_SET_THROTTLE: "cmd:set_throttle",
  SWARM_THROTTLE_SYNC: "swarm:throttle_sync",

  // Job Pipeline
  JOB_REQUEST_BATCH: "job:request_batch",
  JOB_BATCH_DISPATCH: "job:batch",
  JOB_COMPLETE: "job:complete",

  // Diagnostics & Terminal
  SYSTEM_LOG: "sys:log",
  BENCHMARK_START: "cmd:run_benchmark",
  BENCHMARK_RESULT: "benchmark:result",
} as const;

export type SocketEvent = (typeof SocketEvents)[keyof typeof SocketEvents];
</file>

<file path="shared/socket/payloads.ts">
import { SwarmRunState, DeviceConnectionStatus, LogLevel } from "./states";

export interface DeviceRegisterPayload {
  name: string;
  capabilities: {
    cpuCores: number;
    memoryGB: number;
    gpuAvailable: boolean;
    gpuName?: string;
  };
}

export interface JobCompletePayload {
  chunkId: string;
  workerId: string;
  result?: any;
  error?: string;
  durationMs?: number;
}

export interface SwarmSnapshotPayload {
  runState: SwarmRunState;
  devices: Record<string, any>; // Will be refined in Phase 2
  stats: {
    totalJobs: number;
    completedJobs: number;
    activeJobs: number;
    globalVelocity: number;
    globalThrottle: number;
  };
}
</file>

<file path="shared/socket/states.ts">
// Strict states for the compute engine
export type SwarmRunState = "IDLE" | "RUNNING" | "PAUSED" | "STOPPED";

// Device lifecycle states
export type DeviceConnectionStatus = "OFFLINE" | "ONLINE" | "BUSY" | "DISABLED";

// Log levels for the Terminal
export type LogLevel = "SYS" | "NET" | "CPU" | "GPU" | "ERR" | "WARN";

export interface SystemLogPayload {
  level: LogLevel;
  message: string;
  timestamp: number;
  source?: string;
}
</file>

<file path="client/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ostrich Legs</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="client/src/core/types.ts">
/** * Strict Domain Model for Ostrich Swarm
 */

export type SwarmStatus = "IDLE" | "RUNNING" | "PAUSED" | "STOPPED";
export type DeviceType = "DESKTOP" | "MOBILE" | "COLAB" | "SERVER";
export type JobType = "MATH_STRESS" | "MAT_MUL" | "TEXT_TOKENIZE";

export interface DeviceCapabilities {
  cpuCores: number;
  memoryGB: number;
  gpuAvailable: boolean;
  gpuName?: string;
}

export interface DeviceInfo {
  id: string;
  name: string;
  type: DeviceType;
  status: "ONLINE" | "BUSY" | "OFFLINE" | "DISABLED";
  capabilities: DeviceCapabilities;
  opsScore: number;
  totalJobsCompleted: number;
  lastHeartbeat: number;
}

export interface SwarmResources {
  totalCores: number;
  totalMemory: number;
  totalGPUs: number;
  onlineCount: number;
}

export interface Job {
  id: string;
  type: JobType;
  complexity: number;
  data: any;
}

export interface SwarmSnapshot {
  runState: SwarmStatus;
  devices: Record<string, DeviceInfo>;
  stats: {
    totalJobs: number;
    activeJobs: number;
    pendingJobs: number;
    completedJobs: number;
    globalVelocity: number;
    globalThrottle?: number;
  };
  resources: SwarmResources;
}
</file>

<file path="client/src/features/dashboard/ActiveSwarm.tsx">
import { Smartphone, Laptop, Server, Cpu, Play } from "lucide-react";
import { Card } from "../../components/Card";
import { type DeviceInfo } from "../../core/types";

interface ActiveSwarmProps {
  devices: DeviceInfo[];
  onBenchmark: () => void;
  onToggle: (id: string, state: boolean) => void;
}

export const ActiveSwarm = ({
  devices,
  onBenchmark,
  onToggle,
}: ActiveSwarmProps) => {
  const getIcon = (type: string) => {
    switch (type) {
      case "MOBILE":
        return <Smartphone size={18} />;
      case "SERVER":
        return <Server size={18} />;
      case "COLAB":
        return <Cpu size={18} />;
      default:
        return <Laptop size={18} />;
    }
  };

  return (
    <Card className="flex flex-col h-full bg-surface-white relative overflow-hidden p-4 sm:p-6">
      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 gap-4">
        <div>
          <h3 className="font-bold text-lg text-text-main">Swarm Nodes</h3>
          <p className="text-xs text-text-muted">Manage active resources</p>
        </div>
        <button
          onClick={onBenchmark}
          className="w-full sm:w-auto flex items-center justify-center gap-2 bg-gray-900 hover:bg-black text-white px-4 py-2.5 rounded-xl text-xs font-bold transition-all active:scale-95 shadow-lg shadow-gray-900/20"
        >
          <Play size={12} fill="currentColor" />
          Benchmark All
        </button>
      </div>

      <div className="flex-1 overflow-y-auto space-y-3 pr-1 custom-scrollbar">
        {devices.map((device) => {
          const isDisabled = device.status === "DISABLED";
          const isLocal =
            device.id.includes("node-") || device.name === "Local Host";

          return (
            <div
              key={device.id}
              className={`flex flex-col md:flex-row md:items-center justify-between p-4 rounded-2xl border transition-all duration-300 gap-4 ${
                isDisabled
                  ? "bg-gray-50 border-transparent opacity-60"
                  : "bg-white border-gray-100 hover:border-brand-orange/30 shadow-sm"
              }`}
            >
              {/* Left Section: Identity */}
              <div className="flex items-center gap-3">
                <div
                  className={`p-3 rounded-xl shrink-0 ${
                    isDisabled
                      ? "bg-gray-200 text-gray-400"
                      : "bg-surface-muted text-brand-orange"
                  }`}
                >
                  {getIcon(device.type)}
                </div>
                <div className="min-w-0">
                  <div className="flex items-center gap-2 flex-wrap">
                    <h4 className="text-sm font-bold text-text-main truncate">
                      {device.name}
                    </h4>
                    {isLocal && (
                      <span className="text-[9px] bg-brand-orange/10 text-brand-orange px-1.5 py-0.5 rounded font-bold border border-brand-orange/20 uppercase tracking-tighter">
                        YOU
                      </span>
                    )}
                  </div>
                  <div className="flex items-center gap-2 mt-0.5">
                    <span
                      className={`w-1.5 h-1.5 rounded-full shrink-0 ${
                        isDisabled
                          ? "bg-gray-400"
                          : device.status === "ONLINE"
                            ? "bg-green-500"
                            : "bg-amber-500"
                      }`}
                    />
                    <span className="text-[10px] font-bold text-text-muted uppercase truncate">
                      {device.status === "ONLINE"
                        ? `${device.capabilities.cpuCores} Cores Online`
                        : device.status}
                    </span>
                  </div>
                </div>
              </div>

              {/* Right Section: Stats & Toggle */}
              <div className="flex items-center justify-between md:justify-end gap-4 md:gap-8 border-t md:border-t-0 pt-3 md:pt-0">
                <div className="flex gap-6">
                  {/* Job Counter */}
                  <div className="text-left md:text-right min-w-15">
                    <div className="font-mono text-sm font-black text-text-main">
                      {device.totalJobsCompleted || 0}
                    </div>
                    <div className="text-[9px] font-bold text-text-muted uppercase tracking-tighter">
                      Jobs
                    </div>
                  </div>

                  {/* OPS Score */}
                  <div className="text-left md:text-right min-w-17.5">
                    <div className="font-mono text-sm font-black text-brand-orange">
                      {device.opsScore > 0
                        ? device.opsScore.toLocaleString()
                        : "---"}
                    </div>
                    <div className="text-[9px] font-bold text-text-muted uppercase tracking-tighter">
                      OPS Score
                    </div>
                  </div>
                </div>

                <button
                  onClick={() => onToggle(device.id, isDisabled)}
                  className={`w-11 h-6 rounded-full p-1 transition-colors relative shrink-0 ${
                    !isDisabled ? "bg-green-500" : "bg-gray-300"
                  }`}
                >
                  <div
                    className={`w-4 h-4 rounded-full bg-white shadow-sm transition-transform duration-200 ${
                      !isDisabled ? "translate-x-5" : "translate-x-0"
                    }`}
                  />
                </button>
              </div>
            </div>
          );
        })}

        {devices.length === 0 && (
          <div className="text-center py-10">
            <p className="text-sm text-text-muted italic">
              Waiting for swarm nodes...
            </p>
          </div>
        )}
      </div>
    </Card>
  );
};
</file>

<file path="client/src/main.tsx">
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./core/theme.css";
import App from "./App.tsx";

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <App />
  </StrictMode>,
);
</file>

<file path="server/package.json">
{
  "name": "ostrich-server",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "bun src/index.ts"
  },
  "dependencies": {
    "cors": "^2.8.6",
    "express": "^5.2.1",
    "http": "^0.0.1-security",
    "socket.io": "^4.8.3"
  },
  "devDependencies": {
    "@types/cors": "^2.8.13",
    "@types/express": "^4.17.17",
    "@types/node": "^25.2.1",
    "ts-node": "^10.9.1",
    "typescript": "^5.1.6"
  }
}
</file>

<file path="server/src/managers/AuthManager.ts">
export class AuthManager {
  private activeTokens = new Map<
    string,
    { swarmId: string; expiresAt: number }
  >();
  private readonly TOKEN_TTL_MS = 15 * 60 * 1000; // Increased to 15m for better UX

  constructor() {
    setInterval(() => this.cleanup(), 30000);
  }

  /**
   * Generates a unique 6-digit alphanumeric token for a specific swarm.
   */
  public generateToken(swarmId: string): string {
    const token = Math.random().toString(36).substring(2, 8).toUpperCase();

    this.activeTokens.set(token, {
      swarmId,
      expiresAt: Date.now() + this.TOKEN_TTL_MS,
    });

    return token;
  }

  /**
   * Validates a token and returns the associated swarmId.
   * This is the "Party Join" mechanism.
   */
  public validateToken(token: string): string | null {
    const data = this.activeTokens.get(token);

    if (!data) return null;

    if (Date.now() > data.expiresAt) {
      this.activeTokens.delete(token);
      return null;
    }

    return data.swarmId;
  }

  private cleanup() {
    const now = Date.now();
    for (const [token, data] of this.activeTokens.entries()) {
      if (now > data.expiresAt) this.activeTokens.delete(token);
    }
  }
}
</file>

<file path="server/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@shared/*": ["../shared/*"]
    },

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  }
}
</file>

<file path="client/package.json">
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.18",
    "clsx": "^2.1.1",
    "framer-motion": "^12.33.0",
    "html5-qrcode": "^2.3.8",
    "lucide-react": "^0.563.0",
    "qrcode.react": "^4.2.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "recharts": "^3.7.0",
    "socket.io-client": "^4.8.3",
    "tailwind-merge": "^3.4.0",
    "tailwindcss": "^4.1.18"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react-swc": "^4.2.2",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}
</file>

<file path="client/src/features/dashboard/SwarmControls.tsx">
import { Play, Pause, Square } from "lucide-react";
import { Card } from "../../components/Card";

interface SwarmControlsProps {
  readonly status: "IDLE" | "RUNNING" | "PAUSED" | "STOPPED";
  readonly onToggle: () => void;
  readonly onStop: () => void;
}

export const SwarmControls = ({
  status,
  onToggle,
  onStop,
}: SwarmControlsProps) => {
  const isRunning = status === "RUNNING";

  return (
    <Card className="p-5 bg-surface-white">
      <h3 className="font-bold text-sm text-text-muted uppercase tracking-widest mb-4">
        Master Control
      </h3>

      <div className="grid grid-cols-2 gap-4">
        {/* Start/Pause: Orange by default, Emerald on Hover */}
        <button
          onClick={() => {
            console.log("CLICKED TOGGLE");
            onToggle();
          }}
          className={`
            h-20 rounded-2xl flex flex-col items-center justify-center gap-2 transition-all duration-200 active:scale-[0.95]
            border group
            ${
              isRunning
                ? "bg-brand-orange/5 border-brand-orange/20 shadow-inner"
                : "bg-surface-white shadow-[6px_6px_12px_#d1d5db,-6px_-6px_12px_#ffffff] border-white hover:bg-emerald-50 hover:border-emerald-100"
            }
          `}
        >
          <div
            className={`p-2 rounded-full transition-colors ${
              isRunning
                ? "bg-brand-orange text-white shadow-[0_0_10px_rgba(255,125,84,0.4)]"
                : "text-text-muted bg-gray-100 group-hover:bg-emerald-100 group-hover:text-emerald-600"
            }`}
          >
            {isRunning ? (
              <Pause size={24} fill="currentColor" />
            ) : (
              <Play size={24} fill="currentColor" className="ml-0.5" />
            )}
          </div>
          <span
            className={`text-[10px] font-black uppercase transition-colors ${
              isRunning
                ? "text-brand-orange"
                : "text-text-muted group-hover:text-emerald-600"
            }`}
          >
            {isRunning ? "Pause Swarm" : "Start Swarm"}
          </span>
        </button>

        {/* Kill Process: Gray by default, Red on Hover */}
        <button
          onClick={() => {
            if (
              window.confirm(
                "KILL PROCESS? This will terminate all active local threads.",
              )
            ) {
              onStop();
            }
          }}
          className={`
            h-20 rounded-2xl flex flex-col items-center justify-center gap-2 transition-all duration-200 active:scale-[0.98]
            border group
            ${
              status === "STOPPED"
                ? "bg-red-50 border-red-200 shadow-inner"
                : "bg-surface-white shadow-[6px_6px_12px_#d1d5db,-6px_-6px_12px_#ffffff] border-white hover:bg-red-50 hover:border-red-100"
            }
          `}
        >
          <div
            className={`p-2 rounded-full transition-colors ${
              status === "STOPPED"
                ? "bg-red-500 text-white"
                : "text-text-muted bg-gray-100 group-hover:bg-red-100 group-hover:text-red-500"
            }`}
          >
            <Square size={24} fill="currentColor" />
          </div>
          <span
            className={`text-[10px] font-black uppercase transition-colors ${
              status === "STOPPED"
                ? "text-red-600"
                : "text-text-muted group-hover:text-red-600"
            }`}
          >
            {status === "STOPPED" ? "System Killed" : "Kill Process"}
          </span>
        </button>
      </div>

      {/* Status LED Panel */}
      <div className="mt-6 flex items-center justify-between bg-black/5 p-3 rounded-xl shadow-inner border border-black/5">
        <span className="text-xs font-bold text-text-muted">System State</span>
        <div className="flex items-center gap-2">
          <div
            className={`w-2 h-2 rounded-full ${
              isRunning
                ? "bg-brand-orange shadow-[0_0_8px_rgba(255,125,84,0.8)]"
                : "bg-red-500"
            }`}
          />
          <span className="font-mono text-xs font-bold text-text-main">
            {status}
          </span>
        </div>
      </div>
    </Card>
  );
};
</file>

<file path="client/src/features/dashboard/VelocityMonitor.tsx">
import { useEffect, useRef } from "react";
import { Card } from "../../components/Card";
import { Activity } from "lucide-react";

interface VelocityMonitorProps {
  readonly velocity: number;
  readonly throttle: number;
}

export const VelocityMonitor = ({
  velocity,
  throttle,
}: VelocityMonitorProps) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const dataRef = useRef<number[]>(new Array(60).fill(0));
  const requestRef = useRef<number>(0);

  const getColor = (val: number) => {
    if (val < 30) return "#22c55e";
    if (val < 70) return "#ff7d54";
    return "#ef4444";
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext("2d", { alpha: false }); // Optimization: No alpha channel for faster clearing
    if (!ctx) return;

    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);

    const animate = () => {
      // Shift data and update with current velocity
      dataRef.current.shift();
      dataRef.current.push(velocity);

      ctx.fillStyle = "#fcfcfd"; // Match surface-white
      ctx.fillRect(0, 0, rect.width, rect.height);

      const activeColor = getColor(throttle);
      const step = rect.width / (dataRef.current.length - 1);
      const dynamicMax = Math.max(Math.max(...dataRef.current) * 1.2, 100);

      // Draw Gradient Path
      ctx.beginPath();
      ctx.moveTo(0, rect.height);
      dataRef.current.forEach((val, i) => {
        const x = i * step;
        const normalized = Math.min(val / dynamicMax, 1);
        const y = rect.height - normalized * rect.height * 0.7 - 20;
        ctx.lineTo(x, y);
      });
      ctx.lineTo(rect.width, rect.height);
      const gradient = ctx.createLinearGradient(0, 0, 0, rect.height);
      gradient.addColorStop(0, `${activeColor}33`);
      gradient.addColorStop(1, `${activeColor}00`);
      ctx.fillStyle = gradient;
      ctx.fill();

      // Draw Stroke
      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.lineJoin = "round";
      ctx.strokeStyle = activeColor;
      dataRef.current.forEach((val, i) => {
        const x = i * step;
        const normalized = Math.min(val / dynamicMax, 1);
        const y = rect.height - normalized * rect.height * 0.7 - 20;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      requestRef.current = requestAnimationFrame(animate);
    };

    const handleVisibilityChange = () => {
      if (document.hidden) {
        cancelAnimationFrame(requestRef.current);
      } else {
        requestRef.current = requestAnimationFrame(animate);
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);
    requestRef.current = requestAnimationFrame(animate);

    return () => {
      cancelAnimationFrame(requestRef.current);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [velocity, throttle]);

  return (
    <Card className="h-80 flex flex-col relative overflow-hidden bg-surface-white border border-border-soft shadow-soft-depth">
      <div className="flex justify-between items-center mb-4 z-10 px-5 pt-5">
        <div>
          <h3 className="font-bold text-lg text-text-main flex items-center gap-2">
            <Activity
              className={throttle > 70 ? "text-red-500" : "text-brand-orange"}
              size={20}
            />
            Live Compute Velocity
          </h3>
          <p className="text-xs text-text-muted mt-1">
            Real-time operations per second
          </p>
        </div>
        <div className="bg-surface-muted/50 px-4 py-2 rounded-xl border border-white/50 shadow-inner backdrop-blur-sm">
          <span
            className="text-3xl font-black tabular-nums tracking-tight"
            style={{ color: getColor(throttle) }}
          >
            {velocity.toLocaleString()}
          </span>
          <span className="text-[10px] font-bold text-text-muted ml-1 uppercase">
            OPS/s
          </span>
        </div>
      </div>
      <div className="flex-1 w-full min-h-0 relative px-5 pb-5">
        <canvas
          ref={canvasRef}
          className="w-full h-full rounded-xl border border-black/5 shadow-inner"
        />
      </div>
    </Card>
  );
};
</file>

<file path="client/src/features/terminal/LiveTerminal.tsx">
import { useEffect, useRef, memo } from "react";
import { Terminal, Activity } from "lucide-react";
import { Card } from "../../components/Card";

interface Props {
  logs: string[];
}

const LogLine = memo(({ log, index }: { log: string; index: number }) => {
  const isErr = log.includes("[ERR]");
  const isSys = log.includes("[SYS]");
  const isNet = log.includes("[NET]");

  return (
    <div className="flex gap-3 leading-relaxed border-b border-gray-100/30 pb-1 last:border-0">
      <span className="text-gray-400 select-none font-bold w-8">
        {(index + 1).toString().padStart(3, "0")}
      </span>
      <span
        className={`font-medium ${isErr ? "text-red-500" : isSys ? "text-blue-600" : isNet ? "text-green-600" : "text-gray-600"}`}
      >
        {log}
      </span>
    </div>
  );
});

LogLine.displayName = "LogLine";

export const LiveTerminal = ({ logs }: Props) => {
  const scrollRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [logs]);

  return (
    <Card className="h-full flex flex-col relative overflow-hidden bg-surface-white border border-border-soft shadow-soft-depth">
      <div className="flex items-center justify-between px-5 py-3 bg-[#e9ecef] border-b border-white rounded-t-xl shadow-sm z-10">
        <div className="flex items-center gap-2.5">
          <Terminal size={12} className="text-text-main" />
          <span className="text-[10px] font-black text-text-main/80 tracking-widest uppercase">
            System Log
          </span>
        </div>
        <div className="flex bg-surface-white px-3 py-1 rounded-lg border border-white/50 shadow-inner">
          <Activity
            size={10}
            className="text-brand-orange animate-pulse mr-2"
          />
          <span className="text-[9px] font-bold text-brand-orange uppercase">
            Realtime
          </span>
        </div>
      </div>

      <div
        ref={scrollRef}
        className="flex-1 p-5 font-mono text-[11px] overflow-y-auto space-y-1 bg-surface-muted/30"
      >
        {logs.length === 0 && (
          <span className="text-gray-400 italic">
            Listening for swarm events...
          </span>
        )}
        {logs.map((log, i) => (
          <LogLine key={i} log={log} index={i} />
        ))}
      </div>
    </Card>
  );
};
</file>

<file path="client/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client", "node"],
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@shared/*": ["../shared/*"]
    },
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="client/src/hooks/usePersistentIdentity.ts">
import { useState, useEffect } from "react";

export const usePersistentIdentity = () => {
  const [identity, setIdentity] = useState({ id: "", name: "" });

  useEffect(() => {
    // 1. Check LocalStorage
    let storedId = localStorage.getItem("ostrich_device_id");
    let storedName = localStorage.getItem("ostrich_device_name");

    // 2. Generate New ID if missing
    if (!storedId) {
      storedId = `node-${Math.random().toString(36).substr(2, 9)}`;
      localStorage.setItem("ostrich_device_id", storedId);
    }

    // 3. Generate Name based on Platform
    if (!storedName) {
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      storedName = isMobile ? "Mobile Node" : "Desktop Node";
      localStorage.setItem("ostrich_device_name", storedName);
    }

    setIdentity({ id: storedId, name: storedName });
  }, []);

  return identity;
};
</file>

<file path="client/src/utils/compute.worker.ts">
/// <reference lib="webworker" />

const TOTAL_CORES = navigator.hardwareConcurrency || 4;
const RESERVED_CORES = TOTAL_CORES > 8 ? 2 : 1;
const LOGICAL_CORES = Math.max(1, TOTAL_CORES - RESERVED_CORES);

const threadPool = new Map();
let throttleLimit = 0.3;
let nextWorkerId = 0;

const WGSL_SHADER = `
@group(0) @binding(0) var<storage, read> matrixA : array<f32>;
@group(0) @binding(1) var<storage, read> matrixB : array<f32>;
@group(0) @binding(2) var<storage, read_write> result : array<f32>;
@group(0) @binding(3) var<uniform> uniforms : vec2<f32>;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
  let index = global_id.x;
  let size = u32(uniforms.x);
  if (index >= size * size) { return; }
  let row = index / size;
  let col = index % size;
  var sum = 0.0;
  for (var k = 0u; k < size; k = k + 1u) {
    sum = sum + matrixA[row * size + k] * matrixB[k * size + col];
  }
  result[index] = sum;
}
`;

const createSubWorker = (_wId: number) => {
  // CRITICAL: This block MUST be pure Vanilla JS. No TS 'as' or types.
  const code = `
    let device = null;
    let computePipeline = null;
    let gpuReady = false;

    const runCpuStress = (iterations) => {
      let sum = 0;
      for (let i = 0; i < (iterations || 100000); i++) {
        sum += Math.sqrt(i) * Math.sin(i);
      }
      return sum;
    };

    async function initWebGPU() {
      if (!navigator.gpu) return false;
      try {
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) return false;
        device = await adapter.requestDevice();
        const shaderModule = device.createShaderModule({ code: \`${WGSL_SHADER}\` });
        computePipeline = device.createComputePipeline({
          layout: 'auto',
          compute: { module: shaderModule, entryPoint: "main" }
        });
        return true;
      } catch(e) { return false; }
    }

    const initPromise = initWebGPU().then(ok => {
      gpuReady = ok;
      self.postMessage({ type: "WORKER_LOG", level: "GPU", message: ok ? "WebGPU Kernel Ready" : "WebGPU Init Failed: Using CPU Fallback" });
    });

    self.onmessage = async (e) => {
      await initPromise;
      const { type, payload } = e.data;

      if (type === "EXECUTE_JOB") {
        const start = performance.now();
        let result = 0;
        try {
          // Actual math execution
          result = runCpuStress(payload.data?.iterations || 100000);
          self.postMessage({ type: "JOB_COMPLETE", chunkId: payload.id, result, durationMs: performance.now() - start });
        } catch (err) {
          self.postMessage({ type: "JOB_ERROR", chunkId: payload.id, error: err.message });
        }
      }

      if (type === "BENCHMARK") {
        const start = performance.now();
        runCpuStress(1000000);
        const score = Math.round(1000 / ((performance.now() - start) / 1000));
        self.postMessage({ type: "BENCHMARK_COMPLETE", score });
      }
    };
  `;
  const blob = new Blob([code], { type: "application/javascript" });
  const objectUrl = URL.createObjectURL(blob);
  const worker = new Worker(objectUrl);

  // Cleanup the URL immediately after the worker is initialized to free memory
  // The worker remains active as the browser has already loaded the script
  URL.revokeObjectURL(objectUrl);

  return { worker, objectUrl: "" }; // objectUrl no longer needed
};

const applyConfig = () => {
  const targetThreadCount = Math.max(
    1,
    Math.floor(LOGICAL_CORES * throttleLimit),
  );
  if (targetThreadCount > threadPool.size) {
    for (let i = threadPool.size; i < targetThreadCount; i++) {
      const wId = nextWorkerId++;
      const { worker, objectUrl } = createSubWorker(wId);
      worker.onmessage = (ev) => self.postMessage(ev.data);
      threadPool.set(wId, { worker, objectUrl, busy: false });
    }
  }
};

applyConfig();

self.onmessage = (e) => {
  const { type, payload } = e.data;
  if (type === "CONFIG_UPDATE") {
    throttleLimit = payload.throttle;
    applyConfig();
    return;
  }

  // Find free worker
  const workers = Array.from(threadPool.values());
  const freeWorker = workers.find((t) => !t.busy) || workers[0]; // Fallback to first if all busy

  if (freeWorker) {
    if (type === "EXECUTE_JOB") freeWorker.busy = true;
    const originalHandler = freeWorker.worker.onmessage;
    freeWorker.worker.onmessage = (ev: any) => {
      freeWorker.busy = false;
      freeWorker.worker.onmessage = originalHandler;
      self.postMessage(ev.data);
    };
    freeWorker.worker.postMessage({ type, payload });
  }
};
</file>

<file path="client/vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";
import tailwindcss from "@tailwindcss/vite";
import path from "path";
// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  server: {
    allowedHosts: true,
    host: true,
    proxy: {
      // Forward all requests starting with /api to the backend
      "/api": {
        target: "http://localhost:3000",
        changeOrigin: true,
      },
      // Also proxy the socket.io connection
      "/socket.io": {
        target: "http://localhost:3000",
        secure: false,
        changeOrigin: true,
        ws: true,
      },
    },
  },
  resolve: {
    alias: {
      // Points @shared to the actual folder outside /client
      "@shared": path.resolve(__dirname, "../shared"),
    },
  },
});
</file>

<file path="server/src/core/types.ts">
// server/src/core/types.ts
export type DeviceType = "DESKTOP" | "MOBILE" | "COLAB" | "SERVER";
export type JobType = "MATH_STRESS" | "MAT_MUL" | "TEXT_TOKENIZE";
// Added REGISTERED to the flow
export type DeviceConnectionStatus =
  | "OFFLINE"
  | "ONLINE"
  | "BUSY"
  | "DISABLED"
  | "REGISTERED";

export interface DeviceCapabilities {
  cpuCores: number;
  memoryGB: number;
  gpuAvailable: boolean;
  gpuName?: string;
}

export interface DeviceInfo {
  id: string;
  name: string;
  type: DeviceType;
  status: DeviceConnectionStatus;
  capabilities: DeviceCapabilities;
  opsScore: number;
  totalJobsCompleted: number;
  lastHeartbeat: number;
  lastUserInteraction: number;
  swarmId?: string;
}

// ... rest of the file remains same
export interface SwarmResources {
  totalCores: number;
  totalMemory: number;
  totalGPUs: number;
  onlineCount: number;
}

export interface Job {
  id: string;
  type: JobType;
  complexity: number;
  data: any;
}

export interface SwarmSnapshot {
  runState: "IDLE" | "RUNNING" | "PAUSED" | "STOPPED";
  devices: Record<string, DeviceInfo>;
  stats: {
    totalJobs: number;
    activeJobs: number;
    pendingJobs: number;
    completedJobs: number;
    globalVelocity: number;
    globalThrottle: number;
  };
  resources: SwarmResources;
}
</file>

<file path="server/src/managers/DeviceManager.ts">
import { type DeviceInfo, type DeviceCapabilities } from "../core/types";

export class DeviceManager {
  private devices = new Map<string, DeviceInfo>();
  private readonly OFFLINE_THRESHOLD = 30000;
  private readonly DELETE_THRESHOLD = 90000;

  constructor() {
    setInterval(() => this.cleanup(), 5000);
  }

  public register(
    id: string,
    name: string,
    caps: DeviceCapabilities,
    swarmId: string,
  ) {
    const existing = this.devices.get(id);
    this.devices.set(id, {
      id,
      name,
      type: caps.gpuAvailable ? "SERVER" : "DESKTOP",
      // Set to REGISTERED immediately on handshake
      status: "REGISTERED",
      capabilities: caps,
      opsScore: existing?.opsScore || 0,
      totalJobsCompleted: existing?.totalJobsCompleted || 0,
      lastHeartbeat: Date.now(),
      lastUserInteraction: Date.now(),
      swarmId,
    });
  }

  public heartbeat(id: string, data?: { lastInteraction: number }) {
    const device = this.devices.get(id);
    if (!device) return;

    device.lastHeartbeat = Date.now();
    if (data?.lastInteraction)
      device.lastUserInteraction = data.lastInteraction;

    // If they heartbeat, they are ONLINE
    if (device.status === "OFFLINE" || device.status === "REGISTERED") {
      device.status = "ONLINE";
    }
  }

  public toggleDevice(id: string, enabled: boolean) {
    const device = this.devices.get(id);
    if (device) device.status = enabled ? "ONLINE" : "DISABLED";
  }

  public updateScore(id: string, score: number) {
    const device = this.devices.get(id);
    if (device) device.opsScore = score;
  }

  public getDevicesBySwarm(swarmId: string) {
    return Array.from(this.devices.values()).filter(
      (d) => d.swarmId === swarmId,
    );
  }

  public getAvailableResources(swarmId: string) {
    let [totalCores, totalMemory, totalGPUs, onlineCount] = [0, 0, 0, 0];

    this.getDevicesBySwarm(swarmId).forEach((d) => {
      if (
        d.status === "ONLINE" ||
        d.status === "BUSY" ||
        d.status === "REGISTERED"
      ) {
        totalCores += d.capabilities.cpuCores;
        totalMemory += d.capabilities.memoryGB;
        if (d.capabilities.gpuAvailable) totalGPUs++;
        onlineCount++;
      }
    });

    return { totalCores, totalMemory, totalGPUs, onlineCount };
  }

  public getDevice(id: string) {
    return this.devices.get(id);
  }

  public remove(id: string) {
    this.devices.delete(id);
  }

  private cleanup() {
    const now = Date.now();
    this.devices.forEach((device, id) => {
      const diff = now - device.lastHeartbeat;

      if (diff > this.DELETE_THRESHOLD) {
        this.devices.delete(id);
      } else if (
        device.status !== "DISABLED" &&
        diff > this.OFFLINE_THRESHOLD
      ) {
        device.status = "OFFLINE";
      }
    });
  }
}
</file>

<file path="client/src/features/connection/DeviceConnector.tsx">
import { QRCodeSVG } from "qrcode.react";
import {
  X,
  Copy,
  RefreshCw,
  LogOut,
  ArrowRight,
  Camera,
  Smartphone,
} from "lucide-react";
import { Card } from "../../components/Card";
import { useEffect, useState, useCallback, useRef } from "react";
import { Html5Qrcode } from "html5-qrcode";
interface CameraConstraints extends MediaTrackConstraints {
  focusMode?: string;
  zoom?: number;
}
interface DeviceConnectorProps {
  readonly isOpen: boolean;
  readonly onClose: () => void;
  readonly onRegenerateToken: () => Promise<string>;
  readonly onManualJoin: (code: string) => void;
  readonly onLeave: () => void;
  readonly isConnected: boolean;
  readonly isGuest: boolean;
}

export const DeviceConnector = ({
  isOpen,
  onClose,
  onRegenerateToken,
  onManualJoin,
  onLeave,
  isConnected,
  isGuest,
}: DeviceConnectorProps) => {
  const [token, setToken] = useState<string>("");
  const [inputCode, setInputCode] = useState<string>("");
  const [isLoading, setIsLoading] = useState(false);
  const [isScanning, setIsScanning] = useState(false);
  const scannerRef = useRef<Html5Qrcode | null>(null);

  const handleRegenerate = useCallback(async () => {
    if (isGuest || isLoading) return;
    setIsLoading(true);
    try {
      const newToken = await onRegenerateToken();
      setToken(newToken);
    } catch (err) {
      console.error("[UI] Token Generation Failed", err);
    } finally {
      setIsLoading(false);
    }
  }, [onRegenerateToken, isGuest, isLoading]);

  const stopScanner = useCallback(async () => {
    if (scannerRef.current && scannerRef.current.isScanning) {
      await scannerRef.current.stop();
    }
    setIsScanning(false);
  }, []);

  const startScanner = useCallback(async () => {
    setIsScanning(true);
    // Use a delay to ensure React has rendered the #reader div
    setTimeout(async () => {
      const element = document.getElementById("reader");
      if (!element) {
        console.error("[UI] Scanner div #reader not found");
        setIsScanning(false);
        return;
      }

      try {
        const html5QrCode = new Html5Qrcode("reader");
        scannerRef.current = html5QrCode;
        await html5QrCode.start(
          { facingMode: { exact: "environment" } }, // Force back camera
          {
            fps: 20,
            qrbox: { width: 220, height: 220 },
            aspectRatio: 1.0,
            videoConstraints: {
              focusMode: "continuous",
              zoom: 1.5, // Attempt to start slightly zoomed in for better focus
            } as CameraConstraints,
          },
          (decodedText) => {
            // Trim whitespace and handle potential full URLs if people use old codes
            const code = decodedText.includes("invite=")
              ? decodedText.split("invite=")[1].split("&")[0]
              : decodedText.trim();

            stopScanner();
            onManualJoin(code); // Directly trigger the connection
            onClose();
          },
          () => {},
        );
      } catch (err) {
        setIsScanning(false);
      }
    }, 150);
  }, [onManualJoin, onClose, stopScanner]);

  // Handle Token Generation on Open
  useEffect(() => {
    if (isOpen && !isGuest && !token && !isLoading) {
      handleRegenerate();
    }
  }, [isOpen, isGuest, token, isLoading, handleRegenerate]);

  // Cleanup Scanner on Close
  useEffect(() => {
    if (!isOpen && isScanning) {
      stopScanner();
    }
  }, [isOpen, isScanning, stopScanner]);

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-gray-900/60 backdrop-blur-md p-6">
      <Card
        className="max-w-sm w-full relative p-6 space-y-6"
        variant="elevated"
      >
        <button
          onClick={onClose}
          className="absolute top-4 right-4 p-2 hover:bg-gray-100 rounded-full transition-colors"
        >
          <X size={18} className="text-text-muted" />
        </button>

        <div className="text-center space-y-4">
          <h3 className="text-xl font-bold">Swarm Access</h3>

          {isGuest ? (
            <div className="p-4 bg-red-50 border border-red-100 rounded-2xl space-y-3">
              <p className="text-[10px] font-black text-red-500 uppercase">
                Swarm Guest Mode
              </p>
              <button
                onClick={onLeave}
                className="w-full flex items-center justify-center gap-2 bg-red-500 text-white py-3 rounded-xl font-bold text-xs hover:bg-red-600"
              >
                <LogOut size={14} /> Exit Swarm
              </button>
            </div>
          ) : (
            <div className="space-y-6">
              <div className="flex bg-gray-100/80 p-1 rounded-2xl shadow-inner border border-gray-200/50 mx-auto w-fit">
                <button
                  onClick={stopScanner}
                  className={`flex items-center gap-2 px-4 py-1.5 rounded-xl text-[10px] font-black uppercase tracking-wider transition-all ${!isScanning ? "bg-white text-brand-orange shadow-sm" : "text-text-muted"}`}
                >
                  <Smartphone size={12} /> Share
                </button>
                <button
                  onClick={startScanner}
                  className={`flex items-center gap-2 px-4 py-1.5 rounded-xl text-[10px] font-black uppercase tracking-wider transition-all ${isScanning ? "bg-white text-brand-orange shadow-sm" : "text-text-muted"}`}
                >
                  <Camera size={12} /> Scan
                </button>
              </div>

              {!isScanning ? (
                <div className="space-y-4 animate-in fade-in slide-in-from-bottom-2">
                  <div className="relative inline-block p-4 bg-white border border-border-soft rounded-3xl shadow-sm">
                    {isLoading && (
                      <div className="absolute inset-0 z-10 bg-white/80 flex items-center justify-center rounded-3xl">
                        <RefreshCw
                          size={24}
                          className="animate-spin text-brand-orange"
                        />
                      </div>
                    )}
                    {/* Fixed: QR only shows if token exists */}
                    <QRCodeSVG
                      value={token || "OSTRICH_WAITING"} // Encode ONLY the token
                      size={180}
                      level="M"
                      includeMargin
                    />
                  </div>

                  <div className="bg-gray-100 p-3 rounded-xl border border-dashed flex items-center justify-between">
                    <div className="text-left">
                      <p className="text-[9px] font-black text-gray-400 uppercase">
                        Join Code
                      </p>
                      <p className="font-mono font-bold text-brand-orange">
                        {token || "GENERATING..."}
                      </p>
                    </div>
                    <div className="flex gap-1">
                      <button
                        onClick={handleRegenerate}
                        className="p-2 hover:bg-white rounded-lg"
                      >
                        <RefreshCw
                          size={16}
                          className={isLoading ? "animate-spin" : ""}
                        />
                      </button>
                      <button
                        onClick={() =>
                          token && navigator.clipboard.writeText(token)
                        }
                        className="p-2 hover:bg-white rounded-lg"
                      >
                        <Copy size={16} />
                      </button>
                    </div>
                  </div>
                </div>
              ) : (
                <div className="animate-in fade-in zoom-in-95">
                  <div className="relative w-full aspect-square max-w-60 mx-auto bg-black rounded-[40px] border-8 border-surface-white overflow-hidden shadow-inner">
                    <div
                      id="reader"
                      className="w-full h-full [&_video]:object-cover [&_video]:rounded-[32px]"
                    />
                    {/* Scan overlay line */}
                    <div className="absolute inset-0 border-2 border-brand-orange/30 rounded-[32px] pointer-events-none">
                      <div className="absolute top-0 left-0 w-full h-2 bg-brand-orange/50 shadow-[0_0_15px_rgba(255,125,84,0.8)] animate-[scan_2s_linear_indefinite]" />
                    </div>
                  </div>
                  <p className="text-[10px] font-bold text-text-muted uppercase mt-4">
                    Point at a Swarm QR Code
                  </p>
                </div>
              )}
            </div>
          )}
        </div>

        <div className="border-t pt-6 space-y-3">
          <p className="text-[10px] font-black text-text-muted uppercase tracking-widest text-left">
            Manual Join
          </p>
          <div className="flex gap-2">
            <input
              type="text"
              maxLength={6}
              value={inputCode}
              onChange={(e) => setInputCode(e.target.value.toUpperCase())}
              placeholder="ENTER CODE"
              className="flex-1 bg-gray-100 border border-border-soft rounded-xl px-4 py-3 font-mono font-bold text-sm focus:outline-brand-orange"
            />
            <button
              onClick={() => {
                onManualJoin(inputCode);
                // Don't close immediately so user sees "Connecting"
              }}
              disabled={inputCode.length < 4 || !isConnected} // Optional: visual state
              className="bg-gray-900 text-white p-3 rounded-xl hover:bg-black disabled:opacity-50 relative"
            >
              {!isConnected && inputCode.length >= 4 ? (
                <RefreshCw size={20} className="animate-spin" />
              ) : (
                <ArrowRight size={20} />
              )}
            </button>
          </div>
        </div>
      </Card>
    </div>
  );
};
</file>

<file path="client/src/hooks/useSwarmEngine.ts">
import { useEffect, useRef, useState, useCallback } from "react";
import { io, Socket } from "socket.io-client";
import { SocketEvents } from "@shared/socket/events";
import { type LogLevel, type SystemLogPayload } from "@shared/socket/states";
import { type SwarmSnapshot, type SwarmStatus, type Job } from "../core/types";
// Import the constructor directly
import ComputeWorker from "../utils/compute.worker?worker";

export const useSwarmEngine = (persistentId: string) => {
  const [snapshot, setSnapshot] = useState<SwarmSnapshot | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [logs, setLogs] = useState<string[]>([]);
  const socketRef = useRef<Socket | null>(null);
  const workerRef = useRef<Worker | null>(null);

  const addLog = useCallback((level: LogLevel, message: string) => {
    const time = new Date().toLocaleTimeString().split(" ")[0];
    setLogs((prev) => [...prev.slice(-49), `[${time}] [${level}] ${message}`]);
  }, []);

  const handleWorkerMessage = useCallback(
    (e: MessageEvent) => {
      const { type, score, chunkId, result, error, message, level } = e.data;

      switch (type) {
        case "WORKER_LOG":
          addLog(level || "SYS", message);
          break;
        case "BENCHMARK_COMPLETE":
          socketRef.current?.emit(SocketEvents.BENCHMARK_RESULT, { score });
          addLog("CPU", `Benchmark: ${score.toLocaleString()} OPS/s`);
          break;
        case "JOB_COMPLETE":
          socketRef.current?.emit(SocketEvents.JOB_COMPLETE, {
            chunkId,
            result,
            workerId: persistentId,
          });
          socketRef.current?.emit(SocketEvents.JOB_REQUEST_BATCH); // Keep pipeline full
          break;
        case "JOB_ERROR":
          addLog("ERR", `Job ${chunkId} failed: ${error}`);
          socketRef.current?.emit(SocketEvents.JOB_COMPLETE, {
            chunkId,
            error,
            workerId: persistentId,
          });
          socketRef.current?.emit(SocketEvents.JOB_REQUEST_BATCH);
          break;
      }
    },
    [persistentId, addLog],
  );

  // Track the current token to prevent redundant connections
  const currentTokenRef = useRef<string | null>(null);

  const connect = useCallback(
    (manualToken?: string) => {
      // If we are already connected to this specific token/swarm, do nothing
      const inviteToken =
        manualToken ||
        new URLSearchParams(window.location.search).get("invite") ||
        "";
      if (
        socketRef.current?.connected &&
        currentTokenRef.current === inviteToken &&
        !manualToken
      ) {
        return;
      }

      if (socketRef.current) {
        socketRef.current.disconnect();
      }

      currentTokenRef.current = inviteToken;
      const isTunnel = window.location.hostname.includes("trycloudflare.com");
      const serverUrl = isTunnel
        ? "/"
        : `http://${window.location.hostname}:3000`;

      const socket = io(serverUrl, {
        query: { persistentId, token: inviteToken },
        auth: { token: inviteToken },
        transports: ["websocket"],
        reconnection: true,
        reconnectionAttempts: 15,
        path: "/socket.io/",
      });

      socketRef.current = socket;

      socket.on(SocketEvents.CONNECT, () => {
        setIsConnected(true);
        addLog("NET", "Swarm Link Established");

        socket.emit(SocketEvents.DEVICE_REGISTER, {
          name: localStorage.getItem("ostrich_device_name") || "Local Node",
          capabilities: {
            cpuCores: navigator.hardwareConcurrency || 4,
            memoryGB: (navigator as any).deviceMemory || 8,
            gpuAvailable: !!(navigator as any).gpu,
          },
        });

        // --- ADD HEARTBEAT EMITTER ---
        const hbInterval = setInterval(() => {
          if (socket.connected) {
            socket.emit(SocketEvents.HEARTBEAT, {
              lastInteraction: Date.now(),
            });
          }
        }, 10000); // Every 10s

        socket.on("disconnect", () => clearInterval(hbInterval));
        // -----------------------------

        socket.emit(SocketEvents.JOB_REQUEST_BATCH);
        workerRef.current?.postMessage({ type: "BENCHMARK" });
      });

      // Add error feedback
      socket.on("connect_error", (err) => {
        setIsConnected(false);
        addLog("ERR", `Connection failed: ${err.message}`);
      });

      socket.on(SocketEvents.SYSTEM_LOG, (payload: SystemLogPayload) => {
        addLog(payload.level, payload.message);
      });

      socket.on(SocketEvents.JOB_BATCH_DISPATCH, (jobs: Job[]) => {
        jobs.forEach((job) =>
          workerRef.current?.postMessage({ type: "EXECUTE_JOB", payload: job }),
        );
      });

      socket.on(SocketEvents.SWARM_SNAPSHOT, (data: SwarmSnapshot) => {
        setSnapshot((prev) => {
          // Check if we just transitioned to RUNNING
          if (prev?.runState !== "RUNNING" && data.runState === "RUNNING") {
            const isMobile = /iPhone|iPad|iPod|Android/i.test(
              navigator.userAgent,
            );
            setTimeout(
              () => {
                socketRef.current?.emit(SocketEvents.JOB_REQUEST_BATCH);
              },
              isMobile ? 800 : 0,
            );
          }
          return data;
        });
      });

      socket.on("disconnect", (reason) => {
        setIsConnected(false);
        if (reason !== "io client disconnect") {
          addLog("NET", `Link unstable: ${reason}.`);
        }
      });
    },
    [persistentId, addLog], // snapshot?.runState REMOVED
  );

  // 1. Initialize Worker once on mount
  useEffect(() => {
    const worker = new ComputeWorker();
    workerRef.current = worker;

    return () => {
      worker.terminate();
    };
  }, []);

  // 2. Sync worker message handler whenever it changes
  useEffect(() => {
    if (workerRef.current) {
      workerRef.current.onmessage = handleWorkerMessage;
    }
  }, [handleWorkerMessage]);

  // 3. Primary Connection Logic (Single instance)
  useEffect(() => {
    if (persistentId && persistentId !== "loading-identity") {
      connect();
    }
    return () => {
      // Disconnect socket only on unmount or ID change
      if (socketRef.current) {
        socketRef.current.disconnect();
      }
    };
  }, [persistentId, connect]);

  return {
    snapshot,
    devices: snapshot ? Object.values(snapshot.devices) : [],
    isConnected,
    logs,
    setRunState: (s: SwarmStatus) =>
      socketRef.current?.emit(SocketEvents.SWARM_SET_STATE, s),
    setGlobalThrottle: (v: number) =>
      socketRef.current?.emit(SocketEvents.SWARM_SET_THROTTLE, v),
    runLocalBenchmark: () =>
      workerRef.current?.postMessage({ type: "BENCHMARK" }),
    toggleDevice: (id: string, enabled: boolean) =>
      socketRef.current?.emit("cmd:toggle_device", { id, enabled }),
    manualJoin: (code: string) => connect(code),
    leaveSwarm: () => {
      window.location.href = window.location.origin;
    },
    // client/src/hooks/useSwarmEngine.ts
    generateInviteToken: () =>
      new Promise<string>((res) => {
        if (socketRef.current?.connected) {
          socketRef.current.emit("auth:generate_token", (token: string) => {
            res(token);
          });
        } else {
          res("");
        }
      }),
  };
};
</file>

<file path="server/src/index.ts">
import { Server } from "socket.io";
import { DeviceManager } from "./managers/DeviceManager";
import { JobScheduler } from "./managers/JobScheduler";
import { AuthManager } from "./managers/AuthManager";
import { type SwarmSnapshot } from "./core/types";
import { SocketEvents } from "@shared/socket/events";
import { type LogLevel, type SystemLogPayload } from "@shared/socket/states";

const io = new Server(3000, {
  cors: { origin: "*" },
  transports: ["websocket", "polling"],
});

const deviceManager = new DeviceManager();
const jobScheduler = new JobScheduler();
const authManager = new AuthManager();

const activeSwarmIds = new Set<string>();
const swarmStates = new Map<string, SwarmSnapshot["runState"]>();
const swarmCompletedCounts = new Map<string, number>();
const swarmThrottles = new Map<string, number>();

/**
 * Global System Logger
 * Broadcasts to terminal and server console
 */
const systemLog = (
  swarmId: string,
  level: LogLevel,
  message: string,
  source: string = "CORE",
) => {
  const payload: SystemLogPayload = {
    level,
    message,
    timestamp: Date.now(),
    source,
  };
  io.to(swarmId).emit(SocketEvents.SYSTEM_LOG, payload);
};

// Auth Middleware (as we fixed in Phase 0)
io.use((socket, next) => {
  // Priority: 1. Handshake Auth, 2. Query Parameter (Fallback for stability)
  const token = socket.handshake.auth.token || socket.handshake.query.token;
  const persistentId = socket.handshake.query.persistentId as string;

  if (!persistentId) return next(new Error("MISSING_PERSISTENT_ID"));

  // If no token is provided anywhere, this device is its own Master
  if (!token || token === "null" || token === "undefined" || token === "") {
    socket.data.swarmId = persistentId;
    return next();
  }

  const targetSwarm = authManager.validateToken(token as string);
  if (targetSwarm) {
    socket.data.swarmId = targetSwarm;
    return next();
  }

  // Fallback: If token exists but is invalid/expired, join own swarm instead of dropping
  socket.data.swarmId = persistentId;
  return next();
});

io.on("connection", (socket) => {
  const persistentId = socket.handshake.query.persistentId as string;
  const swarmId = socket.data.swarmId;
  activeSwarmIds.add(swarmId);

  socket.join(swarmId);
  systemLog(
    swarmId,
    "NET",
    `Socket connected: ${persistentId.slice(0, 8)}`,
    "GATEWAY",
  );

  // Protocol: Registration
  socket.on(SocketEvents.DEVICE_REGISTER, (data) => {
    deviceManager.register(persistentId, data.name, data.capabilities, swarmId);
    systemLog(swarmId, "SYS", `Node Registered: ${data.name}`, "AUTH");
    deviceManager.heartbeat(persistentId);
    broadcastState(swarmId);
  });

  // Protocol: Heartbeat
  socket.on(SocketEvents.HEARTBEAT, (data) => {
    deviceManager.heartbeat(persistentId, data);
  });

  // Protocol: Job Pipeline
  socket.on(SocketEvents.JOB_REQUEST_BATCH, () => {
    const currentState = swarmStates.get(swarmId);
    const device = deviceManager.getDevice(persistentId);

    // INVARIANT: Check if registered and running
    if (!device || device.status === "OFFLINE") {
      systemLog(
        swarmId,
        "ERR",
        `Job request rejected: Node not registered.`,
        persistentId,
      );
      return;
    }

    if (currentState !== "RUNNING") return;

    const batch = [];
    for (let i = 0; i < 5; i++) {
      const job = jobScheduler.getJobForDevice(device);
      if (job) batch.push(job);
    }

    if (batch.length > 0) {
      socket.emit(SocketEvents.JOB_BATCH_DISPATCH, batch);
    }
  });

  socket.on(SocketEvents.JOB_COMPLETE, (payload) => {
    if (!payload.error) {
      swarmCompletedCounts.set(
        swarmId,
        (swarmCompletedCounts.get(swarmId) || 0) + 1,
      );
      const device = deviceManager.getDevice(persistentId);
      if (device) device.totalJobsCompleted++;
    } else {
      systemLog(
        swarmId,
        "ERR",
        `Job ${payload.chunkId} failed on ${persistentId}`,
        "COMPUTE",
      );
    }
  });

  // --- ADD THIS HANDLER ---
  socket.on("auth:generate_token", (callback: (token: string) => void) => {
    try {
      const token = authManager.generateToken(swarmId);
      systemLog(swarmId, "SYS", `Generated new invite code: ${token}`, "AUTH");
      callback(token);
    } catch (err) {
      console.error("Token generation error:", err);
      callback("");
    }
  });
  // Swarm Controls
  socket.on(SocketEvents.SWARM_SET_STATE, (state) => {
    swarmStates.set(swarmId, state);
    systemLog(swarmId, "SYS", `Swarm state changed to ${state}`, "MASTER");
    broadcastState(swarmId);
  });

  socket.on(SocketEvents.SWARM_SET_THROTTLE, (val) => {
    swarmThrottles.set(swarmId, val);
    io.to(swarmId).emit(SocketEvents.SWARM_THROTTLE_SYNC, val);
  });

  socket.on(SocketEvents.BENCHMARK_RESULT, (data) => {
    deviceManager.updateScore(persistentId, data.score);
    systemLog(
      swarmId,
      "CPU",
      `Benchmark: ${data.score.toLocaleString()} OPS`,
      persistentId,
    );
    broadcastState(swarmId);
  });
  // server/src/index.ts -> inside io.on("connection")

  // server/src/index.ts -> inside io.on("connection")

  // --- ADD THIS HANDLER TO THE SERVER ---
  socket.on(
    "cmd:toggle_device",
    ({ id, enabled }: { id: string; enabled: boolean }) => {
      deviceManager.toggleDevice(id, enabled);

      systemLog(
        swarmId,
        enabled ? "SYS" : "WARN",
        `Node ${id.slice(0, 8)} was ${enabled ? "enabled" : "disabled"} by Master`,
        "ORCHESTRATOR",
      );

      // Force update to all nodes so the UI updates immediately
      broadcastState(swarmId);
    },
  );

  // --- ADD THIS HANDLER FOR THE GENERATOR ---
  socket.on("auth:generate_token", (callback: (token: string) => void) => {
    const token = authManager.generateToken(swarmId);
    callback(token);
  });

  socket.on("disconnect", () => {
    // Check if room is empty before removing swarmId from broadcaster
    const room = io.sockets.adapter.rooms.get(swarmId);
    if (!room || room.size === 0) {
      activeSwarmIds.delete(swarmId);
    }
    systemLog(
      swarmId,
      "NET",
      `Node offline: ${persistentId.slice(0, 8)}`,
      "GATEWAY",
    );
  });
});

/**
 * Single Global Snapshot Loop
 * Prevents interval leaks
 */
function broadcastState(swarmId: string) {
  const resources = deviceManager.getAvailableResources(swarmId);
  const queue = jobScheduler.getQueueStats();
  const allDevices = deviceManager.getDevicesBySwarm(swarmId);
  const currentState = swarmStates.get(swarmId) || "STOPPED";
  const completedCount = swarmCompletedCounts.get(swarmId) || 0;
  const currentThrottle = swarmThrottles.get(swarmId) || 40;

  const totalOpsScore = allDevices
    .filter((d) => d.status !== "OFFLINE" && d.status !== "DISABLED")
    .reduce((sum, d) => sum + (d.opsScore || 0), 0);

  const snapshot: SwarmSnapshot = {
    runState: currentState,
    devices: allDevices.reduce((acc, d) => ({ ...acc, [d.id]: d }), {}),
    stats: {
      totalJobs: completedCount + queue.pending,
      activeJobs: currentState === "RUNNING" ? resources.onlineCount : 0,
      pendingJobs: queue.pending,
      completedJobs: completedCount,
      globalVelocity: currentState === "RUNNING" ? totalOpsScore : 0,
      globalThrottle: currentThrottle,
    },
    resources,
  };

  io.to(swarmId).emit(SocketEvents.SWARM_SNAPSHOT, snapshot);
}

// Tick all active swarms every 2s
setInterval(() => {
  activeSwarmIds.forEach((id) => {
    // Only broadcast if there are actually sockets in that room
    const room = io.sockets.adapter.rooms.get(id);
    if (room && room.size > 0) {
      broadcastState(id);
    } else {
      activeSwarmIds.delete(id);
    }
  });
}, 2000);

console.log("ðŸš€ Ostrich Swarm Coordinator [PHASE 2] Online");
</file>

<file path="client/src/App.tsx">
import { useState, useEffect, useRef, useMemo } from "react";
import { Wifi, Share2, LogOut, RefreshCw } from "lucide-react";
import { useSwarmEngine } from "./hooks/useSwarmEngine";
import { VelocityMonitor } from "./features/dashboard/VelocityMonitor";
import { ActiveSwarm } from "./features/dashboard/ActiveSwarm";
import { ResourceStats } from "./features/dashboard/ResourceStats";
import { JobGauge } from "./features/dashboard/JobGauge";
import { ThrottleControl } from "./features/dashboard/ThrottleControl";
import { LiveTerminal } from "./features/terminal/LiveTerminal";
import { DeviceConnector } from "./features/connection/DeviceConnector";
import { SwarmControls } from "./features/dashboard/SwarmControls";
import { usePersistentIdentity } from "./hooks/usePersistentIdentity";

export default function App() {
  const [activeTab, setActiveTab] = useState("Dashboard");
  const [isModalOpen, setIsModalOpen] = useState(false);
  const identity = usePersistentIdentity();

  // Optimistic UI state for the slider
  const [localThrottle, setLocalThrottle] = useState(40);
  const debounceTimer = useRef<NodeJS.Timeout | null>(null);

  const {
    snapshot,
    devices,
    setRunState,
    runLocalBenchmark,
    isConnected,
    toggleDevice,
    setGlobalThrottle,
    generateInviteToken,
    logs,
    leaveSwarm,
    manualJoin,
  } = useSwarmEngine(identity.id || "loading-identity");

  // Derive resources from snapshot or default to empty
  const totalResources = useMemo(() => {
    if (snapshot?.resources) return snapshot.resources;
    return {
      totalCores: 0,
      totalMemory: 0,
      totalGPUs: 0,
      onlineCount: 0,
    };
  }, [snapshot]);

  const stats = useMemo(() => {
    if (snapshot?.stats) return snapshot.stats;
    return {
      totalJobs: 0,
      activeJobs: 0,
      pendingJobs: 0,
      completedJobs: 0,
      globalVelocity: 0,
      globalThrottle: 40,
    };
  }, [snapshot]);

  const isRunning = snapshot?.runState === "RUNNING";
  const isGuest = new URLSearchParams(window.location.search).has("invite");

  // Sync slider if someone else changes the global throttle
  useEffect(() => {
    if (stats.globalThrottle !== undefined) {
      setLocalThrottle(stats.globalThrottle);
    }
  }, [stats.globalThrottle]);

  const handleThrottleChange = (val: number) => {
    setLocalThrottle(val);
    if (debounceTimer.current) clearTimeout(debounceTimer.current);
    debounceTimer.current = setTimeout(() => {
      setGlobalThrottle(val);
    }, 300);
  };

  return (
    <div className="min-h-screen bg-surface-muted p-4 md:p-8 font-sans antialiased text-text-main">
      <header className=" max-w-7xl mx-auto flex items-center mb-8 bg-surface-white/90 backdrop-blur-md px-6 py-4 rounded-[32px] border border-white shadow-lg sticky top-4 z-50 w-full">
        {/* Left: Identity - Forced to grow from 0 to share space equally */}
        <div className="flex items-center gap-4 flex-1 basis-0">
          <div className="w-12 h-12 bg-surface-white rounded-2xl flex items-center justify-center shadow-soft-depth border border-white relative overflow-hidden group">
            <svg
              viewBox="0 0 512 512"
              className="w-10 h-10 transition-transform duration-500 group-hover:scale-110"
            >
              <path
                d="M256 120V256M256 256L140 380M256 256L372 380"
                stroke="#1a1a1e"
                strokeWidth="48"
                strokeLinecap="round"
                strokeLinejoin="round"
              />
              <path
                d="M256 130V256M256 256L150 370M256 256L362 370"
                stroke="#ff7d54"
                strokeWidth="24"
                strokeLinecap="round"
                strokeLinejoin="round"
              />
              <circle cx="256" cy="256" r="55" fill="#1a1a1e" />
              <circle
                cx="256"
                cy="256"
                r="30"
                fill="#ff7d54"
                className="animate-pulse"
              />
            </svg>
          </div>
          <div className="hidden sm:flex flex-col justify-center -space-y-1">
            <span className="text-lg md:text-xl font-black tracking-tighter text-gray-800 leading-tight">
              Ostrich-Legs
            </span>
            <div
              className={`flex items-center gap-1.5 text-[9px] font-bold transition-colors ${
                isConnected ? "text-green-600" : "text-amber-500 animate-pulse"
              }`}
            >
              {isConnected ? (
                <Wifi size={10} />
              ) : (
                <RefreshCw size={10} className="animate-spin" />
              )}
              {isConnected ? "CONNECTED" : "ESTABLISHING LINK..."}
            </div>
          </div>

          {/* Center: Navigation - shrink-0 ensures it stays centered and doesn't compress */}
          <nav className="absolute left-1/2 -translate-x-1/2 hidden lg:flex items-center gap-1 bg-gray-100/80 p-1.5 rounded-2xl shadow-inner border border-gray-200/50">
            {["Dashboard", "Monitoring"].map((tab) => (
              <button
                key={tab}
                onClick={() => setActiveTab(tab)}
                className={`px-6 py-2 rounded-xl text-xs font-bold transition-all duration-200 ${
                  activeTab === tab
                    ? "bg-white text-brand-orange shadow-sm border border-gray-100"
                    : "text-text-muted hover:text-text-main"
                }`}
              >
                {tab}
              </button>
            ))}
          </nav>

          {/* Right: Actions */}

          <div className="ml-auto flex items-center gap-3">
            {isConnected && (
              <button
                onClick={leaveSwarm}
                className="flex items-center gap-2.5 bg-red-50 text-red-600 px-5 py-2.5 rounded-2xl text-[11px] font-bold border border-red-100 hover:bg-red-500 hover:text-white transition-all uppercase tracking-wider shadow-sm active:scale-95"
              >
                <LogOut size={16} />
                <span className="hidden sm:inline">
                  {isGuest ? "Leave Swarm" : "Exit Session"}
                </span>
              </button>
            )}
            <button
              onClick={() => setIsModalOpen(true)}
              className="p-2 hover:bg-gray-100 rounded-xl transition-colors"
            >
              <Share2 size={20} className="text-text-muted" />
            </button>
          </div>
        </div>
      </header>

      <main className="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-12 gap-8 pb-12">
        {activeTab === "Dashboard" ? (
          <>
            <div className="lg:col-span-8 space-y-8 flex flex-col">
              <VelocityMonitor
                velocity={stats.globalVelocity}
                throttle={localThrottle}
              />
              <ResourceStats stats={stats} onlineCount={devices.length} />
              {/* Tailwind 4 arbitrary value for minimum height constraint */}
              <div className="flex-1 min-h-100">
                <ActiveSwarm
                  devices={devices}
                  onBenchmark={runLocalBenchmark}
                  onToggle={toggleDevice}
                />
              </div>
            </div>

            <div className="lg:col-span-4 space-y-8">
              <JobGauge
                total={stats.totalJobs}
                completed={stats.completedJobs}
              />
              <SwarmControls
                status={snapshot?.runState || "STOPPED"}
                onToggle={() => setRunState(isRunning ? "PAUSED" : "RUNNING")}
                onStop={() => setRunState("STOPPED")}
              />
              <ThrottleControl
                value={localThrottle}
                onChange={handleThrottleChange}
                totalGPUs={totalResources.totalGPUs}
                totalCores={totalResources.totalCores}
                totalMemory={totalResources.totalMemory}
              />
            </div>
          </>
        ) : (
          <div className="lg:col-span-12 h-[80vh]">
            <LiveTerminal logs={logs} />
          </div>
        )}
      </main>

      <DeviceConnector
        isOpen={isModalOpen}
        isConnected
        onClose={() => setIsModalOpen(false)}
        onRegenerateToken={generateInviteToken}
        onManualJoin={manualJoin}
        onLeave={leaveSwarm}
        isGuest={isGuest}
      />
    </div>
  );
}
</file>

</files>
